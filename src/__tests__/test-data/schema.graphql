schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

input AiRequestInput {
  imagesBase64: [String!]
  kind: String!
  metadata: jsonb
  textInput: String
}

type AiRequestOutput {
  data: jsonb!
}

"""
columns and relationships of "auth_account"
"""
type AuthAccount {
  accessToken: String
  accessTokenExpiresAt: timestamptz
  accountId: String!

  """An object relationship"""
  authUser: AuthUser!
  createdAt: timestamptz!
  id: uuid!
  idToken: String
  password: String
  profileId: uuid!
  providerId: String!
  refreshToken: String
  refreshTokenExpiresAt: timestamptz
  scope: String
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "auth_account"
"""
type AuthAccountAggregate {
  aggregate: AuthAccountAggregateFields
  nodes: [AuthAccount!]!
}

input AuthAccountAggregateBoolExp {
  count: authAccountAggregateBoolExpCount
}

"""
aggregate fields of "auth_account"
"""
type AuthAccountAggregateFields {
  count(columns: [AuthAccountSelectColumn!], distinct: Boolean): Int!
  max: AuthAccountMaxFields
  min: AuthAccountMinFields
}

"""
order by aggregate values of table "auth_account"
"""
input AuthAccountAggregateOrderBy {
  count: OrderBy
  max: AuthAccountMaxOrderBy
  min: AuthAccountMinOrderBy
}

"""
input type for inserting array relation for remote table "auth_account"
"""
input AuthAccountArrRelInsertInput {
  data: [AuthAccountInsertInput!]!

  """upsert condition"""
  onConflict: AuthAccountOnConflict
}

"""
Boolean expression to filter rows from the table "auth_account". All fields are combined with a logical 'AND'.
"""
input AuthAccountBoolExp {
  _and: [AuthAccountBoolExp!]
  _not: AuthAccountBoolExp
  _or: [AuthAccountBoolExp!]
  accessToken: StringComparisonExp
  accessTokenExpiresAt: TimestamptzComparisonExp
  accountId: StringComparisonExp
  authUser: AuthUserBoolExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  idToken: StringComparisonExp
  password: StringComparisonExp
  profileId: UuidComparisonExp
  providerId: StringComparisonExp
  refreshToken: StringComparisonExp
  refreshTokenExpiresAt: TimestamptzComparisonExp
  scope: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "auth_account"
"""
enum AuthAccountConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  auth_account_pkey
}

"""
input type for inserting data into table "auth_account"
"""
input AuthAccountInsertInput {
  accessToken: String
  accessTokenExpiresAt: timestamptz
  accountId: String
  authUser: AuthUserObjRelInsertInput
  createdAt: timestamptz
  id: uuid
  idToken: String
  password: String
  profileId: uuid
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamptz
  scope: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type AuthAccountMaxFields {
  accessToken: String
  accessTokenExpiresAt: timestamptz
  accountId: String
  createdAt: timestamptz
  id: uuid
  idToken: String
  password: String
  profileId: uuid
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamptz
  scope: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth_account"
"""
input AuthAccountMaxOrderBy {
  accessToken: OrderBy
  accessTokenExpiresAt: OrderBy
  accountId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  password: OrderBy
  profileId: OrderBy
  providerId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresAt: OrderBy
  scope: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type AuthAccountMinFields {
  accessToken: String
  accessTokenExpiresAt: timestamptz
  accountId: String
  createdAt: timestamptz
  id: uuid
  idToken: String
  password: String
  profileId: uuid
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamptz
  scope: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth_account"
"""
input AuthAccountMinOrderBy {
  accessToken: OrderBy
  accessTokenExpiresAt: OrderBy
  accountId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  password: OrderBy
  profileId: OrderBy
  providerId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresAt: OrderBy
  scope: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "auth_account"
"""
type AuthAccountMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AuthAccount!]!
}

"""
on_conflict condition type for table "auth_account"
"""
input AuthAccountOnConflict {
  constraint: AuthAccountConstraint!
  updateColumns: [AuthAccountUpdateColumn!]! = []
  where: AuthAccountBoolExp
}

"""Ordering options when selecting data from "auth_account"."""
input AuthAccountOrderBy {
  accessToken: OrderBy
  accessTokenExpiresAt: OrderBy
  accountId: OrderBy
  authUser: AuthUserOrderBy
  createdAt: OrderBy
  id: OrderBy
  idToken: OrderBy
  password: OrderBy
  profileId: OrderBy
  providerId: OrderBy
  refreshToken: OrderBy
  refreshTokenExpiresAt: OrderBy
  scope: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: auth_account"""
input AuthAccountPkColumnsInput {
  id: uuid!
}

"""
select columns of table "auth_account"
"""
enum AuthAccountSelectColumn {
  """column name"""
  accessToken

  """column name"""
  accessTokenExpiresAt

  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  idToken

  """column name"""
  password

  """column name"""
  profileId

  """column name"""
  providerId

  """column name"""
  refreshToken

  """column name"""
  refreshTokenExpiresAt

  """column name"""
  scope

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth_account"
"""
input AuthAccountSetInput {
  accessToken: String
  accessTokenExpiresAt: timestamptz
  accountId: String
  createdAt: timestamptz
  id: uuid
  idToken: String
  password: String
  profileId: uuid
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamptz
  scope: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "auth_account"
"""
input AuthAccountStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuthAccountStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuthAccountStreamCursorValueInput {
  accessToken: String
  accessTokenExpiresAt: timestamptz
  accountId: String
  createdAt: timestamptz
  id: uuid
  idToken: String
  password: String
  profileId: uuid
  providerId: String
  refreshToken: String
  refreshTokenExpiresAt: timestamptz
  scope: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "auth_account"
"""
enum AuthAccountUpdateColumn {
  """column name"""
  accessToken

  """column name"""
  accessTokenExpiresAt

  """column name"""
  accountId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  idToken

  """column name"""
  password

  """column name"""
  profileId

  """column name"""
  providerId

  """column name"""
  refreshToken

  """column name"""
  refreshTokenExpiresAt

  """column name"""
  scope

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input AuthAccountUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AuthAccountSetInput

  """filter the rows which have to be updated"""
  where: AuthAccountBoolExp!
}

input AuthAnonymousInput {
  deviceId: String!
}

input AuthEmailInput {
  email: citext!
  state: String
  useVerificationCode: Boolean
}

input AuthEmailPasswordInput {
  email: citext!
  password: String!
}

input AuthEmailPasswordSignUpInput {
  displayNameOverride: String
  email: citext!
  firstName: String
  lastName: String
  password: String!
  state: String
  useVerificationCode: Boolean
  username: citext
}

input AuthEmailSignupInput {
  displayNameOverride: String
  email: citext!
  firstName: String
  lastName: String
  state: String
  useVerificationCode: Boolean
  username: citext
}

input AuthEmailTicketInput {
  email: citext!
  ticket: String!
}

type AuthOutput {
  profileId: uuid
  refreshToken: String
  sessionId: String
  token: String
}

"""
columns and relationships of "auth_provider"
"""
type AuthProvider {
  clientId: String!
  clientSecret: String!
  createdAt: timestamptz!
  id: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "auth_provider"
"""
type AuthProviderAggregate {
  aggregate: AuthProviderAggregateFields
  nodes: [AuthProvider!]!
}

"""
aggregate fields of "auth_provider"
"""
type AuthProviderAggregateFields {
  count(columns: [AuthProviderSelectColumn!], distinct: Boolean): Int!
  max: AuthProviderMaxFields
  min: AuthProviderMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AuthProviderAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "auth_provider". All fields are combined with a logical 'AND'.
"""
input AuthProviderBoolExp {
  _and: [AuthProviderBoolExp!]
  _not: AuthProviderBoolExp
  _or: [AuthProviderBoolExp!]
  clientId: StringComparisonExp
  clientSecret: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  metadata: JsonbComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "auth_provider"
"""
enum AuthProviderConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  auth_provider_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AuthProviderDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AuthProviderDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AuthProviderDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "auth_provider"
"""
input AuthProviderInsertInput {
  clientId: String
  clientSecret: String
  createdAt: timestamptz
  id: String
  metadata: jsonb
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type AuthProviderMaxFields {
  clientId: String
  clientSecret: String
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type AuthProviderMinFields {
  clientId: String
  clientSecret: String
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "auth_provider"
"""
type AuthProviderMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AuthProvider!]!
}

"""
on_conflict condition type for table "auth_provider"
"""
input AuthProviderOnConflict {
  constraint: AuthProviderConstraint!
  updateColumns: [AuthProviderUpdateColumn!]! = []
  where: AuthProviderBoolExp
}

"""Ordering options when selecting data from "auth_provider"."""
input AuthProviderOrderBy {
  clientId: OrderBy
  clientSecret: OrderBy
  createdAt: OrderBy
  id: OrderBy
  metadata: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: auth_provider"""
input AuthProviderPkColumnsInput {
  id: String!
  tenantId: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AuthProviderPrependInput {
  metadata: jsonb
}

"""
select columns of table "auth_provider"
"""
enum AuthProviderSelectColumn {
  """column name"""
  clientId

  """column name"""
  clientSecret

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth_provider"
"""
input AuthProviderSetInput {
  clientId: String
  clientSecret: String
  createdAt: timestamptz
  id: String
  metadata: jsonb
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "auth_provider"
"""
input AuthProviderStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuthProviderStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuthProviderStreamCursorValueInput {
  clientId: String
  clientSecret: String
  createdAt: timestamptz
  id: String
  metadata: jsonb
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "auth_provider"
"""
enum AuthProviderUpdateColumn {
  """column name"""
  clientId

  """column name"""
  clientSecret

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input AuthProviderUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AuthProviderAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AuthProviderDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AuthProviderDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AuthProviderDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AuthProviderPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: AuthProviderSetInput

  """filter the rows which have to be updated"""
  where: AuthProviderBoolExp!
}

input AuthResetPasswordInput {
  email: citext!
  password: String!
  ticket: String!
}

"""
columns and relationships of "auth_role_kind"
"""
type AuthRoleKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "auth_role_kind". All fields are combined with a logical 'AND'.
"""
input AuthRoleKindBoolExp {
  _and: [AuthRoleKindBoolExp!]
  _not: AuthRoleKindBoolExp
  _or: [AuthRoleKindBoolExp!]
  id: StringComparisonExp
}

enum AuthRoleKindEnum {
  ANONYMOUS
  PUBLIC
  TENANT_ADMIN
  USER
}

"""
Boolean expression to compare columns of type "AuthRoleKindEnum". All fields are combined with logical 'AND'.
"""
input AuthRoleKindEnumComparisonExp {
  _eq: AuthRoleKindEnum
  _in: [AuthRoleKindEnum!]
  _isNull: Boolean
  _neq: AuthRoleKindEnum
  _nin: [AuthRoleKindEnum!]
}

"""Ordering options when selecting data from "auth_role_kind"."""
input AuthRoleKindOrderBy {
  id: OrderBy
}

"""
select columns of table "auth_role_kind"
"""
enum AuthRoleKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "auth_role_kind"
"""
input AuthRoleKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuthRoleKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuthRoleKindStreamCursorValueInput {
  id: String
}

"""
columns and relationships of "auth_session"
"""
type AuthSession {
  createdAt: timestamptz!
  data(
    """JSON select path"""
    path: String
  ): jsonb!
  expiresAt: timestamptz!
  id: uuid!

  """An object relationship"""
  profile: Profile
  profileId: uuid
  tenantId: String!
  token: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "auth_session"
"""
type AuthSessionAggregate {
  aggregate: AuthSessionAggregateFields
  nodes: [AuthSession!]!
}

input AuthSessionAggregateBoolExp {
  count: authSessionAggregateBoolExpCount
}

"""
aggregate fields of "auth_session"
"""
type AuthSessionAggregateFields {
  count(columns: [AuthSessionSelectColumn!], distinct: Boolean): Int!
  max: AuthSessionMaxFields
  min: AuthSessionMinFields
}

"""
order by aggregate values of table "auth_session"
"""
input AuthSessionAggregateOrderBy {
  count: OrderBy
  max: AuthSessionMaxOrderBy
  min: AuthSessionMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AuthSessionAppendInput {
  data: jsonb
}

"""
input type for inserting array relation for remote table "auth_session"
"""
input AuthSessionArrRelInsertInput {
  data: [AuthSessionInsertInput!]!

  """upsert condition"""
  onConflict: AuthSessionOnConflict
}

"""
Boolean expression to filter rows from the table "auth_session". All fields are combined with a logical 'AND'.
"""
input AuthSessionBoolExp {
  _and: [AuthSessionBoolExp!]
  _not: AuthSessionBoolExp
  _or: [AuthSessionBoolExp!]
  createdAt: TimestamptzComparisonExp
  data: JsonbComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  token: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "auth_session"
"""
enum AuthSessionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  auth_session_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AuthSessionDeleteAtPathInput {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AuthSessionDeleteElemInput {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AuthSessionDeleteKeyInput {
  data: String
}

"""
input type for inserting data into table "auth_session"
"""
input AuthSessionInsertInput {
  createdAt: timestamptz
  data: jsonb
  expiresAt: timestamptz
  id: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  tenantId: String
  token: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type AuthSessionMaxFields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  profileId: uuid
  tenantId: String
  token: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth_session"
"""
input AuthSessionMaxOrderBy {
  createdAt: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  token: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type AuthSessionMinFields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  profileId: uuid
  tenantId: String
  token: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth_session"
"""
input AuthSessionMinOrderBy {
  createdAt: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  token: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "auth_session"
"""
type AuthSessionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AuthSession!]!
}

"""
on_conflict condition type for table "auth_session"
"""
input AuthSessionOnConflict {
  constraint: AuthSessionConstraint!
  updateColumns: [AuthSessionUpdateColumn!]! = []
  where: AuthSessionBoolExp
}

"""Ordering options when selecting data from "auth_session"."""
input AuthSessionOrderBy {
  createdAt: OrderBy
  data: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  tenantId: OrderBy
  token: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: auth_session"""
input AuthSessionPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AuthSessionPrependInput {
  data: jsonb
}

"""
select columns of table "auth_session"
"""
enum AuthSessionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  token

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth_session"
"""
input AuthSessionSetInput {
  createdAt: timestamptz
  data: jsonb
  expiresAt: timestamptz
  id: uuid
  profileId: uuid
  tenantId: String
  token: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "auth_session"
"""
input AuthSessionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuthSessionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuthSessionStreamCursorValueInput {
  createdAt: timestamptz
  data: jsonb
  expiresAt: timestamptz
  id: uuid
  profileId: uuid
  tenantId: String
  token: String
  updatedAt: timestamptz
}

"""
update columns of table "auth_session"
"""
enum AuthSessionUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  data

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  token

  """column name"""
  updatedAt
}

input AuthSessionUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AuthSessionAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AuthSessionDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AuthSessionDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AuthSessionDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AuthSessionPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: AuthSessionSetInput

  """filter the rows which have to be updated"""
  where: AuthSessionBoolExp!
}

input AuthSmsCodeInput {
  code: String!
  mobile: citext!
}

input AuthSmsInput {
  mobile: citext!
}

input AuthSmsSignUpInput {
  displayNameOverride: String
  firstName: String
  lastName: String
  mobile: citext!
  username: citext
}

"""
columns and relationships of "auth_user"
"""
type AuthUser {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinctOn: [AuthAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthAccountOrderBy!]

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): [AuthAccount!]!

  """An aggregate relationship"""
  accountsAggregate(
    """distinct select on columns"""
    distinctOn: [AuthAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthAccountOrderBy!]

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): AuthAccountAggregate!
  createdAt: timestamptz!
  emailTicket: String
  emailTicketExpiresAt: timestamptz
  id: uuid!

  """An object relationship"""
  identity: ProfileIdentity!
  mobileTicket: String
  mobileTicketExpiresAt: timestamptz
  passwordHash: String
  passwordSalt: String

  """An object relationship"""
  profile: Profile
  roleKind: AuthRoleKindEnum!

  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "auth_user"
"""
type AuthUserAggregate {
  aggregate: AuthUserAggregateFields
  nodes: [AuthUser!]!
}

"""
aggregate fields of "auth_user"
"""
type AuthUserAggregateFields {
  count(columns: [AuthUserSelectColumn!], distinct: Boolean): Int!
  max: AuthUserMaxFields
  min: AuthUserMinFields
}

"""
Boolean expression to filter rows from the table "auth_user". All fields are combined with a logical 'AND'.
"""
input AuthUserBoolExp {
  _and: [AuthUserBoolExp!]
  _not: AuthUserBoolExp
  _or: [AuthUserBoolExp!]
  accounts: AuthAccountBoolExp
  accountsAggregate: AuthAccountAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  emailTicket: StringComparisonExp
  emailTicketExpiresAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  identity: ProfileIdentityBoolExp
  mobileTicket: StringComparisonExp
  mobileTicketExpiresAt: TimestamptzComparisonExp
  passwordHash: StringComparisonExp
  passwordSalt: StringComparisonExp
  profile: ProfileBoolExp
  roleKind: AuthRoleKindEnumComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "auth_user"
"""
enum AuthUserConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  auth_user_pkey
}

"""
input type for inserting data into table "auth_user"
"""
input AuthUserInsertInput {
  accounts: AuthAccountArrRelInsertInput
  createdAt: timestamptz
  emailTicket: String
  emailTicketExpiresAt: timestamptz
  id: uuid
  identity: ProfileIdentityObjRelInsertInput
  mobileTicket: String
  mobileTicketExpiresAt: timestamptz
  passwordHash: String
  passwordSalt: String
  profile: ProfileObjRelInsertInput
  roleKind: AuthRoleKindEnum
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type AuthUserMaxFields {
  createdAt: timestamptz
  emailTicket: String
  emailTicketExpiresAt: timestamptz
  id: uuid
  mobileTicket: String
  mobileTicketExpiresAt: timestamptz
  passwordHash: String
  passwordSalt: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type AuthUserMinFields {
  createdAt: timestamptz
  emailTicket: String
  emailTicketExpiresAt: timestamptz
  id: uuid
  mobileTicket: String
  mobileTicketExpiresAt: timestamptz
  passwordHash: String
  passwordSalt: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "auth_user"
"""
type AuthUserMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [AuthUser!]!
}

"""
input type for inserting object relation for remote table "auth_user"
"""
input AuthUserObjRelInsertInput {
  data: AuthUserInsertInput!

  """upsert condition"""
  onConflict: AuthUserOnConflict
}

"""
on_conflict condition type for table "auth_user"
"""
input AuthUserOnConflict {
  constraint: AuthUserConstraint!
  updateColumns: [AuthUserUpdateColumn!]! = []
  where: AuthUserBoolExp
}

"""Ordering options when selecting data from "auth_user"."""
input AuthUserOrderBy {
  accountsAggregate: AuthAccountAggregateOrderBy
  createdAt: OrderBy
  emailTicket: OrderBy
  emailTicketExpiresAt: OrderBy
  id: OrderBy
  identity: ProfileIdentityOrderBy
  mobileTicket: OrderBy
  mobileTicketExpiresAt: OrderBy
  passwordHash: OrderBy
  passwordSalt: OrderBy
  profile: ProfileOrderBy
  roleKind: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: auth_user"""
input AuthUserPkColumnsInput {
  id: uuid!
}

"""
select columns of table "auth_user"
"""
enum AuthUserSelectColumn {
  """column name"""
  createdAt

  """column name"""
  emailTicket

  """column name"""
  emailTicketExpiresAt

  """column name"""
  id

  """column name"""
  mobileTicket

  """column name"""
  mobileTicketExpiresAt

  """column name"""
  passwordHash

  """column name"""
  passwordSalt

  """column name"""
  roleKind

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth_user"
"""
input AuthUserSetInput {
  createdAt: timestamptz
  emailTicket: String
  emailTicketExpiresAt: timestamptz
  id: uuid
  mobileTicket: String
  mobileTicketExpiresAt: timestamptz
  passwordHash: String
  passwordSalt: String
  roleKind: AuthRoleKindEnum
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "auth_user"
"""
input AuthUserStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuthUserStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuthUserStreamCursorValueInput {
  createdAt: timestamptz
  emailTicket: String
  emailTicketExpiresAt: timestamptz
  id: uuid
  mobileTicket: String
  mobileTicketExpiresAt: timestamptz
  passwordHash: String
  passwordSalt: String
  roleKind: AuthRoleKindEnum
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "auth_user"
"""
enum AuthUserUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  emailTicket

  """column name"""
  emailTicketExpiresAt

  """column name"""
  id

  """column name"""
  mobileTicket

  """column name"""
  mobileTicketExpiresAt

  """column name"""
  passwordHash

  """column name"""
  passwordSalt

  """column name"""
  roleKind

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input AuthUserUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AuthUserSetInput

  """filter the rows which have to be updated"""
  where: AuthUserBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "category"
"""
type Category {
  """An array relationship"""
  children(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """An aggregate relationship"""
  childrenAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!
  createdAt: timestamptz!
  id: String!
  kind: String!
  name: String!

  """An object relationship"""
  parent: Category
  parentId: String
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "category"
"""
type CategoryAggregate {
  aggregate: CategoryAggregateFields
  nodes: [Category!]!
}

input CategoryAggregateBoolExp {
  count: categoryAggregateBoolExpCount
}

"""
aggregate fields of "category"
"""
type CategoryAggregateFields {
  count(columns: [CategorySelectColumn!], distinct: Boolean): Int!
  max: CategoryMaxFields
  min: CategoryMinFields
}

"""
order by aggregate values of table "category"
"""
input CategoryAggregateOrderBy {
  count: OrderBy
  max: CategoryMaxOrderBy
  min: CategoryMinOrderBy
}

"""
input type for inserting array relation for remote table "category"
"""
input CategoryArrRelInsertInput {
  data: [CategoryInsertInput!]!

  """upsert condition"""
  onConflict: CategoryOnConflict
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input CategoryBoolExp {
  _and: [CategoryBoolExp!]
  _not: CategoryBoolExp
  _or: [CategoryBoolExp!]
  children: CategoryBoolExp
  childrenAggregate: CategoryAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  kind: StringComparisonExp
  name: StringComparisonExp
  parent: CategoryBoolExp
  parentId: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "category"
"""
enum CategoryConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  category_pkey
}

"""
input type for inserting data into table "category"
"""
input CategoryInsertInput {
  children: CategoryArrRelInsertInput
  createdAt: timestamptz
  id: String
  kind: String
  name: String
  parent: CategoryObjRelInsertInput
  parentId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "category_kind"
"""
type CategoryKind {
  id: String!
  tenantId: String!
}

"""
aggregated selection of "category_kind"
"""
type CategoryKindAggregate {
  aggregate: CategoryKindAggregateFields
  nodes: [CategoryKind!]!
}

"""
aggregate fields of "category_kind"
"""
type CategoryKindAggregateFields {
  count(columns: [CategoryKindSelectColumn!], distinct: Boolean): Int!
  max: CategoryKindMaxFields
  min: CategoryKindMinFields
}

"""
Boolean expression to filter rows from the table "category_kind". All fields are combined with a logical 'AND'.
"""
input CategoryKindBoolExp {
  _and: [CategoryKindBoolExp!]
  _not: CategoryKindBoolExp
  _or: [CategoryKindBoolExp!]
  id: StringComparisonExp
  tenantId: StringComparisonExp
}

"""
unique or primary key constraints on table "category_kind"
"""
enum CategoryKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  category_kind_pkey
}

"""
input type for inserting data into table "category_kind"
"""
input CategoryKindInsertInput {
  id: String
  tenantId: String
}

"""aggregate max on columns"""
type CategoryKindMaxFields {
  id: String
  tenantId: String
}

"""aggregate min on columns"""
type CategoryKindMinFields {
  id: String
  tenantId: String
}

"""
response of any mutation on the table "category_kind"
"""
type CategoryKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CategoryKind!]!
}

"""
on_conflict condition type for table "category_kind"
"""
input CategoryKindOnConflict {
  constraint: CategoryKindConstraint!
  updateColumns: [CategoryKindUpdateColumn!]! = []
  where: CategoryKindBoolExp
}

"""Ordering options when selecting data from "category_kind"."""
input CategoryKindOrderBy {
  id: OrderBy
  tenantId: OrderBy
}

"""primary key columns input for table: category_kind"""
input CategoryKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "category_kind"
"""
enum CategoryKindSelectColumn {
  """column name"""
  id

  """column name"""
  tenantId
}

"""
input type for updating data in table "category_kind"
"""
input CategoryKindSetInput {
  id: String
  tenantId: String
}

"""
Streaming cursor of the table "category_kind"
"""
input CategoryKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryKindStreamCursorValueInput {
  id: String
  tenantId: String
}

"""
update columns of table "category_kind"
"""
enum CategoryKindUpdateColumn {
  """column name"""
  id

  """column name"""
  tenantId
}

input CategoryKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CategoryKindSetInput

  """filter the rows which have to be updated"""
  where: CategoryKindBoolExp!
}

"""aggregate max on columns"""
type CategoryMaxFields {
  createdAt: timestamptz
  id: String
  kind: String
  name: String
  parentId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "category"
"""
input CategoryMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  name: OrderBy
  parentId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CategoryMinFields {
  createdAt: timestamptz
  id: String
  kind: String
  name: String
  parentId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "category"
"""
input CategoryMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  name: OrderBy
  parentId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "category"
"""
type CategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input CategoryObjRelInsertInput {
  data: CategoryInsertInput!

  """upsert condition"""
  onConflict: CategoryOnConflict
}

"""
on_conflict condition type for table "category"
"""
input CategoryOnConflict {
  constraint: CategoryConstraint!
  updateColumns: [CategoryUpdateColumn!]! = []
  where: CategoryBoolExp
}

"""Ordering options when selecting data from "category"."""
input CategoryOrderBy {
  childrenAggregate: CategoryAggregateOrderBy
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  name: OrderBy
  parent: CategoryOrderBy
  parentId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: category"""
input CategoryPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "category"
"""
enum CategorySelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "category"
"""
input CategorySetInput {
  createdAt: timestamptz
  id: String
  kind: String
  name: String
  parentId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "category"
"""
input CategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CategoryStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  kind: String
  name: String
  parentId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "category"
"""
enum CategoryUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  name

  """column name"""
  parentId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CategoryUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CategorySetInput

  """filter the rows which have to be updated"""
  where: CategoryBoolExp!
}

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input CitextComparisonExp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

input ContactFormInput {
  data: jsonb!
  email: String!
  name: String!
  profileId: String
  tenantId: String!
  turnstileToken: String!
}

"""
columns and relationships of "contact_opt_in"
"""
type ContactOptIn {
  channelKind: ContactOptInChannelKindEnum!
  createdAt: timestamptz
  email: String
  id: uuid!
  isOptOut: Boolean
  name: String
  phone: String
  pushToken: String

  """An object relationship"""
  receiver: Profile
  receiverId: uuid

  """An object relationship"""
  sender: Profile!
  senderId: uuid!
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "contact_opt_in"
"""
type ContactOptInAggregate {
  aggregate: ContactOptInAggregateFields
  nodes: [ContactOptIn!]!
}

input ContactOptInAggregateBoolExp {
  bool_and: contactOptInAggregateBoolExpBool_and
  bool_or: contactOptInAggregateBoolExpBool_or
  count: contactOptInAggregateBoolExpCount
}

"""
aggregate fields of "contact_opt_in"
"""
type ContactOptInAggregateFields {
  count(columns: [ContactOptInSelectColumn!], distinct: Boolean): Int!
  max: ContactOptInMaxFields
  min: ContactOptInMinFields
}

"""
order by aggregate values of table "contact_opt_in"
"""
input ContactOptInAggregateOrderBy {
  count: OrderBy
  max: ContactOptInMaxOrderBy
  min: ContactOptInMinOrderBy
}

"""
input type for inserting array relation for remote table "contact_opt_in"
"""
input ContactOptInArrRelInsertInput {
  data: [ContactOptInInsertInput!]!

  """upsert condition"""
  onConflict: ContactOptInOnConflict
}

"""
Boolean expression to filter rows from the table "contact_opt_in". All fields are combined with a logical 'AND'.
"""
input ContactOptInBoolExp {
  _and: [ContactOptInBoolExp!]
  _not: ContactOptInBoolExp
  _or: [ContactOptInBoolExp!]
  channelKind: ContactOptInChannelKindEnumComparisonExp
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  isOptOut: BooleanComparisonExp
  name: StringComparisonExp
  phone: StringComparisonExp
  pushToken: StringComparisonExp
  receiver: ProfileBoolExp
  receiverId: UuidComparisonExp
  sender: ProfileBoolExp
  senderId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

enum ContactOptInChannelKindEnum {
  EMAIL
  PUSH_NOTIFICATION
  SMS
}

"""
Boolean expression to compare columns of type "ContactOptInChannelKindEnum". All fields are combined with logical 'AND'.
"""
input ContactOptInChannelKindEnumComparisonExp {
  _eq: ContactOptInChannelKindEnum
  _in: [ContactOptInChannelKindEnum!]
  _isNull: Boolean
  _neq: ContactOptInChannelKindEnum
  _nin: [ContactOptInChannelKindEnum!]
}

"""
unique or primary key constraints on table "contact_opt_in"
"""
enum ContactOptInConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  contact_opt_in_pkey

  """
  unique or primary key constraint on columns "receiver_id", "sender_id", "channel_kind", "tenant_id"
  """
  contact_opt_in_sender_id_receiver_id_channel_kind_tenant_id_key
}

"""
input type for inserting data into table "contact_opt_in"
"""
input ContactOptInInsertInput {
  channelKind: ContactOptInChannelKindEnum
  createdAt: timestamptz
  email: String
  id: uuid
  isOptOut: Boolean
  name: String
  phone: String
  pushToken: String
  receiver: ProfileObjRelInsertInput
  receiverId: uuid
  sender: ProfileObjRelInsertInput
  senderId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ContactOptInMaxFields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  phone: String
  pushToken: String
  receiverId: uuid
  senderId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "contact_opt_in"
"""
input ContactOptInMaxOrderBy {
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  name: OrderBy
  phone: OrderBy
  pushToken: OrderBy
  receiverId: OrderBy
  senderId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ContactOptInMinFields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  phone: String
  pushToken: String
  receiverId: uuid
  senderId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "contact_opt_in"
"""
input ContactOptInMinOrderBy {
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  name: OrderBy
  phone: OrderBy
  pushToken: OrderBy
  receiverId: OrderBy
  senderId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "contact_opt_in"
"""
type ContactOptInMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ContactOptIn!]!
}

"""
on_conflict condition type for table "contact_opt_in"
"""
input ContactOptInOnConflict {
  constraint: ContactOptInConstraint!
  updateColumns: [ContactOptInUpdateColumn!]! = []
  where: ContactOptInBoolExp
}

"""Ordering options when selecting data from "contact_opt_in"."""
input ContactOptInOrderBy {
  channelKind: OrderBy
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  isOptOut: OrderBy
  name: OrderBy
  phone: OrderBy
  pushToken: OrderBy
  receiver: ProfileOrderBy
  receiverId: OrderBy
  sender: ProfileOrderBy
  senderId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: contact_opt_in"""
input ContactOptInPkColumnsInput {
  id: uuid!
}

"""
select columns of table "contact_opt_in"
"""
enum ContactOptInSelectColumn {
  """column name"""
  channelKind

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  isOptOut

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  pushToken

  """column name"""
  receiverId

  """column name"""
  senderId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
select "contactOptInAggregateBoolExpBool_andArgumentsColumns" columns of table "contact_opt_in"
"""
enum ContactOptInSelectColumnContactOptInAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isOptOut
}

"""
select "contactOptInAggregateBoolExpBool_orArgumentsColumns" columns of table "contact_opt_in"
"""
enum ContactOptInSelectColumnContactOptInAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isOptOut
}

"""
input type for updating data in table "contact_opt_in"
"""
input ContactOptInSetInput {
  channelKind: ContactOptInChannelKindEnum
  createdAt: timestamptz
  email: String
  id: uuid
  isOptOut: Boolean
  name: String
  phone: String
  pushToken: String
  receiverId: uuid
  senderId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "contact_opt_in"
"""
input ContactOptInStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ContactOptInStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ContactOptInStreamCursorValueInput {
  channelKind: ContactOptInChannelKindEnum
  createdAt: timestamptz
  email: String
  id: uuid
  isOptOut: Boolean
  name: String
  phone: String
  pushToken: String
  receiverId: uuid
  senderId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "contact_opt_in"
"""
enum ContactOptInUpdateColumn {
  """column name"""
  channelKind

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  id

  """column name"""
  isOptOut

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  pushToken

  """column name"""
  receiverId

  """column name"""
  senderId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ContactOptInUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ContactOptInSetInput

  """filter the rows which have to be updated"""
  where: ContactOptInBoolExp!
}

"""
columns and relationships of "course"
"""
type Course {
  copiedFromCourseId: uuid

  """An object relationship"""
  coverPhoto: MediaItem
  coverPhotoId: String
  createdAt: timestamptz!
  id: uuid!

  """An array relationship"""
  lessons(
    """distinct select on columns"""
    distinctOn: [CourseLessonSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonOrderBy!]

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): [CourseLesson!]!

  """An aggregate relationship"""
  lessonsAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonOrderBy!]

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): CourseLessonAggregate!
  name: String!
  profileId: uuid
  slug: String
  tenantId: String!
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "course"
"""
type CourseAggregate {
  aggregate: CourseAggregateFields
  nodes: [Course!]!
}

"""
aggregate fields of "course"
"""
type CourseAggregateFields {
  count(columns: [CourseSelectColumn!], distinct: Boolean): Int!
  max: CourseMaxFields
  min: CourseMinFields
}

"""
Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'.
"""
input CourseBoolExp {
  _and: [CourseBoolExp!]
  _not: CourseBoolExp
  _or: [CourseBoolExp!]
  copiedFromCourseId: UuidComparisonExp
  coverPhoto: MediaItemBoolExp
  coverPhotoId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  lessons: CourseLessonBoolExp
  lessonsAggregate: CourseLessonAggregateBoolExp
  name: StringComparisonExp
  profileId: UuidComparisonExp
  slug: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "course"
"""
enum CourseConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_pkey

  """
  unique or primary key constraint on columns "slug", "tenant_id"
  """
  course_slug_tenant_id_key
}

"""
columns and relationships of "course_exercise"
"""
type CourseExercise {
  body: String

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinctOn: [CourseExerciseCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseCategoryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): [CourseExerciseCategory!]!

  """An aggregate relationship"""
  categoriesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseCategoryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): CourseExerciseCategoryAggregate!

  """An object relationship"""
  coverPhoto: MediaItem
  coverPhotoId: String
  createdAt: timestamptz!

  """An array relationship"""
  exerciseMediaItems(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): [CourseExerciseMediaItem!]!

  """An aggregate relationship"""
  exerciseMediaItemsAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): CourseExerciseMediaItemAggregate!
  id: uuid!
  kind: String!

  """An array relationship"""
  mediaItems(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): [CourseExerciseMediaItem!]!

  """An aggregate relationship"""
  mediaItemsAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): CourseExerciseMediaItemAggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!

  """An array relationship"""
  sectionExercises(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): [CourseLessonSectionExercise!]!

  """An aggregate relationship"""
  sectionExercisesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): CourseLessonSectionExerciseAggregate!
  tenantId: String!
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "course_exercise"
"""
type CourseExerciseAggregate {
  aggregate: CourseExerciseAggregateFields
  nodes: [CourseExercise!]!
}

"""
aggregate fields of "course_exercise"
"""
type CourseExerciseAggregateFields {
  count(columns: [CourseExerciseSelectColumn!], distinct: Boolean): Int!
  max: CourseExerciseMaxFields
  min: CourseExerciseMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input CourseExerciseAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "course_exercise". All fields are combined with a logical 'AND'.
"""
input CourseExerciseBoolExp {
  _and: [CourseExerciseBoolExp!]
  _not: CourseExerciseBoolExp
  _or: [CourseExerciseBoolExp!]
  body: StringComparisonExp
  categories: CourseExerciseCategoryBoolExp
  categoriesAggregate: CourseExerciseCategoryAggregateBoolExp
  coverPhoto: MediaItemBoolExp
  coverPhotoId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  exerciseMediaItems: CourseExerciseMediaItemBoolExp
  exerciseMediaItemsAggregate: CourseExerciseMediaItemAggregateBoolExp
  id: UuidComparisonExp
  kind: StringComparisonExp
  mediaItems: CourseExerciseMediaItemBoolExp
  mediaItemsAggregate: CourseExerciseMediaItemAggregateBoolExp
  metadata: JsonbComparisonExp
  name: StringComparisonExp
  sectionExercises: CourseLessonSectionExerciseBoolExp
  sectionExercisesAggregate: CourseLessonSectionExerciseAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
columns and relationships of "course_exercise_category"
"""
type CourseExerciseCategory {
  """An object relationship"""
  category: Category!
  categoryId: String!
  courseExerciseId: uuid!
  createdAt: timestamptz!

  """An object relationship"""
  exercise: CourseExercise!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_exercise_category"
"""
type CourseExerciseCategoryAggregate {
  aggregate: CourseExerciseCategoryAggregateFields
  nodes: [CourseExerciseCategory!]!
}

input CourseExerciseCategoryAggregateBoolExp {
  count: courseExerciseCategoryAggregateBoolExpCount
}

"""
aggregate fields of "course_exercise_category"
"""
type CourseExerciseCategoryAggregateFields {
  count(columns: [CourseExerciseCategorySelectColumn!], distinct: Boolean): Int!
  max: CourseExerciseCategoryMaxFields
  min: CourseExerciseCategoryMinFields
}

"""
order by aggregate values of table "course_exercise_category"
"""
input CourseExerciseCategoryAggregateOrderBy {
  count: OrderBy
  max: CourseExerciseCategoryMaxOrderBy
  min: CourseExerciseCategoryMinOrderBy
}

"""
input type for inserting array relation for remote table "course_exercise_category"
"""
input CourseExerciseCategoryArrRelInsertInput {
  data: [CourseExerciseCategoryInsertInput!]!

  """upsert condition"""
  onConflict: CourseExerciseCategoryOnConflict
}

"""
Boolean expression to filter rows from the table "course_exercise_category". All fields are combined with a logical 'AND'.
"""
input CourseExerciseCategoryBoolExp {
  _and: [CourseExerciseCategoryBoolExp!]
  _not: CourseExerciseCategoryBoolExp
  _or: [CourseExerciseCategoryBoolExp!]
  category: CategoryBoolExp
  categoryId: StringComparisonExp
  courseExerciseId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  exercise: CourseExerciseBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_exercise_category"
"""
enum CourseExerciseCategoryConstraint {
  """
  unique or primary key constraint on columns "course_exercise_id", "category_id", "tenant_id"
  """
  course_exercise_category_pkey
}

"""
input type for inserting data into table "course_exercise_category"
"""
input CourseExerciseCategoryInsertInput {
  category: CategoryObjRelInsertInput
  categoryId: String
  courseExerciseId: uuid
  createdAt: timestamptz
  exercise: CourseExerciseObjRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseExerciseCategoryMaxFields {
  categoryId: String
  courseExerciseId: uuid
  createdAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_exercise_category"
"""
input CourseExerciseCategoryMaxOrderBy {
  categoryId: OrderBy
  courseExerciseId: OrderBy
  createdAt: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseExerciseCategoryMinFields {
  categoryId: String
  courseExerciseId: uuid
  createdAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_exercise_category"
"""
input CourseExerciseCategoryMinOrderBy {
  categoryId: OrderBy
  courseExerciseId: OrderBy
  createdAt: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_exercise_category"
"""
type CourseExerciseCategoryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseExerciseCategory!]!
}

"""
on_conflict condition type for table "course_exercise_category"
"""
input CourseExerciseCategoryOnConflict {
  constraint: CourseExerciseCategoryConstraint!
  updateColumns: [CourseExerciseCategoryUpdateColumn!]! = []
  where: CourseExerciseCategoryBoolExp
}

"""Ordering options when selecting data from "course_exercise_category"."""
input CourseExerciseCategoryOrderBy {
  category: CategoryOrderBy
  categoryId: OrderBy
  courseExerciseId: OrderBy
  createdAt: OrderBy
  exercise: CourseExerciseOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_exercise_category"""
input CourseExerciseCategoryPkColumnsInput {
  categoryId: String!
  courseExerciseId: uuid!
  tenantId: String!
}

"""
select columns of table "course_exercise_category"
"""
enum CourseExerciseCategorySelectColumn {
  """column name"""
  categoryId

  """column name"""
  courseExerciseId

  """column name"""
  createdAt

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_exercise_category"
"""
input CourseExerciseCategorySetInput {
  categoryId: String
  courseExerciseId: uuid
  createdAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "course_exercise_category"
"""
input CourseExerciseCategoryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseExerciseCategoryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseExerciseCategoryStreamCursorValueInput {
  categoryId: String
  courseExerciseId: uuid
  createdAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "course_exercise_category"
"""
enum CourseExerciseCategoryUpdateColumn {
  """column name"""
  categoryId

  """column name"""
  courseExerciseId

  """column name"""
  createdAt

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseExerciseCategoryUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CourseExerciseCategorySetInput

  """filter the rows which have to be updated"""
  where: CourseExerciseCategoryBoolExp!
}

"""
unique or primary key constraints on table "course_exercise"
"""
enum CourseExerciseConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_exercise_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input CourseExerciseDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input CourseExerciseDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input CourseExerciseDeleteKeyInput {
  metadata: String
}

"""
columns and relationships of "course_exercise_entry"
"""
type CourseExerciseEntry {
  courseLessonEntryId: uuid
  courseLessonSectionId: uuid!
  createdAt: timestamptz!
  durationMilliseconds: Int
  exerciseId: uuid
  id: uuid!

  """An object relationship"""
  lessonEntry: CourseLessonEntry
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
  profileId: uuid!
  stringValue: String
  tenantId: String!
  timestamp: timestamptz!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_exercise_entry"
"""
type CourseExerciseEntryAggregate {
  aggregate: CourseExerciseEntryAggregateFields
  nodes: [CourseExerciseEntry!]!
}

input CourseExerciseEntryAggregateBoolExp {
  count: courseExerciseEntryAggregateBoolExpCount
}

"""
aggregate fields of "course_exercise_entry"
"""
type CourseExerciseEntryAggregateFields {
  avg: CourseExerciseEntryAvgFields
  count(columns: [CourseExerciseEntrySelectColumn!], distinct: Boolean): Int!
  max: CourseExerciseEntryMaxFields
  min: CourseExerciseEntryMinFields
  stddev: CourseExerciseEntryStddevFields
  stddevPop: CourseExerciseEntryStddevPopFields
  stddevSamp: CourseExerciseEntryStddevSampFields
  sum: CourseExerciseEntrySumFields
  varPop: CourseExerciseEntryVarPopFields
  varSamp: CourseExerciseEntryVarSampFields
  variance: CourseExerciseEntryVarianceFields
}

"""
order by aggregate values of table "course_exercise_entry"
"""
input CourseExerciseEntryAggregateOrderBy {
  avg: CourseExerciseEntryAvgOrderBy
  count: OrderBy
  max: CourseExerciseEntryMaxOrderBy
  min: CourseExerciseEntryMinOrderBy
  stddev: CourseExerciseEntryStddevOrderBy
  stddevPop: CourseExerciseEntryStddevPopOrderBy
  stddevSamp: CourseExerciseEntryStddevSampOrderBy
  sum: CourseExerciseEntrySumOrderBy
  varPop: CourseExerciseEntryVarPopOrderBy
  varSamp: CourseExerciseEntryVarSampOrderBy
  variance: CourseExerciseEntryVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input CourseExerciseEntryAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "course_exercise_entry"
"""
input CourseExerciseEntryArrRelInsertInput {
  data: [CourseExerciseEntryInsertInput!]!

  """upsert condition"""
  onConflict: CourseExerciseEntryOnConflict
}

"""aggregate avg on columns"""
type CourseExerciseEntryAvgFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by avg() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryAvgOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""
Boolean expression to filter rows from the table "course_exercise_entry". All fields are combined with a logical 'AND'.
"""
input CourseExerciseEntryBoolExp {
  _and: [CourseExerciseEntryBoolExp!]
  _not: CourseExerciseEntryBoolExp
  _or: [CourseExerciseEntryBoolExp!]
  courseLessonEntryId: UuidComparisonExp
  courseLessonSectionId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  durationMilliseconds: IntComparisonExp
  exerciseId: UuidComparisonExp
  id: UuidComparisonExp
  lessonEntry: CourseLessonEntryBoolExp
  metadata: JsonbComparisonExp
  numberValue1: NumericComparisonExp
  numberValue2: NumericComparisonExp
  numberValue3: NumericComparisonExp
  profileId: UuidComparisonExp
  stringValue: StringComparisonExp
  tenantId: StringComparisonExp
  timestamp: TimestamptzComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_exercise_entry"
"""
enum CourseExerciseEntryConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_exercise_entry_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input CourseExerciseEntryDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input CourseExerciseEntryDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input CourseExerciseEntryDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "course_exercise_entry"
"""
input CourseExerciseEntryIncInput {
  durationMilliseconds: Int

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
}

"""
input type for inserting data into table "course_exercise_entry"
"""
input CourseExerciseEntryInsertInput {
  courseLessonEntryId: uuid
  courseLessonSectionId: uuid
  createdAt: timestamptz
  durationMilliseconds: Int
  exerciseId: uuid
  id: uuid
  lessonEntry: CourseLessonEntryObjRelInsertInput
  metadata: jsonb

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
  profileId: uuid
  stringValue: String
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseExerciseEntryMaxFields {
  courseLessonEntryId: uuid
  courseLessonSectionId: uuid
  createdAt: timestamptz
  durationMilliseconds: Int
  exerciseId: uuid
  id: uuid

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
  profileId: uuid
  stringValue: String
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryMaxOrderBy {
  courseLessonEntryId: OrderBy
  courseLessonSectionId: OrderBy
  createdAt: OrderBy
  durationMilliseconds: OrderBy
  exerciseId: OrderBy
  id: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
  profileId: OrderBy
  stringValue: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseExerciseEntryMinFields {
  courseLessonEntryId: uuid
  courseLessonSectionId: uuid
  createdAt: timestamptz
  durationMilliseconds: Int
  exerciseId: uuid
  id: uuid

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
  profileId: uuid
  stringValue: String
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryMinOrderBy {
  courseLessonEntryId: OrderBy
  courseLessonSectionId: OrderBy
  createdAt: OrderBy
  durationMilliseconds: OrderBy
  exerciseId: OrderBy
  id: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
  profileId: OrderBy
  stringValue: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_exercise_entry"
"""
type CourseExerciseEntryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseExerciseEntry!]!
}

"""
on_conflict condition type for table "course_exercise_entry"
"""
input CourseExerciseEntryOnConflict {
  constraint: CourseExerciseEntryConstraint!
  updateColumns: [CourseExerciseEntryUpdateColumn!]! = []
  where: CourseExerciseEntryBoolExp
}

"""Ordering options when selecting data from "course_exercise_entry"."""
input CourseExerciseEntryOrderBy {
  courseLessonEntryId: OrderBy
  courseLessonSectionId: OrderBy
  createdAt: OrderBy
  durationMilliseconds: OrderBy
  exerciseId: OrderBy
  id: OrderBy
  lessonEntry: CourseLessonEntryOrderBy
  metadata: OrderBy
  numberValue1: OrderBy
  numberValue2: OrderBy
  numberValue3: OrderBy
  profileId: OrderBy
  stringValue: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_exercise_entry"""
input CourseExerciseEntryPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input CourseExerciseEntryPrependInput {
  metadata: jsonb
}

"""
select columns of table "course_exercise_entry"
"""
enum CourseExerciseEntrySelectColumn {
  """column name"""
  courseLessonEntryId

  """column name"""
  courseLessonSectionId

  """column name"""
  createdAt

  """column name"""
  durationMilliseconds

  """column name"""
  exerciseId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  numberValue1

  """column name"""
  numberValue2

  """column name"""
  numberValue3

  """column name"""
  profileId

  """column name"""
  stringValue

  """column name"""
  tenantId

  """column name"""
  timestamp

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_exercise_entry"
"""
input CourseExerciseEntrySetInput {
  courseLessonEntryId: uuid
  courseLessonSectionId: uuid
  createdAt: timestamptz
  durationMilliseconds: Int
  exerciseId: uuid
  id: uuid
  metadata: jsonb

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
  profileId: uuid
  stringValue: String
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CourseExerciseEntryStddevFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by stddev() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryStddevOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseExerciseEntryStddevPopFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by stddevPop() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryStddevPopOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseExerciseEntryStddevSampFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by stddevSamp() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryStddevSampOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""
Streaming cursor of the table "course_exercise_entry"
"""
input CourseExerciseEntryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseExerciseEntryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseExerciseEntryStreamCursorValueInput {
  courseLessonEntryId: uuid
  courseLessonSectionId: uuid
  createdAt: timestamptz
  durationMilliseconds: Int
  exerciseId: uuid
  id: uuid
  metadata: jsonb

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
  profileId: uuid
  stringValue: String
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type CourseExerciseEntrySumFields {
  durationMilliseconds: Int

  """Physical workouts: weight in lbs"""
  numberValue1: numeric

  """Physical workouts: number of reps"""
  numberValue2: numeric

  """Physical workouts: distance in feet"""
  numberValue3: numeric
}

"""
order by sum() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntrySumOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""
update columns of table "course_exercise_entry"
"""
enum CourseExerciseEntryUpdateColumn {
  """column name"""
  courseLessonEntryId

  """column name"""
  courseLessonSectionId

  """column name"""
  createdAt

  """column name"""
  durationMilliseconds

  """column name"""
  exerciseId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  numberValue1

  """column name"""
  numberValue2

  """column name"""
  numberValue3

  """column name"""
  profileId

  """column name"""
  stringValue

  """column name"""
  tenantId

  """column name"""
  timestamp

  """column name"""
  updatedAt
}

input CourseExerciseEntryUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: CourseExerciseEntryAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: CourseExerciseEntryDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: CourseExerciseEntryDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: CourseExerciseEntryDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseExerciseEntryIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: CourseExerciseEntryPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseExerciseEntrySetInput

  """filter the rows which have to be updated"""
  where: CourseExerciseEntryBoolExp!
}

"""aggregate varPop on columns"""
type CourseExerciseEntryVarPopFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by varPop() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryVarPopOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""aggregate varSamp on columns"""
type CourseExerciseEntryVarSampFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by varSamp() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryVarSampOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""aggregate variance on columns"""
type CourseExerciseEntryVarianceFields {
  durationMilliseconds: Float

  """Physical workouts: weight in lbs"""
  numberValue1: Float

  """Physical workouts: number of reps"""
  numberValue2: Float

  """Physical workouts: distance in feet"""
  numberValue3: Float
}

"""
order by variance() on columns of table "course_exercise_entry"
"""
input CourseExerciseEntryVarianceOrderBy {
  durationMilliseconds: OrderBy

  """Physical workouts: weight in lbs"""
  numberValue1: OrderBy

  """Physical workouts: number of reps"""
  numberValue2: OrderBy

  """Physical workouts: distance in feet"""
  numberValue3: OrderBy
}

"""
input type for inserting data into table "course_exercise"
"""
input CourseExerciseInsertInput {
  body: String
  categories: CourseExerciseCategoryArrRelInsertInput
  coverPhoto: MediaItemObjRelInsertInput
  coverPhotoId: String
  createdAt: timestamptz
  exerciseMediaItems: CourseExerciseMediaItemArrRelInsertInput
  id: uuid
  kind: String
  mediaItems: CourseExerciseMediaItemArrRelInsertInput
  metadata: jsonb
  name: String
  sectionExercises: CourseLessonSectionExerciseArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "course_exercise_kind"
"""
type CourseExerciseKind {
  createdAt: timestamptz!
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_exercise_kind"
"""
type CourseExerciseKindAggregate {
  aggregate: CourseExerciseKindAggregateFields
  nodes: [CourseExerciseKind!]!
}

"""
aggregate fields of "course_exercise_kind"
"""
type CourseExerciseKindAggregateFields {
  count(columns: [CourseExerciseKindSelectColumn!], distinct: Boolean): Int!
  max: CourseExerciseKindMaxFields
  min: CourseExerciseKindMinFields
}

"""
Boolean expression to filter rows from the table "course_exercise_kind". All fields are combined with a logical 'AND'.
"""
input CourseExerciseKindBoolExp {
  _and: [CourseExerciseKindBoolExp!]
  _not: CourseExerciseKindBoolExp
  _or: [CourseExerciseKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_exercise_kind"
"""
enum CourseExerciseKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  course_exercise_kind_pkey
}

"""
input type for inserting data into table "course_exercise_kind"
"""
input CourseExerciseKindInsertInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseExerciseKindMaxFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type CourseExerciseKindMinFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "course_exercise_kind"
"""
type CourseExerciseKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseExerciseKind!]!
}

"""
on_conflict condition type for table "course_exercise_kind"
"""
input CourseExerciseKindOnConflict {
  constraint: CourseExerciseKindConstraint!
  updateColumns: [CourseExerciseKindUpdateColumn!]! = []
  where: CourseExerciseKindBoolExp
}

"""Ordering options when selecting data from "course_exercise_kind"."""
input CourseExerciseKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_exercise_kind"""
input CourseExerciseKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "course_exercise_kind"
"""
enum CourseExerciseKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_exercise_kind"
"""
input CourseExerciseKindSetInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "course_exercise_kind"
"""
input CourseExerciseKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseExerciseKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseExerciseKindStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "course_exercise_kind"
"""
enum CourseExerciseKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseExerciseKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CourseExerciseKindSetInput

  """filter the rows which have to be updated"""
  where: CourseExerciseKindBoolExp!
}

"""aggregate max on columns"""
type CourseExerciseMaxFields {
  body: String
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "course_exercise_media_item"
"""
type CourseExerciseMediaItem {
  courseExerciseId: uuid!
  createdAt: timestamptz!

  """An object relationship"""
  exercise: CourseExercise!
  label: String

  """An object relationship"""
  mediaItem: MediaItem!
  mediaItemId: String!
  order: Int
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_exercise_media_item"
"""
type CourseExerciseMediaItemAggregate {
  aggregate: CourseExerciseMediaItemAggregateFields
  nodes: [CourseExerciseMediaItem!]!
}

input CourseExerciseMediaItemAggregateBoolExp {
  count: courseExerciseMediaItemAggregateBoolExpCount
}

"""
aggregate fields of "course_exercise_media_item"
"""
type CourseExerciseMediaItemAggregateFields {
  avg: CourseExerciseMediaItemAvgFields
  count(columns: [CourseExerciseMediaItemSelectColumn!], distinct: Boolean): Int!
  max: CourseExerciseMediaItemMaxFields
  min: CourseExerciseMediaItemMinFields
  stddev: CourseExerciseMediaItemStddevFields
  stddevPop: CourseExerciseMediaItemStddevPopFields
  stddevSamp: CourseExerciseMediaItemStddevSampFields
  sum: CourseExerciseMediaItemSumFields
  varPop: CourseExerciseMediaItemVarPopFields
  varSamp: CourseExerciseMediaItemVarSampFields
  variance: CourseExerciseMediaItemVarianceFields
}

"""
order by aggregate values of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemAggregateOrderBy {
  avg: CourseExerciseMediaItemAvgOrderBy
  count: OrderBy
  max: CourseExerciseMediaItemMaxOrderBy
  min: CourseExerciseMediaItemMinOrderBy
  stddev: CourseExerciseMediaItemStddevOrderBy
  stddevPop: CourseExerciseMediaItemStddevPopOrderBy
  stddevSamp: CourseExerciseMediaItemStddevSampOrderBy
  sum: CourseExerciseMediaItemSumOrderBy
  varPop: CourseExerciseMediaItemVarPopOrderBy
  varSamp: CourseExerciseMediaItemVarSampOrderBy
  variance: CourseExerciseMediaItemVarianceOrderBy
}

"""
input type for inserting array relation for remote table "course_exercise_media_item"
"""
input CourseExerciseMediaItemArrRelInsertInput {
  data: [CourseExerciseMediaItemInsertInput!]!

  """upsert condition"""
  onConflict: CourseExerciseMediaItemOnConflict
}

"""aggregate avg on columns"""
type CourseExerciseMediaItemAvgFields {
  order: Float
}

"""
order by avg() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "course_exercise_media_item". All fields are combined with a logical 'AND'.
"""
input CourseExerciseMediaItemBoolExp {
  _and: [CourseExerciseMediaItemBoolExp!]
  _not: CourseExerciseMediaItemBoolExp
  _or: [CourseExerciseMediaItemBoolExp!]
  courseExerciseId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  exercise: CourseExerciseBoolExp
  label: StringComparisonExp
  mediaItem: MediaItemBoolExp
  mediaItemId: StringComparisonExp
  order: IntComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_exercise_media_item"
"""
enum CourseExerciseMediaItemConstraint {
  """
  unique or primary key constraint on columns "course_exercise_id", "media_item_id"
  """
  course_exercise_media_item_pkey
}

"""
input type for incrementing numeric columns in table "course_exercise_media_item"
"""
input CourseExerciseMediaItemIncInput {
  order: Int
}

"""
input type for inserting data into table "course_exercise_media_item"
"""
input CourseExerciseMediaItemInsertInput {
  courseExerciseId: uuid
  createdAt: timestamptz
  exercise: CourseExerciseObjRelInsertInput
  label: String
  mediaItem: MediaItemObjRelInsertInput
  mediaItemId: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseExerciseMediaItemMaxFields {
  courseExerciseId: uuid
  createdAt: timestamptz
  label: String
  mediaItemId: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemMaxOrderBy {
  courseExerciseId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  mediaItemId: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseExerciseMediaItemMinFields {
  courseExerciseId: uuid
  createdAt: timestamptz
  label: String
  mediaItemId: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemMinOrderBy {
  courseExerciseId: OrderBy
  createdAt: OrderBy
  label: OrderBy
  mediaItemId: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_exercise_media_item"
"""
type CourseExerciseMediaItemMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseExerciseMediaItem!]!
}

"""
on_conflict condition type for table "course_exercise_media_item"
"""
input CourseExerciseMediaItemOnConflict {
  constraint: CourseExerciseMediaItemConstraint!
  updateColumns: [CourseExerciseMediaItemUpdateColumn!]! = []
  where: CourseExerciseMediaItemBoolExp
}

"""
Ordering options when selecting data from "course_exercise_media_item".
"""
input CourseExerciseMediaItemOrderBy {
  courseExerciseId: OrderBy
  createdAt: OrderBy
  exercise: CourseExerciseOrderBy
  label: OrderBy
  mediaItem: MediaItemOrderBy
  mediaItemId: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_exercise_media_item"""
input CourseExerciseMediaItemPkColumnsInput {
  courseExerciseId: uuid!
  mediaItemId: String!
}

"""
select columns of table "course_exercise_media_item"
"""
enum CourseExerciseMediaItemSelectColumn {
  """column name"""
  courseExerciseId

  """column name"""
  createdAt

  """column name"""
  label

  """column name"""
  mediaItemId

  """column name"""
  order

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_exercise_media_item"
"""
input CourseExerciseMediaItemSetInput {
  courseExerciseId: uuid
  createdAt: timestamptz
  label: String
  mediaItemId: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CourseExerciseMediaItemStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseExerciseMediaItemStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseExerciseMediaItemStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "course_exercise_media_item"
"""
input CourseExerciseMediaItemStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseExerciseMediaItemStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseExerciseMediaItemStreamCursorValueInput {
  courseExerciseId: uuid
  createdAt: timestamptz
  label: String
  mediaItemId: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type CourseExerciseMediaItemSumFields {
  order: Int
}

"""
order by sum() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemSumOrderBy {
  order: OrderBy
}

"""
update columns of table "course_exercise_media_item"
"""
enum CourseExerciseMediaItemUpdateColumn {
  """column name"""
  courseExerciseId

  """column name"""
  createdAt

  """column name"""
  label

  """column name"""
  mediaItemId

  """column name"""
  order

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseExerciseMediaItemUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseExerciseMediaItemIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseExerciseMediaItemSetInput

  """filter the rows which have to be updated"""
  where: CourseExerciseMediaItemBoolExp!
}

"""aggregate varPop on columns"""
type CourseExerciseMediaItemVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type CourseExerciseMediaItemVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type CourseExerciseMediaItemVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "course_exercise_media_item"
"""
input CourseExerciseMediaItemVarianceOrderBy {
  order: OrderBy
}

"""aggregate min on columns"""
type CourseExerciseMinFields {
  body: String
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "course_exercise"
"""
type CourseExerciseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseExercise!]!
}

"""
input type for inserting object relation for remote table "course_exercise"
"""
input CourseExerciseObjRelInsertInput {
  data: CourseExerciseInsertInput!

  """upsert condition"""
  onConflict: CourseExerciseOnConflict
}

"""
on_conflict condition type for table "course_exercise"
"""
input CourseExerciseOnConflict {
  constraint: CourseExerciseConstraint!
  updateColumns: [CourseExerciseUpdateColumn!]! = []
  where: CourseExerciseBoolExp
}

"""Ordering options when selecting data from "course_exercise"."""
input CourseExerciseOrderBy {
  body: OrderBy
  categoriesAggregate: CourseExerciseCategoryAggregateOrderBy
  coverPhoto: MediaItemOrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  exerciseMediaItemsAggregate: CourseExerciseMediaItemAggregateOrderBy
  id: OrderBy
  kind: OrderBy
  mediaItemsAggregate: CourseExerciseMediaItemAggregateOrderBy
  metadata: OrderBy
  name: OrderBy
  sectionExercisesAggregate: CourseLessonSectionExerciseAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: course_exercise"""
input CourseExercisePkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input CourseExercisePrependInput {
  metadata: jsonb
}

"""
select columns of table "course_exercise"
"""
enum CourseExerciseSelectColumn {
  """column name"""
  body

  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

"""
input type for updating data in table "course_exercise"
"""
input CourseExerciseSetInput {
  body: String
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  kind: String
  metadata: jsonb
  name: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
Streaming cursor of the table "course_exercise"
"""
input CourseExerciseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseExerciseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseExerciseStreamCursorValueInput {
  body: String
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  kind: String
  metadata: jsonb
  name: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
update columns of table "course_exercise"
"""
enum CourseExerciseUpdateColumn {
  """column name"""
  body

  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

input CourseExerciseUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: CourseExerciseAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: CourseExerciseDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: CourseExerciseDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: CourseExerciseDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: CourseExercisePrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseExerciseSetInput

  """filter the rows which have to be updated"""
  where: CourseExerciseBoolExp!
}

"""
input type for inserting data into table "course"
"""
input CourseInsertInput {
  copiedFromCourseId: uuid
  coverPhoto: MediaItemObjRelInsertInput
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  lessons: CourseLessonArrRelInsertInput
  name: String
  profileId: uuid
  slug: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "course_lesson"
"""
type CourseLesson {
  """An object relationship"""
  course: Course!
  courseId: uuid!

  """An object relationship"""
  coverPhoto: MediaItem
  coverPhotoId: String
  createdAt: timestamptz!
  id: uuid!
  name: String!
  order: Int

  """An array relationship"""
  sections(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): [CourseLessonSection!]!

  """An aggregate relationship"""
  sectionsAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): CourseLessonSectionAggregate!
  slug: String
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_lesson"
"""
type CourseLessonAggregate {
  aggregate: CourseLessonAggregateFields
  nodes: [CourseLesson!]!
}

input CourseLessonAggregateBoolExp {
  count: courseLessonAggregateBoolExpCount
}

"""
aggregate fields of "course_lesson"
"""
type CourseLessonAggregateFields {
  avg: CourseLessonAvgFields
  count(columns: [CourseLessonSelectColumn!], distinct: Boolean): Int!
  max: CourseLessonMaxFields
  min: CourseLessonMinFields
  stddev: CourseLessonStddevFields
  stddevPop: CourseLessonStddevPopFields
  stddevSamp: CourseLessonStddevSampFields
  sum: CourseLessonSumFields
  varPop: CourseLessonVarPopFields
  varSamp: CourseLessonVarSampFields
  variance: CourseLessonVarianceFields
}

"""
order by aggregate values of table "course_lesson"
"""
input CourseLessonAggregateOrderBy {
  avg: CourseLessonAvgOrderBy
  count: OrderBy
  max: CourseLessonMaxOrderBy
  min: CourseLessonMinOrderBy
  stddev: CourseLessonStddevOrderBy
  stddevPop: CourseLessonStddevPopOrderBy
  stddevSamp: CourseLessonStddevSampOrderBy
  sum: CourseLessonSumOrderBy
  varPop: CourseLessonVarPopOrderBy
  varSamp: CourseLessonVarSampOrderBy
  variance: CourseLessonVarianceOrderBy
}

"""
input type for inserting array relation for remote table "course_lesson"
"""
input CourseLessonArrRelInsertInput {
  data: [CourseLessonInsertInput!]!

  """upsert condition"""
  onConflict: CourseLessonOnConflict
}

"""aggregate avg on columns"""
type CourseLessonAvgFields {
  order: Float
}

"""
order by avg() on columns of table "course_lesson"
"""
input CourseLessonAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "course_lesson". All fields are combined with a logical 'AND'.
"""
input CourseLessonBoolExp {
  _and: [CourseLessonBoolExp!]
  _not: CourseLessonBoolExp
  _or: [CourseLessonBoolExp!]
  course: CourseBoolExp
  courseId: UuidComparisonExp
  coverPhoto: MediaItemBoolExp
  coverPhotoId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  order: IntComparisonExp
  sections: CourseLessonSectionBoolExp
  sectionsAggregate: CourseLessonSectionAggregateBoolExp
  slug: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_lesson"
"""
enum CourseLessonConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_lesson_pkey

  """
  unique or primary key constraint on columns "slug", "tenant_id"
  """
  course_lesson_slug_tenant_id_key
}

"""
columns and relationships of "course_lesson_entry"
"""
type CourseLessonEntry {
  createdAt: timestamptz!
  durationMilliseconds: Int!

  """An array relationship"""
  exerciseEntries(
    """distinct select on columns"""
    distinctOn: [CourseExerciseEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseEntryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): [CourseExerciseEntry!]!

  """An aggregate relationship"""
  exerciseEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseEntryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): CourseExerciseEntryAggregate!
  id: uuid!

  """An object relationship"""
  lesson: CourseLesson!
  lessonId: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  profileId: uuid!
  tenantId: String!
  timestamp: timestamptz!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_lesson_entry"
"""
type CourseLessonEntryAggregate {
  aggregate: CourseLessonEntryAggregateFields
  nodes: [CourseLessonEntry!]!
}

"""
aggregate fields of "course_lesson_entry"
"""
type CourseLessonEntryAggregateFields {
  avg: CourseLessonEntryAvgFields
  count(columns: [CourseLessonEntrySelectColumn!], distinct: Boolean): Int!
  max: CourseLessonEntryMaxFields
  min: CourseLessonEntryMinFields
  stddev: CourseLessonEntryStddevFields
  stddevPop: CourseLessonEntryStddevPopFields
  stddevSamp: CourseLessonEntryStddevSampFields
  sum: CourseLessonEntrySumFields
  varPop: CourseLessonEntryVarPopFields
  varSamp: CourseLessonEntryVarSampFields
  variance: CourseLessonEntryVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input CourseLessonEntryAppendInput {
  metadata: jsonb
}

"""aggregate avg on columns"""
type CourseLessonEntryAvgFields {
  durationMilliseconds: Float
}

"""
Boolean expression to filter rows from the table "course_lesson_entry". All fields are combined with a logical 'AND'.
"""
input CourseLessonEntryBoolExp {
  _and: [CourseLessonEntryBoolExp!]
  _not: CourseLessonEntryBoolExp
  _or: [CourseLessonEntryBoolExp!]
  createdAt: TimestamptzComparisonExp
  durationMilliseconds: IntComparisonExp
  exerciseEntries: CourseExerciseEntryBoolExp
  exerciseEntriesAggregate: CourseExerciseEntryAggregateBoolExp
  id: UuidComparisonExp
  lesson: CourseLessonBoolExp
  lessonId: UuidComparisonExp
  metadata: JsonbComparisonExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  timestamp: TimestamptzComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_lesson_entry"
"""
enum CourseLessonEntryConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_lesson_entry_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input CourseLessonEntryDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input CourseLessonEntryDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input CourseLessonEntryDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "course_lesson_entry"
"""
input CourseLessonEntryIncInput {
  durationMilliseconds: Int
}

"""
input type for inserting data into table "course_lesson_entry"
"""
input CourseLessonEntryInsertInput {
  createdAt: timestamptz
  durationMilliseconds: Int
  exerciseEntries: CourseExerciseEntryArrRelInsertInput
  id: uuid
  lesson: CourseLessonObjRelInsertInput
  lessonId: uuid
  metadata: jsonb
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseLessonEntryMaxFields {
  createdAt: timestamptz
  durationMilliseconds: Int
  id: uuid
  lessonId: uuid
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type CourseLessonEntryMinFields {
  createdAt: timestamptz
  durationMilliseconds: Int
  id: uuid
  lessonId: uuid
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""
response of any mutation on the table "course_lesson_entry"
"""
type CourseLessonEntryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseLessonEntry!]!
}

"""
input type for inserting object relation for remote table "course_lesson_entry"
"""
input CourseLessonEntryObjRelInsertInput {
  data: CourseLessonEntryInsertInput!

  """upsert condition"""
  onConflict: CourseLessonEntryOnConflict
}

"""
on_conflict condition type for table "course_lesson_entry"
"""
input CourseLessonEntryOnConflict {
  constraint: CourseLessonEntryConstraint!
  updateColumns: [CourseLessonEntryUpdateColumn!]! = []
  where: CourseLessonEntryBoolExp
}

"""Ordering options when selecting data from "course_lesson_entry"."""
input CourseLessonEntryOrderBy {
  createdAt: OrderBy
  durationMilliseconds: OrderBy
  exerciseEntriesAggregate: CourseExerciseEntryAggregateOrderBy
  id: OrderBy
  lesson: CourseLessonOrderBy
  lessonId: OrderBy
  metadata: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_lesson_entry"""
input CourseLessonEntryPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input CourseLessonEntryPrependInput {
  metadata: jsonb
}

"""
select columns of table "course_lesson_entry"
"""
enum CourseLessonEntrySelectColumn {
  """column name"""
  createdAt

  """column name"""
  durationMilliseconds

  """column name"""
  id

  """column name"""
  lessonId

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  timestamp

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_lesson_entry"
"""
input CourseLessonEntrySetInput {
  createdAt: timestamptz
  durationMilliseconds: Int
  id: uuid
  lessonId: uuid
  metadata: jsonb
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CourseLessonEntryStddevFields {
  durationMilliseconds: Float
}

"""aggregate stddevPop on columns"""
type CourseLessonEntryStddevPopFields {
  durationMilliseconds: Float
}

"""aggregate stddevSamp on columns"""
type CourseLessonEntryStddevSampFields {
  durationMilliseconds: Float
}

"""
Streaming cursor of the table "course_lesson_entry"
"""
input CourseLessonEntryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseLessonEntryStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseLessonEntryStreamCursorValueInput {
  createdAt: timestamptz
  durationMilliseconds: Int
  id: uuid
  lessonId: uuid
  metadata: jsonb
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type CourseLessonEntrySumFields {
  durationMilliseconds: Int
}

"""
update columns of table "course_lesson_entry"
"""
enum CourseLessonEntryUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  durationMilliseconds

  """column name"""
  id

  """column name"""
  lessonId

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  timestamp

  """column name"""
  updatedAt
}

input CourseLessonEntryUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: CourseLessonEntryAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: CourseLessonEntryDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: CourseLessonEntryDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: CourseLessonEntryDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseLessonEntryIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: CourseLessonEntryPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseLessonEntrySetInput

  """filter the rows which have to be updated"""
  where: CourseLessonEntryBoolExp!
}

"""aggregate varPop on columns"""
type CourseLessonEntryVarPopFields {
  durationMilliseconds: Float
}

"""aggregate varSamp on columns"""
type CourseLessonEntryVarSampFields {
  durationMilliseconds: Float
}

"""aggregate variance on columns"""
type CourseLessonEntryVarianceFields {
  durationMilliseconds: Float
}

"""
input type for incrementing numeric columns in table "course_lesson"
"""
input CourseLessonIncInput {
  order: Int
}

"""
input type for inserting data into table "course_lesson"
"""
input CourseLessonInsertInput {
  course: CourseObjRelInsertInput
  courseId: uuid
  coverPhoto: MediaItemObjRelInsertInput
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  order: Int
  sections: CourseLessonSectionArrRelInsertInput
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseLessonMaxFields {
  courseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  order: Int
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_lesson"
"""
input CourseLessonMaxOrderBy {
  courseId: OrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  order: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseLessonMinFields {
  courseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  order: Int
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_lesson"
"""
input CourseLessonMinOrderBy {
  courseId: OrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  order: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_lesson"
"""
type CourseLessonMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseLesson!]!
}

"""
input type for inserting object relation for remote table "course_lesson"
"""
input CourseLessonObjRelInsertInput {
  data: CourseLessonInsertInput!

  """upsert condition"""
  onConflict: CourseLessonOnConflict
}

"""
on_conflict condition type for table "course_lesson"
"""
input CourseLessonOnConflict {
  constraint: CourseLessonConstraint!
  updateColumns: [CourseLessonUpdateColumn!]! = []
  where: CourseLessonBoolExp
}

"""Ordering options when selecting data from "course_lesson"."""
input CourseLessonOrderBy {
  course: CourseOrderBy
  courseId: OrderBy
  coverPhoto: MediaItemOrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  order: OrderBy
  sectionsAggregate: CourseLessonSectionAggregateOrderBy
  slug: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_lesson"""
input CourseLessonPkColumnsInput {
  id: uuid!
}

"""
columns and relationships of "course_lesson_section"
"""
type CourseLessonSection {
  """An object relationship"""
  coverPhoto: MediaItem
  coverPhotoId: String
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  lesson: CourseLesson!
  lessonId: uuid!
  name: String!
  order: Int

  """An array relationship"""
  sectionExercises(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): [CourseLessonSectionExercise!]!

  """An aggregate relationship"""
  sectionExercisesAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): CourseLessonSectionExerciseAggregate!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_lesson_section"
"""
type CourseLessonSectionAggregate {
  aggregate: CourseLessonSectionAggregateFields
  nodes: [CourseLessonSection!]!
}

input CourseLessonSectionAggregateBoolExp {
  count: courseLessonSectionAggregateBoolExpCount
}

"""
aggregate fields of "course_lesson_section"
"""
type CourseLessonSectionAggregateFields {
  avg: CourseLessonSectionAvgFields
  count(columns: [CourseLessonSectionSelectColumn!], distinct: Boolean): Int!
  max: CourseLessonSectionMaxFields
  min: CourseLessonSectionMinFields
  stddev: CourseLessonSectionStddevFields
  stddevPop: CourseLessonSectionStddevPopFields
  stddevSamp: CourseLessonSectionStddevSampFields
  sum: CourseLessonSectionSumFields
  varPop: CourseLessonSectionVarPopFields
  varSamp: CourseLessonSectionVarSampFields
  variance: CourseLessonSectionVarianceFields
}

"""
order by aggregate values of table "course_lesson_section"
"""
input CourseLessonSectionAggregateOrderBy {
  avg: CourseLessonSectionAvgOrderBy
  count: OrderBy
  max: CourseLessonSectionMaxOrderBy
  min: CourseLessonSectionMinOrderBy
  stddev: CourseLessonSectionStddevOrderBy
  stddevPop: CourseLessonSectionStddevPopOrderBy
  stddevSamp: CourseLessonSectionStddevSampOrderBy
  sum: CourseLessonSectionSumOrderBy
  varPop: CourseLessonSectionVarPopOrderBy
  varSamp: CourseLessonSectionVarSampOrderBy
  variance: CourseLessonSectionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "course_lesson_section"
"""
input CourseLessonSectionArrRelInsertInput {
  data: [CourseLessonSectionInsertInput!]!

  """upsert condition"""
  onConflict: CourseLessonSectionOnConflict
}

"""aggregate avg on columns"""
type CourseLessonSectionAvgFields {
  order: Float
}

"""
order by avg() on columns of table "course_lesson_section"
"""
input CourseLessonSectionAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "course_lesson_section". All fields are combined with a logical 'AND'.
"""
input CourseLessonSectionBoolExp {
  _and: [CourseLessonSectionBoolExp!]
  _not: CourseLessonSectionBoolExp
  _or: [CourseLessonSectionBoolExp!]
  coverPhoto: MediaItemBoolExp
  coverPhotoId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  lesson: CourseLessonBoolExp
  lessonId: UuidComparisonExp
  name: StringComparisonExp
  order: IntComparisonExp
  sectionExercises: CourseLessonSectionExerciseBoolExp
  sectionExercisesAggregate: CourseLessonSectionExerciseAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_lesson_section"
"""
enum CourseLessonSectionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_lesson_section_pkey
}

"""
columns and relationships of "course_lesson_section_exercise"
"""
type CourseLessonSectionExercise {
  createdAt: timestamptz!

  """An object relationship"""
  exercise: CourseExercise!
  exerciseId: uuid!
  lessonSectionId: uuid!
  order: Int

  """An object relationship"""
  section: CourseLessonSection!

  """An array relationship"""
  substitutions(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSubSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseSubOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): [CourseLessonSectionExerciseSub!]!

  """An aggregate relationship"""
  substitutionsAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSubSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseSubOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): CourseLessonSectionExerciseSubAggregate!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_lesson_section_exercise"
"""
type CourseLessonSectionExerciseAggregate {
  aggregate: CourseLessonSectionExerciseAggregateFields
  nodes: [CourseLessonSectionExercise!]!
}

input CourseLessonSectionExerciseAggregateBoolExp {
  count: courseLessonSectionExerciseAggregateBoolExpCount
}

"""
aggregate fields of "course_lesson_section_exercise"
"""
type CourseLessonSectionExerciseAggregateFields {
  avg: CourseLessonSectionExerciseAvgFields
  count(columns: [CourseLessonSectionExerciseSelectColumn!], distinct: Boolean): Int!
  max: CourseLessonSectionExerciseMaxFields
  min: CourseLessonSectionExerciseMinFields
  stddev: CourseLessonSectionExerciseStddevFields
  stddevPop: CourseLessonSectionExerciseStddevPopFields
  stddevSamp: CourseLessonSectionExerciseStddevSampFields
  sum: CourseLessonSectionExerciseSumFields
  varPop: CourseLessonSectionExerciseVarPopFields
  varSamp: CourseLessonSectionExerciseVarSampFields
  variance: CourseLessonSectionExerciseVarianceFields
}

"""
order by aggregate values of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseAggregateOrderBy {
  avg: CourseLessonSectionExerciseAvgOrderBy
  count: OrderBy
  max: CourseLessonSectionExerciseMaxOrderBy
  min: CourseLessonSectionExerciseMinOrderBy
  stddev: CourseLessonSectionExerciseStddevOrderBy
  stddevPop: CourseLessonSectionExerciseStddevPopOrderBy
  stddevSamp: CourseLessonSectionExerciseStddevSampOrderBy
  sum: CourseLessonSectionExerciseSumOrderBy
  varPop: CourseLessonSectionExerciseVarPopOrderBy
  varSamp: CourseLessonSectionExerciseVarSampOrderBy
  variance: CourseLessonSectionExerciseVarianceOrderBy
}

"""
input type for inserting array relation for remote table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseArrRelInsertInput {
  data: [CourseLessonSectionExerciseInsertInput!]!

  """upsert condition"""
  onConflict: CourseLessonSectionExerciseOnConflict
}

"""aggregate avg on columns"""
type CourseLessonSectionExerciseAvgFields {
  order: Float
}

"""
order by avg() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "course_lesson_section_exercise". All fields are combined with a logical 'AND'.
"""
input CourseLessonSectionExerciseBoolExp {
  _and: [CourseLessonSectionExerciseBoolExp!]
  _not: CourseLessonSectionExerciseBoolExp
  _or: [CourseLessonSectionExerciseBoolExp!]
  createdAt: TimestamptzComparisonExp
  exercise: CourseExerciseBoolExp
  exerciseId: UuidComparisonExp
  lessonSectionId: UuidComparisonExp
  order: IntComparisonExp
  section: CourseLessonSectionBoolExp
  substitutions: CourseLessonSectionExerciseSubBoolExp
  substitutionsAggregate: CourseLessonSectionExerciseSubAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_lesson_section_exercise"
"""
enum CourseLessonSectionExerciseConstraint {
  """
  unique or primary key constraint on columns "exercise_id", "lesson_section_id"
  """
  course_lesson_section_exercise_pkey
}

"""
input type for incrementing numeric columns in table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseIncInput {
  order: Int
}

"""
input type for inserting data into table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseInsertInput {
  createdAt: timestamptz
  exercise: CourseExerciseObjRelInsertInput
  exerciseId: uuid
  lessonSectionId: uuid
  order: Int
  section: CourseLessonSectionObjRelInsertInput
  substitutions: CourseLessonSectionExerciseSubArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseLessonSectionExerciseMaxFields {
  createdAt: timestamptz
  exerciseId: uuid
  lessonSectionId: uuid
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseMaxOrderBy {
  createdAt: OrderBy
  exerciseId: OrderBy
  lessonSectionId: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseLessonSectionExerciseMinFields {
  createdAt: timestamptz
  exerciseId: uuid
  lessonSectionId: uuid
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseMinOrderBy {
  createdAt: OrderBy
  exerciseId: OrderBy
  lessonSectionId: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_lesson_section_exercise"
"""
type CourseLessonSectionExerciseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseLessonSectionExercise!]!
}

"""
on_conflict condition type for table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseOnConflict {
  constraint: CourseLessonSectionExerciseConstraint!
  updateColumns: [CourseLessonSectionExerciseUpdateColumn!]! = []
  where: CourseLessonSectionExerciseBoolExp
}

"""
Ordering options when selecting data from "course_lesson_section_exercise".
"""
input CourseLessonSectionExerciseOrderBy {
  createdAt: OrderBy
  exercise: CourseExerciseOrderBy
  exerciseId: OrderBy
  lessonSectionId: OrderBy
  order: OrderBy
  section: CourseLessonSectionOrderBy
  substitutionsAggregate: CourseLessonSectionExerciseSubAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_lesson_section_exercise"""
input CourseLessonSectionExercisePkColumnsInput {
  exerciseId: uuid!
  lessonSectionId: uuid!
}

"""
select columns of table "course_lesson_section_exercise"
"""
enum CourseLessonSectionExerciseSelectColumn {
  """column name"""
  createdAt

  """column name"""
  exerciseId

  """column name"""
  lessonSectionId

  """column name"""
  order

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseSetInput {
  createdAt: timestamptz
  exerciseId: uuid
  lessonSectionId: uuid
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CourseLessonSectionExerciseStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseLessonSectionExerciseStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseLessonSectionExerciseStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseLessonSectionExerciseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseLessonSectionExerciseStreamCursorValueInput {
  createdAt: timestamptz
  exerciseId: uuid
  lessonSectionId: uuid
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "course_lesson_section_exercise_sub"
"""
type CourseLessonSectionExerciseSub {
  createdAt: timestamptz!
  exerciseId: uuid!
  id: uuid!
  lessonSectionId: uuid!
  profileId: uuid!
  subExerciseId: uuid!

  """An object relationship"""
  substitutionExercise: CourseExercise!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "course_lesson_section_exercise_sub"
"""
type CourseLessonSectionExerciseSubAggregate {
  aggregate: CourseLessonSectionExerciseSubAggregateFields
  nodes: [CourseLessonSectionExerciseSub!]!
}

input CourseLessonSectionExerciseSubAggregateBoolExp {
  count: courseLessonSectionExerciseSubAggregateBoolExpCount
}

"""
aggregate fields of "course_lesson_section_exercise_sub"
"""
type CourseLessonSectionExerciseSubAggregateFields {
  count(columns: [CourseLessonSectionExerciseSubSelectColumn!], distinct: Boolean): Int!
  max: CourseLessonSectionExerciseSubMaxFields
  min: CourseLessonSectionExerciseSubMinFields
}

"""
order by aggregate values of table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubAggregateOrderBy {
  count: OrderBy
  max: CourseLessonSectionExerciseSubMaxOrderBy
  min: CourseLessonSectionExerciseSubMinOrderBy
}

"""
input type for inserting array relation for remote table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubArrRelInsertInput {
  data: [CourseLessonSectionExerciseSubInsertInput!]!

  """upsert condition"""
  onConflict: CourseLessonSectionExerciseSubOnConflict
}

"""
Boolean expression to filter rows from the table "course_lesson_section_exercise_sub". All fields are combined with a logical 'AND'.
"""
input CourseLessonSectionExerciseSubBoolExp {
  _and: [CourseLessonSectionExerciseSubBoolExp!]
  _not: CourseLessonSectionExerciseSubBoolExp
  _or: [CourseLessonSectionExerciseSubBoolExp!]
  createdAt: TimestamptzComparisonExp
  exerciseId: UuidComparisonExp
  id: UuidComparisonExp
  lessonSectionId: UuidComparisonExp
  profileId: UuidComparisonExp
  subExerciseId: UuidComparisonExp
  substitutionExercise: CourseExerciseBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "course_lesson_section_exercise_sub"
"""
enum CourseLessonSectionExerciseSubConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  course_lesson_section_exercise_sub_pkey
}

"""
input type for inserting data into table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubInsertInput {
  createdAt: timestamptz
  exerciseId: uuid
  id: uuid
  lessonSectionId: uuid
  profileId: uuid
  subExerciseId: uuid
  substitutionExercise: CourseExerciseObjRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseLessonSectionExerciseSubMaxFields {
  createdAt: timestamptz
  exerciseId: uuid
  id: uuid
  lessonSectionId: uuid
  profileId: uuid
  subExerciseId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubMaxOrderBy {
  createdAt: OrderBy
  exerciseId: OrderBy
  id: OrderBy
  lessonSectionId: OrderBy
  profileId: OrderBy
  subExerciseId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseLessonSectionExerciseSubMinFields {
  createdAt: timestamptz
  exerciseId: uuid
  id: uuid
  lessonSectionId: uuid
  profileId: uuid
  subExerciseId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubMinOrderBy {
  createdAt: OrderBy
  exerciseId: OrderBy
  id: OrderBy
  lessonSectionId: OrderBy
  profileId: OrderBy
  subExerciseId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_lesson_section_exercise_sub"
"""
type CourseLessonSectionExerciseSubMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseLessonSectionExerciseSub!]!
}

"""
on_conflict condition type for table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubOnConflict {
  constraint: CourseLessonSectionExerciseSubConstraint!
  updateColumns: [CourseLessonSectionExerciseSubUpdateColumn!]! = []
  where: CourseLessonSectionExerciseSubBoolExp
}

"""
Ordering options when selecting data from "course_lesson_section_exercise_sub".
"""
input CourseLessonSectionExerciseSubOrderBy {
  createdAt: OrderBy
  exerciseId: OrderBy
  id: OrderBy
  lessonSectionId: OrderBy
  profileId: OrderBy
  subExerciseId: OrderBy
  substitutionExercise: CourseExerciseOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
primary key columns input for table: course_lesson_section_exercise_sub
"""
input CourseLessonSectionExerciseSubPkColumnsInput {
  id: uuid!
}

"""
select columns of table "course_lesson_section_exercise_sub"
"""
enum CourseLessonSectionExerciseSubSelectColumn {
  """column name"""
  createdAt

  """column name"""
  exerciseId

  """column name"""
  id

  """column name"""
  lessonSectionId

  """column name"""
  profileId

  """column name"""
  subExerciseId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubSetInput {
  createdAt: timestamptz
  exerciseId: uuid
  id: uuid
  lessonSectionId: uuid
  profileId: uuid
  subExerciseId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "course_lesson_section_exercise_sub"
"""
input CourseLessonSectionExerciseSubStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseLessonSectionExerciseSubStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseLessonSectionExerciseSubStreamCursorValueInput {
  createdAt: timestamptz
  exerciseId: uuid
  id: uuid
  lessonSectionId: uuid
  profileId: uuid
  subExerciseId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "course_lesson_section_exercise_sub"
"""
enum CourseLessonSectionExerciseSubUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  exerciseId

  """column name"""
  id

  """column name"""
  lessonSectionId

  """column name"""
  profileId

  """column name"""
  subExerciseId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseLessonSectionExerciseSubUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CourseLessonSectionExerciseSubSetInput

  """filter the rows which have to be updated"""
  where: CourseLessonSectionExerciseSubBoolExp!
}

"""aggregate sum on columns"""
type CourseLessonSectionExerciseSumFields {
  order: Int
}

"""
order by sum() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseSumOrderBy {
  order: OrderBy
}

"""
update columns of table "course_lesson_section_exercise"
"""
enum CourseLessonSectionExerciseUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  exerciseId

  """column name"""
  lessonSectionId

  """column name"""
  order

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseLessonSectionExerciseUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseLessonSectionExerciseIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseLessonSectionExerciseSetInput

  """filter the rows which have to be updated"""
  where: CourseLessonSectionExerciseBoolExp!
}

"""aggregate varPop on columns"""
type CourseLessonSectionExerciseVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type CourseLessonSectionExerciseVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type CourseLessonSectionExerciseVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "course_lesson_section_exercise"
"""
input CourseLessonSectionExerciseVarianceOrderBy {
  order: OrderBy
}

"""
input type for incrementing numeric columns in table "course_lesson_section"
"""
input CourseLessonSectionIncInput {
  order: Int
}

"""
input type for inserting data into table "course_lesson_section"
"""
input CourseLessonSectionInsertInput {
  coverPhoto: MediaItemObjRelInsertInput
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  lesson: CourseLessonObjRelInsertInput
  lessonId: uuid
  name: String
  order: Int
  sectionExercises: CourseLessonSectionExerciseArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type CourseLessonSectionMaxFields {
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  lessonId: uuid
  name: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "course_lesson_section"
"""
input CourseLessonSectionMaxOrderBy {
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  lessonId: OrderBy
  name: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type CourseLessonSectionMinFields {
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  lessonId: uuid
  name: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "course_lesson_section"
"""
input CourseLessonSectionMinOrderBy {
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  lessonId: OrderBy
  name: OrderBy
  order: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "course_lesson_section"
"""
type CourseLessonSectionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [CourseLessonSection!]!
}

"""
input type for inserting object relation for remote table "course_lesson_section"
"""
input CourseLessonSectionObjRelInsertInput {
  data: CourseLessonSectionInsertInput!

  """upsert condition"""
  onConflict: CourseLessonSectionOnConflict
}

"""
on_conflict condition type for table "course_lesson_section"
"""
input CourseLessonSectionOnConflict {
  constraint: CourseLessonSectionConstraint!
  updateColumns: [CourseLessonSectionUpdateColumn!]! = []
  where: CourseLessonSectionBoolExp
}

"""Ordering options when selecting data from "course_lesson_section"."""
input CourseLessonSectionOrderBy {
  coverPhoto: MediaItemOrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  lesson: CourseLessonOrderBy
  lessonId: OrderBy
  name: OrderBy
  order: OrderBy
  sectionExercisesAggregate: CourseLessonSectionExerciseAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: course_lesson_section"""
input CourseLessonSectionPkColumnsInput {
  id: uuid!
}

"""
select columns of table "course_lesson_section"
"""
enum CourseLessonSectionSelectColumn {
  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  lessonId

  """column name"""
  name

  """column name"""
  order

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_lesson_section"
"""
input CourseLessonSectionSetInput {
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  lessonId: uuid
  name: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CourseLessonSectionStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "course_lesson_section"
"""
input CourseLessonSectionStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseLessonSectionStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "course_lesson_section"
"""
input CourseLessonSectionStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseLessonSectionStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "course_lesson_section"
"""
input CourseLessonSectionStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "course_lesson_section"
"""
input CourseLessonSectionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseLessonSectionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseLessonSectionStreamCursorValueInput {
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  lessonId: uuid
  name: String
  order: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type CourseLessonSectionSumFields {
  order: Int
}

"""
order by sum() on columns of table "course_lesson_section"
"""
input CourseLessonSectionSumOrderBy {
  order: OrderBy
}

"""
update columns of table "course_lesson_section"
"""
enum CourseLessonSectionUpdateColumn {
  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  lessonId

  """column name"""
  name

  """column name"""
  order

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseLessonSectionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseLessonSectionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseLessonSectionSetInput

  """filter the rows which have to be updated"""
  where: CourseLessonSectionBoolExp!
}

"""aggregate varPop on columns"""
type CourseLessonSectionVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "course_lesson_section"
"""
input CourseLessonSectionVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type CourseLessonSectionVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "course_lesson_section"
"""
input CourseLessonSectionVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type CourseLessonSectionVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "course_lesson_section"
"""
input CourseLessonSectionVarianceOrderBy {
  order: OrderBy
}

"""
select columns of table "course_lesson"
"""
enum CourseLessonSelectColumn {
  """column name"""
  courseId

  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  order

  """column name"""
  slug

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "course_lesson"
"""
input CourseLessonSetInput {
  courseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  order: Int
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type CourseLessonStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "course_lesson"
"""
input CourseLessonStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type CourseLessonStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "course_lesson"
"""
input CourseLessonStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type CourseLessonStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "course_lesson"
"""
input CourseLessonStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "course_lesson"
"""
input CourseLessonStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseLessonStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseLessonStreamCursorValueInput {
  courseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  order: Int
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type CourseLessonSumFields {
  order: Int
}

"""
order by sum() on columns of table "course_lesson"
"""
input CourseLessonSumOrderBy {
  order: OrderBy
}

"""
update columns of table "course_lesson"
"""
enum CourseLessonUpdateColumn {
  """column name"""
  courseId

  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  order

  """column name"""
  slug

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input CourseLessonUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: CourseLessonIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: CourseLessonSetInput

  """filter the rows which have to be updated"""
  where: CourseLessonBoolExp!
}

"""aggregate varPop on columns"""
type CourseLessonVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "course_lesson"
"""
input CourseLessonVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type CourseLessonVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "course_lesson"
"""
input CourseLessonVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type CourseLessonVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "course_lesson"
"""
input CourseLessonVarianceOrderBy {
  order: OrderBy
}

"""aggregate max on columns"""
type CourseMaxFields {
  copiedFromCourseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type CourseMinFields {
  copiedFromCourseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  slug: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "course"
"""
type CourseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Course!]!
}

"""
input type for inserting object relation for remote table "course"
"""
input CourseObjRelInsertInput {
  data: CourseInsertInput!

  """upsert condition"""
  onConflict: CourseOnConflict
}

"""
on_conflict condition type for table "course"
"""
input CourseOnConflict {
  constraint: CourseConstraint!
  updateColumns: [CourseUpdateColumn!]! = []
  where: CourseBoolExp
}

"""Ordering options when selecting data from "course"."""
input CourseOrderBy {
  copiedFromCourseId: OrderBy
  coverPhoto: MediaItemOrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  lessonsAggregate: CourseLessonAggregateOrderBy
  name: OrderBy
  profileId: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: course"""
input CoursePkColumnsInput {
  id: uuid!
}

"""
select columns of table "course"
"""
enum CourseSelectColumn {
  """column name"""
  copiedFromCourseId

  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  slug

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

"""
input type for updating data in table "course"
"""
input CourseSetInput {
  copiedFromCourseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  slug: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
Streaming cursor of the table "course"
"""
input CourseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CourseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CourseStreamCursorValueInput {
  copiedFromCourseId: uuid
  coverPhotoId: String
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  slug: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
update columns of table "course"
"""
enum CourseUpdateColumn {
  """column name"""
  copiedFromCourseId

  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  slug

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

input CourseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CourseSetInput

  """filter the rows which have to be updated"""
  where: CourseBoolExp!
}

input CreateTestProfileInput {
  parentNodeId: uuid
}

type CreateTestProfileOutput {
  profile: Profile
  profileId: uuid!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "document"
"""
type Document {
  body: String
  createdAt: timestamptz!
  id: uuid!
  isDeleted: Boolean!
  kind: DocumentKindEnum!
  profileId: uuid
  slug: citext!
  tenantId: String!
  title: String
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "document"
"""
type DocumentAggregate {
  aggregate: DocumentAggregateFields
  nodes: [Document!]!
}

"""
aggregate fields of "document"
"""
type DocumentAggregateFields {
  count(columns: [DocumentSelectColumn!], distinct: Boolean): Int!
  max: DocumentMaxFields
  min: DocumentMinFields
}

"""
columns and relationships of "document_block"
"""
type DocumentBlock {
  body: String

  """An array relationship"""
  childBlocks(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!

  """An aggregate relationship"""
  childBlocksAggregate(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): DocumentBlockAggregate!
  createdAt: timestamptz!

  """An object relationship"""
  document: Document!
  documentId: uuid!
  id: uuid!
  kind: DocumentBlockKindEnum!

  """An object relationship"""
  mediaItem: MediaItem
  mediaItemId: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  parentBlock: DocumentBlock
  parentBlockId: uuid
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "document_block"
"""
type DocumentBlockAggregate {
  aggregate: DocumentBlockAggregateFields
  nodes: [DocumentBlock!]!
}

input DocumentBlockAggregateBoolExp {
  count: documentBlockAggregateBoolExpCount
}

"""
aggregate fields of "document_block"
"""
type DocumentBlockAggregateFields {
  count(columns: [DocumentBlockSelectColumn!], distinct: Boolean): Int!
  max: DocumentBlockMaxFields
  min: DocumentBlockMinFields
}

"""
order by aggregate values of table "document_block"
"""
input DocumentBlockAggregateOrderBy {
  count: OrderBy
  max: DocumentBlockMaxOrderBy
  min: DocumentBlockMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input DocumentBlockAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "document_block"
"""
input DocumentBlockArrRelInsertInput {
  data: [DocumentBlockInsertInput!]!

  """upsert condition"""
  onConflict: DocumentBlockOnConflict
}

"""
Boolean expression to filter rows from the table "document_block". All fields are combined with a logical 'AND'.
"""
input DocumentBlockBoolExp {
  _and: [DocumentBlockBoolExp!]
  _not: DocumentBlockBoolExp
  _or: [DocumentBlockBoolExp!]
  body: StringComparisonExp
  childBlocks: DocumentBlockBoolExp
  childBlocksAggregate: DocumentBlockAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  document: DocumentBoolExp
  documentId: UuidComparisonExp
  id: UuidComparisonExp
  kind: DocumentBlockKindEnumComparisonExp
  mediaItem: MediaItemBoolExp
  mediaItemId: StringComparisonExp
  metadata: JsonbComparisonExp
  parentBlock: DocumentBlockBoolExp
  parentBlockId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "document_block"
"""
enum DocumentBlockConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  document_block_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input DocumentBlockDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input DocumentBlockDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input DocumentBlockDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "document_block"
"""
input DocumentBlockInsertInput {
  body: String
  childBlocks: DocumentBlockArrRelInsertInput
  createdAt: timestamptz
  document: DocumentObjRelInsertInput
  documentId: uuid
  id: uuid
  kind: DocumentBlockKindEnum
  mediaItem: MediaItemObjRelInsertInput
  mediaItemId: String
  metadata: jsonb
  parentBlock: DocumentBlockObjRelInsertInput
  parentBlockId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "document_block_kind"
"""
type DocumentBlockKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "document_block_kind". All fields are combined with a logical 'AND'.
"""
input DocumentBlockKindBoolExp {
  _and: [DocumentBlockKindBoolExp!]
  _not: DocumentBlockKindBoolExp
  _or: [DocumentBlockKindBoolExp!]
  id: StringComparisonExp
}

enum DocumentBlockKindEnum {
  IMAGE
  TEXT
}

"""
Boolean expression to compare columns of type "DocumentBlockKindEnum". All fields are combined with logical 'AND'.
"""
input DocumentBlockKindEnumComparisonExp {
  _eq: DocumentBlockKindEnum
  _in: [DocumentBlockKindEnum!]
  _isNull: Boolean
  _neq: DocumentBlockKindEnum
  _nin: [DocumentBlockKindEnum!]
}

"""Ordering options when selecting data from "document_block_kind"."""
input DocumentBlockKindOrderBy {
  id: OrderBy
}

"""
select columns of table "document_block_kind"
"""
enum DocumentBlockKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "document_block_kind"
"""
input DocumentBlockKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentBlockKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentBlockKindStreamCursorValueInput {
  id: String
}

"""aggregate max on columns"""
type DocumentBlockMaxFields {
  body: String
  createdAt: timestamptz
  documentId: uuid
  id: uuid
  mediaItemId: String
  parentBlockId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "document_block"
"""
input DocumentBlockMaxOrderBy {
  body: OrderBy
  createdAt: OrderBy
  documentId: OrderBy
  id: OrderBy
  mediaItemId: OrderBy
  parentBlockId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type DocumentBlockMinFields {
  body: String
  createdAt: timestamptz
  documentId: uuid
  id: uuid
  mediaItemId: String
  parentBlockId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "document_block"
"""
input DocumentBlockMinOrderBy {
  body: OrderBy
  createdAt: OrderBy
  documentId: OrderBy
  id: OrderBy
  mediaItemId: OrderBy
  parentBlockId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "document_block"
"""
type DocumentBlockMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [DocumentBlock!]!
}

"""
input type for inserting object relation for remote table "document_block"
"""
input DocumentBlockObjRelInsertInput {
  data: DocumentBlockInsertInput!

  """upsert condition"""
  onConflict: DocumentBlockOnConflict
}

"""
on_conflict condition type for table "document_block"
"""
input DocumentBlockOnConflict {
  constraint: DocumentBlockConstraint!
  updateColumns: [DocumentBlockUpdateColumn!]! = []
  where: DocumentBlockBoolExp
}

"""Ordering options when selecting data from "document_block"."""
input DocumentBlockOrderBy {
  body: OrderBy
  childBlocksAggregate: DocumentBlockAggregateOrderBy
  createdAt: OrderBy
  document: DocumentOrderBy
  documentId: OrderBy
  id: OrderBy
  kind: OrderBy
  mediaItem: MediaItemOrderBy
  mediaItemId: OrderBy
  metadata: OrderBy
  parentBlock: DocumentBlockOrderBy
  parentBlockId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: document_block"""
input DocumentBlockPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input DocumentBlockPrependInput {
  metadata: jsonb
}

"""
select columns of table "document_block"
"""
enum DocumentBlockSelectColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  documentId

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  mediaItemId

  """column name"""
  metadata

  """column name"""
  parentBlockId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "document_block"
"""
input DocumentBlockSetInput {
  body: String
  createdAt: timestamptz
  documentId: uuid
  id: uuid
  kind: DocumentBlockKindEnum
  mediaItemId: String
  metadata: jsonb
  parentBlockId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "document_block"
"""
input DocumentBlockStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentBlockStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentBlockStreamCursorValueInput {
  body: String
  createdAt: timestamptz
  documentId: uuid
  id: uuid
  kind: DocumentBlockKindEnum
  mediaItemId: String
  metadata: jsonb
  parentBlockId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "document_block"
"""
enum DocumentBlockUpdateColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  documentId

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  mediaItemId

  """column name"""
  metadata

  """column name"""
  parentBlockId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input DocumentBlockUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: DocumentBlockAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: DocumentBlockDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: DocumentBlockDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: DocumentBlockDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: DocumentBlockPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: DocumentBlockSetInput

  """filter the rows which have to be updated"""
  where: DocumentBlockBoolExp!
}

"""
Boolean expression to filter rows from the table "document". All fields are combined with a logical 'AND'.
"""
input DocumentBoolExp {
  _and: [DocumentBoolExp!]
  _not: DocumentBoolExp
  _or: [DocumentBoolExp!]
  body: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isDeleted: BooleanComparisonExp
  kind: DocumentKindEnumComparisonExp
  profileId: UuidComparisonExp
  slug: CitextComparisonExp
  tenantId: StringComparisonExp
  title: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "document"
"""
enum DocumentConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  document_pkey

  """
  unique or primary key constraint on columns "slug", "tenant_id"
  """
  document_slug_tenant_id_key
}

"""
input type for inserting data into table "document"
"""
input DocumentInsertInput {
  body: String
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: DocumentKindEnum
  profileId: uuid
  slug: citext
  tenantId: String
  title: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "document_kind"
"""
type DocumentKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "document_kind". All fields are combined with a logical 'AND'.
"""
input DocumentKindBoolExp {
  _and: [DocumentKindBoolExp!]
  _not: DocumentKindBoolExp
  _or: [DocumentKindBoolExp!]
  id: StringComparisonExp
}

enum DocumentKindEnum {
  AGREEMENT
  PAGE
}

"""
Boolean expression to compare columns of type "DocumentKindEnum". All fields are combined with logical 'AND'.
"""
input DocumentKindEnumComparisonExp {
  _eq: DocumentKindEnum
  _in: [DocumentKindEnum!]
  _isNull: Boolean
  _neq: DocumentKindEnum
  _nin: [DocumentKindEnum!]
}

"""Ordering options when selecting data from "document_kind"."""
input DocumentKindOrderBy {
  id: OrderBy
}

"""
select columns of table "document_kind"
"""
enum DocumentKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "document_kind"
"""
input DocumentKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentKindStreamCursorValueInput {
  id: String
}

"""aggregate max on columns"""
type DocumentMaxFields {
  body: String
  createdAt: timestamptz
  id: uuid
  profileId: uuid
  slug: citext
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type DocumentMinFields {
  body: String
  createdAt: timestamptz
  id: uuid
  profileId: uuid
  slug: citext
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "document"
"""
type DocumentMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Document!]!
}

"""
input type for inserting object relation for remote table "document"
"""
input DocumentObjRelInsertInput {
  data: DocumentInsertInput!

  """upsert condition"""
  onConflict: DocumentOnConflict
}

"""
on_conflict condition type for table "document"
"""
input DocumentOnConflict {
  constraint: DocumentConstraint!
  updateColumns: [DocumentUpdateColumn!]! = []
  where: DocumentBoolExp
}

"""Ordering options when selecting data from "document"."""
input DocumentOrderBy {
  body: OrderBy
  createdAt: OrderBy
  id: OrderBy
  isDeleted: OrderBy
  kind: OrderBy
  profileId: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: document"""
input DocumentPkColumnsInput {
  id: uuid!
}

"""
select columns of table "document"
"""
enum DocumentSelectColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  slug

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt

  """column name"""
  visibility
}

"""
input type for updating data in table "document"
"""
input DocumentSetInput {
  body: String
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: DocumentKindEnum
  profileId: uuid
  slug: citext
  tenantId: String
  title: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
Streaming cursor of the table "document"
"""
input DocumentStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentStreamCursorValueInput {
  body: String
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: DocumentKindEnum
  profileId: uuid
  slug: citext
  tenantId: String
  title: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
update columns of table "document"
"""
enum DocumentUpdateColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  slug

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt

  """column name"""
  visibility
}

input DocumentUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: DocumentSetInput

  """filter the rows which have to be updated"""
  where: DocumentBoolExp!
}

"""
columns and relationships of "event"
"""
type Event {
  """An object relationship"""
  coverPhoto: MediaItem
  coverPhotoId: String
  createdAt: timestamptz!
  description: String
  endDate: date!
  endTimestamp: timestamptz

  """An object relationship"""
  eventLive: EventLive
  id: uuid!
  isDeleted: Boolean!
  kind: String!
  label: String
  link: String

  """An object relationship"""
  location: GeoLocation
  locationId: uuid
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  name: citext!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  raffleId: uuid

  """An object relationship"""
  recurrence: EventRecurrence
  recurrenceId: uuid
  slug: String
  startDate: date!
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String!

  """An array relationship"""
  ticketOptions(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!

  """An aggregate relationship"""
  ticketOptionsAggregate(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): EventTicketOptionAggregate!
  timezone: String!
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "event"
"""
type EventAggregate {
  aggregate: EventAggregateFields
  nodes: [Event!]!
}

"""
aggregate fields of "event"
"""
type EventAggregateFields {
  count(columns: [EventSelectColumn!], distinct: Boolean): Int!
  max: EventMaxFields
  min: EventMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input EventAppendInput {
  metadata: jsonb
}

"""
columns and relationships of "event_attendee"
"""
type EventAttendee {
  createdAt: timestamptz!

  """An object relationship"""
  event: Event!
  eventId: uuid!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  product: ShopProduct
  productId: uuid

  """An object relationship"""
  profile: Profile
  profileId: uuid
  status: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "event_attendee"
"""
type EventAttendeeAggregate {
  aggregate: EventAttendeeAggregateFields
  nodes: [EventAttendee!]!
}

"""
aggregate fields of "event_attendee"
"""
type EventAttendeeAggregateFields {
  count(columns: [EventAttendeeSelectColumn!], distinct: Boolean): Int!
  max: EventAttendeeMaxFields
  min: EventAttendeeMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input EventAttendeeAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "event_attendee". All fields are combined with a logical 'AND'.
"""
input EventAttendeeBoolExp {
  _and: [EventAttendeeBoolExp!]
  _not: EventAttendeeBoolExp
  _or: [EventAttendeeBoolExp!]
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: UuidComparisonExp
  id: UuidComparisonExp
  metadata: JsonbComparisonExp
  product: ShopProductBoolExp
  productId: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  status: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_attendee"
"""
enum EventAttendeeConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_attendee_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input EventAttendeeDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input EventAttendeeDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input EventAttendeeDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "event_attendee"
"""
input EventAttendeeInsertInput {
  createdAt: timestamptz
  event: EventObjRelInsertInput
  eventId: uuid
  id: uuid
  metadata: jsonb
  product: ShopProductObjRelInsertInput
  productId: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventAttendeeMaxFields {
  createdAt: timestamptz
  eventId: uuid
  id: uuid
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventAttendeeMinFields {
  createdAt: timestamptz
  eventId: uuid
  id: uuid
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_attendee"
"""
type EventAttendeeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventAttendee!]!
}

"""
on_conflict condition type for table "event_attendee"
"""
input EventAttendeeOnConflict {
  constraint: EventAttendeeConstraint!
  updateColumns: [EventAttendeeUpdateColumn!]! = []
  where: EventAttendeeBoolExp
}

"""Ordering options when selecting data from "event_attendee"."""
input EventAttendeeOrderBy {
  createdAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  id: OrderBy
  metadata: OrderBy
  product: ShopProductOrderBy
  productId: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_attendee"""
input EventAttendeePkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input EventAttendeePrependInput {
  metadata: jsonb
}

"""
select columns of table "event_attendee"
"""
enum EventAttendeeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  productId

  """column name"""
  profileId

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_attendee"
"""
input EventAttendeeSetInput {
  createdAt: timestamptz
  eventId: uuid
  id: uuid
  metadata: jsonb
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_attendee"
"""
input EventAttendeeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventAttendeeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventAttendeeStreamCursorValueInput {
  createdAt: timestamptz
  eventId: uuid
  id: uuid
  metadata: jsonb
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "event_attendee"
"""
enum EventAttendeeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  productId

  """column name"""
  profileId

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventAttendeeUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: EventAttendeeAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: EventAttendeeDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: EventAttendeeDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: EventAttendeeDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: EventAttendeePrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: EventAttendeeSetInput

  """filter the rows which have to be updated"""
  where: EventAttendeeBoolExp!
}

"""
columns and relationships of "event_availability"
"""
type EventAvailability {
  createdAt: timestamptz
  endTime: timetz!
  id: uuid!
  kind: EventAvailabilityKindEnum!
  profileId: uuid!
  startTime: timetz!
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "event_availability"
"""
type EventAvailabilityAggregate {
  aggregate: EventAvailabilityAggregateFields
  nodes: [EventAvailability!]!
}

"""
aggregate fields of "event_availability"
"""
type EventAvailabilityAggregateFields {
  count(columns: [EventAvailabilitySelectColumn!], distinct: Boolean): Int!
  max: EventAvailabilityMaxFields
  min: EventAvailabilityMinFields
}

"""
Boolean expression to filter rows from the table "event_availability". All fields are combined with a logical 'AND'.
"""
input EventAvailabilityBoolExp {
  _and: [EventAvailabilityBoolExp!]
  _not: EventAvailabilityBoolExp
  _or: [EventAvailabilityBoolExp!]
  createdAt: TimestamptzComparisonExp
  endTime: TimetzComparisonExp
  id: UuidComparisonExp
  kind: EventAvailabilityKindEnumComparisonExp
  profileId: UuidComparisonExp
  startTime: TimetzComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_availability"
"""
enum EventAvailabilityConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_availability_pkey
}

"""
input type for inserting data into table "event_availability"
"""
input EventAvailabilityInsertInput {
  createdAt: timestamptz
  endTime: timetz
  id: uuid
  kind: EventAvailabilityKindEnum
  profileId: uuid
  startTime: timetz
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "event_availability_kind"
"""
type EventAvailabilityKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "event_availability_kind". All fields are combined with a logical 'AND'.
"""
input EventAvailabilityKindBoolExp {
  _and: [EventAvailabilityKindBoolExp!]
  _not: EventAvailabilityKindBoolExp
  _or: [EventAvailabilityKindBoolExp!]
  id: StringComparisonExp
}

enum EventAvailabilityKindEnum {
  ALL_DAYS
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
  WEEKDAYS
}

"""
Boolean expression to compare columns of type "EventAvailabilityKindEnum". All fields are combined with logical 'AND'.
"""
input EventAvailabilityKindEnumComparisonExp {
  _eq: EventAvailabilityKindEnum
  _in: [EventAvailabilityKindEnum!]
  _isNull: Boolean
  _neq: EventAvailabilityKindEnum
  _nin: [EventAvailabilityKindEnum!]
}

"""Ordering options when selecting data from "event_availability_kind"."""
input EventAvailabilityKindOrderBy {
  id: OrderBy
}

"""
select columns of table "event_availability_kind"
"""
enum EventAvailabilityKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "event_availability_kind"
"""
input EventAvailabilityKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventAvailabilityKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventAvailabilityKindStreamCursorValueInput {
  id: String
}

"""aggregate max on columns"""
type EventAvailabilityMaxFields {
  createdAt: timestamptz
  endTime: timetz
  id: uuid
  profileId: uuid
  startTime: timetz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventAvailabilityMinFields {
  createdAt: timestamptz
  endTime: timetz
  id: uuid
  profileId: uuid
  startTime: timetz
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_availability"
"""
type EventAvailabilityMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventAvailability!]!
}

"""
on_conflict condition type for table "event_availability"
"""
input EventAvailabilityOnConflict {
  constraint: EventAvailabilityConstraint!
  updateColumns: [EventAvailabilityUpdateColumn!]! = []
  where: EventAvailabilityBoolExp
}

"""Ordering options when selecting data from "event_availability"."""
input EventAvailabilityOrderBy {
  createdAt: OrderBy
  endTime: OrderBy
  id: OrderBy
  kind: OrderBy
  profileId: OrderBy
  startTime: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
columns and relationships of "event_availability_override"
"""
type EventAvailabilityOverride {
  available: Boolean!
  createdAt: timestamptz
  endDate: date!
  endTime: timestamptz
  id: uuid!
  profileId: uuid!
  startDate: date!
  startTime: timestamptz
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "event_availability_override"
"""
type EventAvailabilityOverrideAggregate {
  aggregate: EventAvailabilityOverrideAggregateFields
  nodes: [EventAvailabilityOverride!]!
}

"""
aggregate fields of "event_availability_override"
"""
type EventAvailabilityOverrideAggregateFields {
  count(columns: [EventAvailabilityOverrideSelectColumn!], distinct: Boolean): Int!
  max: EventAvailabilityOverrideMaxFields
  min: EventAvailabilityOverrideMinFields
}

"""
Boolean expression to filter rows from the table "event_availability_override". All fields are combined with a logical 'AND'.
"""
input EventAvailabilityOverrideBoolExp {
  _and: [EventAvailabilityOverrideBoolExp!]
  _not: EventAvailabilityOverrideBoolExp
  _or: [EventAvailabilityOverrideBoolExp!]
  available: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  profileId: UuidComparisonExp
  startDate: DateComparisonExp
  startTime: TimestamptzComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_availability_override"
"""
enum EventAvailabilityOverrideConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_availability_override_pkey
}

"""
input type for inserting data into table "event_availability_override"
"""
input EventAvailabilityOverrideInsertInput {
  available: Boolean
  createdAt: timestamptz
  endDate: date
  endTime: timestamptz
  id: uuid
  profileId: uuid
  startDate: date
  startTime: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventAvailabilityOverrideMaxFields {
  createdAt: timestamptz
  endDate: date
  endTime: timestamptz
  id: uuid
  profileId: uuid
  startDate: date
  startTime: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventAvailabilityOverrideMinFields {
  createdAt: timestamptz
  endDate: date
  endTime: timestamptz
  id: uuid
  profileId: uuid
  startDate: date
  startTime: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_availability_override"
"""
type EventAvailabilityOverrideMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventAvailabilityOverride!]!
}

"""
on_conflict condition type for table "event_availability_override"
"""
input EventAvailabilityOverrideOnConflict {
  constraint: EventAvailabilityOverrideConstraint!
  updateColumns: [EventAvailabilityOverrideUpdateColumn!]! = []
  where: EventAvailabilityOverrideBoolExp
}

"""
Ordering options when selecting data from "event_availability_override".
"""
input EventAvailabilityOverrideOrderBy {
  available: OrderBy
  createdAt: OrderBy
  endDate: OrderBy
  endTime: OrderBy
  id: OrderBy
  profileId: OrderBy
  startDate: OrderBy
  startTime: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_availability_override"""
input EventAvailabilityOverridePkColumnsInput {
  id: uuid!
}

"""
select columns of table "event_availability_override"
"""
enum EventAvailabilityOverrideSelectColumn {
  """column name"""
  available

  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  endTime

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  startDate

  """column name"""
  startTime

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_availability_override"
"""
input EventAvailabilityOverrideSetInput {
  available: Boolean
  createdAt: timestamptz
  endDate: date
  endTime: timestamptz
  id: uuid
  profileId: uuid
  startDate: date
  startTime: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_availability_override"
"""
input EventAvailabilityOverrideStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventAvailabilityOverrideStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventAvailabilityOverrideStreamCursorValueInput {
  available: Boolean
  createdAt: timestamptz
  endDate: date
  endTime: timestamptz
  id: uuid
  profileId: uuid
  startDate: date
  startTime: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "event_availability_override"
"""
enum EventAvailabilityOverrideUpdateColumn {
  """column name"""
  available

  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  endTime

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  startDate

  """column name"""
  startTime

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventAvailabilityOverrideUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: EventAvailabilityOverrideSetInput

  """filter the rows which have to be updated"""
  where: EventAvailabilityOverrideBoolExp!
}

"""primary key columns input for table: event_availability"""
input EventAvailabilityPkColumnsInput {
  id: uuid!
}

"""
select columns of table "event_availability"
"""
enum EventAvailabilitySelectColumn {
  """column name"""
  createdAt

  """column name"""
  endTime

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  startTime

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_availability"
"""
input EventAvailabilitySetInput {
  createdAt: timestamptz
  endTime: timetz
  id: uuid
  kind: EventAvailabilityKindEnum
  profileId: uuid
  startTime: timetz
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_availability"
"""
input EventAvailabilityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventAvailabilityStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventAvailabilityStreamCursorValueInput {
  createdAt: timestamptz
  endTime: timetz
  id: uuid
  kind: EventAvailabilityKindEnum
  profileId: uuid
  startTime: timetz
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "event_availability"
"""
enum EventAvailabilityUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  endTime

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  startTime

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventAvailabilityUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: EventAvailabilitySetInput

  """filter the rows which have to be updated"""
  where: EventAvailabilityBoolExp!
}

"""
Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
"""
input EventBoolExp {
  _and: [EventBoolExp!]
  _not: EventBoolExp
  _or: [EventBoolExp!]
  coverPhoto: MediaItemBoolExp
  coverPhotoId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  endDate: DateComparisonExp
  endTimestamp: TimestamptzComparisonExp
  eventLive: EventLiveBoolExp
  id: UuidComparisonExp
  isDeleted: BooleanComparisonExp
  kind: StringComparisonExp
  label: StringComparisonExp
  link: StringComparisonExp
  location: GeoLocationBoolExp
  locationId: UuidComparisonExp
  metadata: JsonbComparisonExp
  name: CitextComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  raffleId: UuidComparisonExp
  recurrence: EventRecurrenceBoolExp
  recurrenceId: UuidComparisonExp
  slug: StringComparisonExp
  startDate: DateComparisonExp
  startTimestamp: TimestamptzComparisonExp
  templateId: UuidComparisonExp
  tenantId: StringComparisonExp
  ticketOptions: EventTicketOptionBoolExp
  ticketOptionsAggregate: EventTicketOptionAggregateBoolExp
  timezone: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "event"
"""
enum EventConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_pkey

  """
  unique or primary key constraint on columns "slug", "tenant_id"
  """
  event_slug_tenant_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input EventDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input EventDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input EventDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "event"
"""
input EventInsertInput {
  coverPhoto: MediaItemObjRelInsertInput
  coverPhotoId: String
  createdAt: timestamptz
  description: String
  endDate: date
  endTimestamp: timestamptz
  eventLive: EventLiveObjRelInsertInput
  id: uuid
  isDeleted: Boolean
  kind: String
  label: String
  link: String
  location: GeoLocationObjRelInsertInput
  locationId: uuid
  metadata: jsonb
  name: citext
  profile: ProfileObjRelInsertInput
  profileId: uuid
  raffleId: uuid
  recurrence: EventRecurrenceObjRelInsertInput
  recurrenceId: uuid
  slug: String
  startDate: date
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String
  ticketOptions: EventTicketOptionArrRelInsertInput
  timezone: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "event_kind"
"""
type EventKind {
  createdAt: timestamptz
  id: String!
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "event_kind"
"""
type EventKindAggregate {
  aggregate: EventKindAggregateFields
  nodes: [EventKind!]!
}

"""
aggregate fields of "event_kind"
"""
type EventKindAggregateFields {
  count(columns: [EventKindSelectColumn!], distinct: Boolean): Int!
  max: EventKindMaxFields
  min: EventKindMinFields
}

"""
Boolean expression to filter rows from the table "event_kind". All fields are combined with a logical 'AND'.
"""
input EventKindBoolExp {
  _and: [EventKindBoolExp!]
  _not: EventKindBoolExp
  _or: [EventKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_kind"
"""
enum EventKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  event_kind_pkey
}

"""
input type for inserting data into table "event_kind"
"""
input EventKindInsertInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventKindMaxFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventKindMinFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_kind"
"""
type EventKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventKind!]!
}

"""
on_conflict condition type for table "event_kind"
"""
input EventKindOnConflict {
  constraint: EventKindConstraint!
  updateColumns: [EventKindUpdateColumn!]! = []
  where: EventKindBoolExp
}

"""Ordering options when selecting data from "event_kind"."""
input EventKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_kind"""
input EventKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "event_kind"
"""
enum EventKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_kind"
"""
input EventKindSetInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_kind"
"""
input EventKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventKindStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "event_kind"
"""
enum EventKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: EventKindSetInput

  """filter the rows which have to be updated"""
  where: EventKindBoolExp!
}

"""
columns and relationships of "event_live"
"""
type EventLive {
  cleanupReady: Boolean
  createdAt: timestamptz

  """An object relationship"""
  event: Event!
  eventId: uuid!
  id: String!
  isLive: Boolean
  isPaused: Boolean

  """Gets the response counts for the currently active question_set"""
  liveResponseCounts(
    """JSON select path"""
    path: String
  ): jsonb
  nextTimer: timestamptz

  """An object relationship"""
  profile: Profile!
  profileId: uuid!

  """An object relationship"""
  question: Question
  questionId: uuid

  """An object relationship"""
  questionSet: QuestionSet
  questionSetId: uuid

  """An object relationship"""
  raffle: GameRaffle
  raffleId: uuid

  """An array relationship"""
  raffleTickets(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): [GameRaffleTicket!]!

  """An aggregate relationship"""
  raffleTicketsAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): GameRaffleTicketAggregate!

  """
  A computed field, executes function "current_time"
  """
  serverTime: timestamptz
  showAfterQuestionDetails: Boolean!
  startTimestamp: timestamptz

  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "event_live"
"""
type EventLiveAggregate {
  aggregate: EventLiveAggregateFields
  nodes: [EventLive!]!
}

"""
aggregate fields of "event_live"
"""
type EventLiveAggregateFields {
  count(columns: [EventLiveSelectColumn!], distinct: Boolean): Int!
  max: EventLiveMaxFields
  min: EventLiveMinFields
}

"""
Boolean expression to filter rows from the table "event_live". All fields are combined with a logical 'AND'.
"""
input EventLiveBoolExp {
  _and: [EventLiveBoolExp!]
  _not: EventLiveBoolExp
  _or: [EventLiveBoolExp!]
  cleanupReady: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: UuidComparisonExp
  id: StringComparisonExp
  isLive: BooleanComparisonExp
  isPaused: BooleanComparisonExp
  liveResponseCounts: JsonbComparisonExp
  nextTimer: TimestamptzComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  question: QuestionBoolExp
  questionId: UuidComparisonExp
  questionSet: QuestionSetBoolExp
  questionSetId: UuidComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  raffleTickets: GameRaffleTicketBoolExp
  raffleTicketsAggregate: GameRaffleTicketAggregateBoolExp
  serverTime: TimestamptzComparisonExp
  showAfterQuestionDetails: BooleanComparisonExp
  startTimestamp: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_live"
"""
enum EventLiveConstraint {
  """
  unique or primary key constraint on columns "event_id"
  """
  event_live_event_id_key

  """
  unique or primary key constraint on columns "id"
  """
  event_live_pkey
}

"""
input type for inserting data into table "event_live"
"""
input EventLiveInsertInput {
  cleanupReady: Boolean
  createdAt: timestamptz
  event: EventObjRelInsertInput
  eventId: uuid
  id: String
  isLive: Boolean
  isPaused: Boolean
  nextTimer: timestamptz
  profile: ProfileObjRelInsertInput
  profileId: uuid
  question: QuestionObjRelInsertInput
  questionId: uuid
  questionSet: QuestionSetObjRelInsertInput
  questionSetId: uuid
  raffle: GameRaffleObjRelInsertInput
  raffleId: uuid
  raffleTickets: GameRaffleTicketArrRelInsertInput
  showAfterQuestionDetails: Boolean
  startTimestamp: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventLiveMaxFields {
  createdAt: timestamptz
  eventId: uuid
  id: String
  nextTimer: timestamptz
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  raffleId: uuid

  """
  A computed field, executes function "current_time"
  """
  serverTime: timestamptz
  startTimestamp: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventLiveMinFields {
  createdAt: timestamptz
  eventId: uuid
  id: String
  nextTimer: timestamptz
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  raffleId: uuid

  """
  A computed field, executes function "current_time"
  """
  serverTime: timestamptz
  startTimestamp: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_live"
"""
type EventLiveMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventLive!]!
}

"""
input type for inserting object relation for remote table "event_live"
"""
input EventLiveObjRelInsertInput {
  data: EventLiveInsertInput!

  """upsert condition"""
  onConflict: EventLiveOnConflict
}

"""
on_conflict condition type for table "event_live"
"""
input EventLiveOnConflict {
  constraint: EventLiveConstraint!
  updateColumns: [EventLiveUpdateColumn!]! = []
  where: EventLiveBoolExp
}

"""Ordering options when selecting data from "event_live"."""
input EventLiveOrderBy {
  cleanupReady: OrderBy
  createdAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  id: OrderBy
  isLive: OrderBy
  isPaused: OrderBy
  liveResponseCounts: OrderBy
  nextTimer: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  question: QuestionOrderBy
  questionId: OrderBy
  questionSet: QuestionSetOrderBy
  questionSetId: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  raffleTicketsAggregate: GameRaffleTicketAggregateOrderBy
  serverTime: OrderBy
  showAfterQuestionDetails: OrderBy
  startTimestamp: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_live"""
input EventLivePkColumnsInput {
  id: String!
}

"""
select columns of table "event_live"
"""
enum EventLiveSelectColumn {
  """column name"""
  cleanupReady

  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  isLive

  """column name"""
  isPaused

  """column name"""
  nextTimer

  """column name"""
  profileId

  """column name"""
  questionId

  """column name"""
  questionSetId

  """column name"""
  raffleId

  """column name"""
  showAfterQuestionDetails

  """column name"""
  startTimestamp

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_live"
"""
input EventLiveSetInput {
  cleanupReady: Boolean
  createdAt: timestamptz
  eventId: uuid
  id: String
  isLive: Boolean
  isPaused: Boolean
  nextTimer: timestamptz
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  raffleId: uuid
  showAfterQuestionDetails: Boolean
  startTimestamp: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_live"
"""
input EventLiveStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventLiveStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventLiveStreamCursorValueInput {
  cleanupReady: Boolean
  createdAt: timestamptz
  eventId: uuid
  id: String
  isLive: Boolean
  isPaused: Boolean
  nextTimer: timestamptz
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  raffleId: uuid
  showAfterQuestionDetails: Boolean
  startTimestamp: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "event_live"
"""
enum EventLiveUpdateColumn {
  """column name"""
  cleanupReady

  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  id

  """column name"""
  isLive

  """column name"""
  isPaused

  """column name"""
  nextTimer

  """column name"""
  profileId

  """column name"""
  questionId

  """column name"""
  questionSetId

  """column name"""
  raffleId

  """column name"""
  showAfterQuestionDetails

  """column name"""
  startTimestamp

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventLiveUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: EventLiveSetInput

  """filter the rows which have to be updated"""
  where: EventLiveBoolExp!
}

"""aggregate max on columns"""
type EventMaxFields {
  coverPhotoId: String
  createdAt: timestamptz
  description: String
  endDate: date
  endTimestamp: timestamptz
  id: uuid
  kind: String
  label: String
  link: String
  locationId: uuid
  name: citext
  profileId: uuid
  raffleId: uuid
  recurrenceId: uuid
  slug: String
  startDate: date
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventMinFields {
  coverPhotoId: String
  createdAt: timestamptz
  description: String
  endDate: date
  endTimestamp: timestamptz
  id: uuid
  kind: String
  label: String
  link: String
  locationId: uuid
  name: citext
  profileId: uuid
  raffleId: uuid
  recurrenceId: uuid
  slug: String
  startDate: date
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event"
"""
type EventMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Event!]!
}

"""
input type for inserting object relation for remote table "event"
"""
input EventObjRelInsertInput {
  data: EventInsertInput!

  """upsert condition"""
  onConflict: EventOnConflict
}

"""
on_conflict condition type for table "event"
"""
input EventOnConflict {
  constraint: EventConstraint!
  updateColumns: [EventUpdateColumn!]! = []
  where: EventBoolExp
}

"""Ordering options when selecting data from "event"."""
input EventOrderBy {
  coverPhoto: MediaItemOrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  description: OrderBy
  endDate: OrderBy
  endTimestamp: OrderBy
  eventLive: EventLiveOrderBy
  id: OrderBy
  isDeleted: OrderBy
  kind: OrderBy
  label: OrderBy
  link: OrderBy
  location: GeoLocationOrderBy
  locationId: OrderBy
  metadata: OrderBy
  name: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  raffleId: OrderBy
  recurrence: EventRecurrenceOrderBy
  recurrenceId: OrderBy
  slug: OrderBy
  startDate: OrderBy
  startTimestamp: OrderBy
  templateId: OrderBy
  tenantId: OrderBy
  ticketOptionsAggregate: EventTicketOptionAggregateOrderBy
  timezone: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: event"""
input EventPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input EventPrependInput {
  metadata: jsonb
}

"""
columns and relationships of "event_recurrence"
"""
type EventRecurrence {
  createdAt: timestamptz!
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz

  """An object relationship"""
  event: Event
  id: uuid!
  kind: EventRecurrenceKindEnum!
  month: Int
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "event_recurrence"
"""
type EventRecurrenceAggregate {
  aggregate: EventRecurrenceAggregateFields
  nodes: [EventRecurrence!]!
}

"""
aggregate fields of "event_recurrence"
"""
type EventRecurrenceAggregateFields {
  avg: EventRecurrenceAvgFields
  count(columns: [EventRecurrenceSelectColumn!], distinct: Boolean): Int!
  max: EventRecurrenceMaxFields
  min: EventRecurrenceMinFields
  stddev: EventRecurrenceStddevFields
  stddevPop: EventRecurrenceStddevPopFields
  stddevSamp: EventRecurrenceStddevSampFields
  sum: EventRecurrenceSumFields
  varPop: EventRecurrenceVarPopFields
  varSamp: EventRecurrenceVarSampFields
  variance: EventRecurrenceVarianceFields
}

"""aggregate avg on columns"""
type EventRecurrenceAvgFields {
  dayOfMonth: Float
  month: Float
}

"""
Boolean expression to filter rows from the table "event_recurrence". All fields are combined with a logical 'AND'.
"""
input EventRecurrenceBoolExp {
  _and: [EventRecurrenceBoolExp!]
  _not: EventRecurrenceBoolExp
  _or: [EventRecurrenceBoolExp!]
  createdAt: TimestamptzComparisonExp
  dayOfMonth: IntComparisonExp
  daysOfWeek: StringArrayComparisonExp
  endsAt: TimestamptzComparisonExp
  event: EventBoolExp
  id: UuidComparisonExp
  kind: EventRecurrenceKindEnumComparisonExp
  month: IntComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_recurrence"
"""
enum EventRecurrenceConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_recurrance_pkey
}

"""
input type for incrementing numeric columns in table "event_recurrence"
"""
input EventRecurrenceIncInput {
  dayOfMonth: Int
  month: Int
}

"""
input type for inserting data into table "event_recurrence"
"""
input EventRecurrenceInsertInput {
  createdAt: timestamptz
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  event: EventObjRelInsertInput
  id: uuid
  kind: EventRecurrenceKindEnum
  month: Int
  tenantId: String
  updatedAt: timestamptz
}

enum EventRecurrenceKindEnum {
  DAILY
  MONTHLY
  WEEKLY
  YEARLY
}

"""
Boolean expression to compare columns of type "EventRecurrenceKindEnum". All fields are combined with logical 'AND'.
"""
input EventRecurrenceKindEnumComparisonExp {
  _eq: EventRecurrenceKindEnum
  _in: [EventRecurrenceKindEnum!]
  _isNull: Boolean
  _neq: EventRecurrenceKindEnum
  _nin: [EventRecurrenceKindEnum!]
}

"""aggregate max on columns"""
type EventRecurrenceMaxFields {
  createdAt: timestamptz
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  id: uuid
  month: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventRecurrenceMinFields {
  createdAt: timestamptz
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  id: uuid
  month: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_recurrence"
"""
type EventRecurrenceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventRecurrence!]!
}

"""
input type for inserting object relation for remote table "event_recurrence"
"""
input EventRecurrenceObjRelInsertInput {
  data: EventRecurrenceInsertInput!

  """upsert condition"""
  onConflict: EventRecurrenceOnConflict
}

"""
on_conflict condition type for table "event_recurrence"
"""
input EventRecurrenceOnConflict {
  constraint: EventRecurrenceConstraint!
  updateColumns: [EventRecurrenceUpdateColumn!]! = []
  where: EventRecurrenceBoolExp
}

"""Ordering options when selecting data from "event_recurrence"."""
input EventRecurrenceOrderBy {
  createdAt: OrderBy
  dayOfMonth: OrderBy
  daysOfWeek: OrderBy
  endsAt: OrderBy
  event: EventOrderBy
  id: OrderBy
  kind: OrderBy
  month: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_recurrence"""
input EventRecurrencePkColumnsInput {
  id: uuid!
}

"""
select columns of table "event_recurrence"
"""
enum EventRecurrenceSelectColumn {
  """column name"""
  createdAt

  """column name"""
  dayOfMonth

  """column name"""
  daysOfWeek

  """column name"""
  endsAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  month

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_recurrence"
"""
input EventRecurrenceSetInput {
  createdAt: timestamptz
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  id: uuid
  kind: EventRecurrenceKindEnum
  month: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type EventRecurrenceStddevFields {
  dayOfMonth: Float
  month: Float
}

"""aggregate stddevPop on columns"""
type EventRecurrenceStddevPopFields {
  dayOfMonth: Float
  month: Float
}

"""aggregate stddevSamp on columns"""
type EventRecurrenceStddevSampFields {
  dayOfMonth: Float
  month: Float
}

"""
Streaming cursor of the table "event_recurrence"
"""
input EventRecurrenceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventRecurrenceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventRecurrenceStreamCursorValueInput {
  createdAt: timestamptz
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  id: uuid
  kind: EventRecurrenceKindEnum
  month: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type EventRecurrenceSumFields {
  dayOfMonth: Int
  month: Int
}

"""
update columns of table "event_recurrence"
"""
enum EventRecurrenceUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  dayOfMonth

  """column name"""
  daysOfWeek

  """column name"""
  endsAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  month

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventRecurrenceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: EventRecurrenceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: EventRecurrenceSetInput

  """filter the rows which have to be updated"""
  where: EventRecurrenceBoolExp!
}

"""aggregate varPop on columns"""
type EventRecurrenceVarPopFields {
  dayOfMonth: Float
  month: Float
}

"""aggregate varSamp on columns"""
type EventRecurrenceVarSampFields {
  dayOfMonth: Float
  month: Float
}

"""aggregate variance on columns"""
type EventRecurrenceVarianceFields {
  dayOfMonth: Float
  month: Float
}

"""
select columns of table "event"
"""
enum EventSelectColumn {
  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  endDate

  """column name"""
  endTimestamp

  """column name"""
  id

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  label

  """column name"""
  link

  """column name"""
  locationId

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  raffleId

  """column name"""
  recurrenceId

  """column name"""
  slug

  """column name"""
  startDate

  """column name"""
  startTimestamp

  """column name"""
  templateId

  """column name"""
  tenantId

  """column name"""
  timezone

  """column name"""
  updatedAt

  """column name"""
  visibility
}

"""
input type for updating data in table "event"
"""
input EventSetInput {
  coverPhotoId: String
  createdAt: timestamptz
  description: String
  endDate: date
  endTimestamp: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: String
  label: String
  link: String
  locationId: uuid
  metadata: jsonb
  name: citext
  profileId: uuid
  raffleId: uuid
  recurrenceId: uuid
  slug: String
  startDate: date
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String
  timezone: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
Streaming cursor of the table "event"
"""
input EventStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventStreamCursorValueInput {
  coverPhotoId: String
  createdAt: timestamptz
  description: String
  endDate: date
  endTimestamp: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: String
  label: String
  link: String
  locationId: uuid
  metadata: jsonb
  name: citext
  profileId: uuid
  raffleId: uuid
  recurrenceId: uuid
  slug: String
  startDate: date
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String
  timezone: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "event_template"
"""
type EventTemplate {
  createdAt: timestamptz
  id: uuid!
  kind: String!
  name: String!
  profileId: uuid!
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "event_template"
"""
type EventTemplateAggregate {
  aggregate: EventTemplateAggregateFields
  nodes: [EventTemplate!]!
}

"""
aggregate fields of "event_template"
"""
type EventTemplateAggregateFields {
  count(columns: [EventTemplateSelectColumn!], distinct: Boolean): Int!
  max: EventTemplateMaxFields
  min: EventTemplateMinFields
}

"""
Boolean expression to filter rows from the table "event_template". All fields are combined with a logical 'AND'.
"""
input EventTemplateBoolExp {
  _and: [EventTemplateBoolExp!]
  _not: EventTemplateBoolExp
  _or: [EventTemplateBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  kind: StringComparisonExp
  name: StringComparisonExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_template"
"""
enum EventTemplateConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  event_template_pkey
}

"""
input type for inserting data into table "event_template"
"""
input EventTemplateInsertInput {
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventTemplateMaxFields {
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventTemplateMinFields {
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_template"
"""
type EventTemplateMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventTemplate!]!
}

"""
on_conflict condition type for table "event_template"
"""
input EventTemplateOnConflict {
  constraint: EventTemplateConstraint!
  updateColumns: [EventTemplateUpdateColumn!]! = []
  where: EventTemplateBoolExp
}

"""Ordering options when selecting data from "event_template"."""
input EventTemplateOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  name: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_template"""
input EventTemplatePkColumnsInput {
  id: uuid!
}

"""
select columns of table "event_template"
"""
enum EventTemplateSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_template"
"""
input EventTemplateSetInput {
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_template"
"""
input EventTemplateStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventTemplateStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventTemplateStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  kind: String
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "event_template_tag"
"""
type EventTemplateTag {
  createdAt: timestamptz!
  eventTemplateId: uuid!
  tag: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "event_template_tag"
"""
type EventTemplateTagAggregate {
  aggregate: EventTemplateTagAggregateFields
  nodes: [EventTemplateTag!]!
}

"""
aggregate fields of "event_template_tag"
"""
type EventTemplateTagAggregateFields {
  count(columns: [EventTemplateTagSelectColumn!], distinct: Boolean): Int!
  max: EventTemplateTagMaxFields
  min: EventTemplateTagMinFields
}

"""
Boolean expression to filter rows from the table "event_template_tag". All fields are combined with a logical 'AND'.
"""
input EventTemplateTagBoolExp {
  _and: [EventTemplateTagBoolExp!]
  _not: EventTemplateTagBoolExp
  _or: [EventTemplateTagBoolExp!]
  createdAt: TimestamptzComparisonExp
  eventTemplateId: UuidComparisonExp
  tag: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_template_tag"
"""
enum EventTemplateTagConstraint {
  """
  unique or primary key constraint on columns "tag", "event_template_id"
  """
  event_template_tag_pkey
}

"""
input type for inserting data into table "event_template_tag"
"""
input EventTemplateTagInsertInput {
  createdAt: timestamptz
  eventTemplateId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventTemplateTagMaxFields {
  createdAt: timestamptz
  eventTemplateId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type EventTemplateTagMinFields {
  createdAt: timestamptz
  eventTemplateId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "event_template_tag"
"""
type EventTemplateTagMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventTemplateTag!]!
}

"""
on_conflict condition type for table "event_template_tag"
"""
input EventTemplateTagOnConflict {
  constraint: EventTemplateTagConstraint!
  updateColumns: [EventTemplateTagUpdateColumn!]! = []
  where: EventTemplateTagBoolExp
}

"""Ordering options when selecting data from "event_template_tag"."""
input EventTemplateTagOrderBy {
  createdAt: OrderBy
  eventTemplateId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_template_tag"""
input EventTemplateTagPkColumnsInput {
  eventTemplateId: uuid!
  tag: String!
}

"""
select columns of table "event_template_tag"
"""
enum EventTemplateTagSelectColumn {
  """column name"""
  createdAt

  """column name"""
  eventTemplateId

  """column name"""
  tag

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_template_tag"
"""
input EventTemplateTagSetInput {
  createdAt: timestamptz
  eventTemplateId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "event_template_tag"
"""
input EventTemplateTagStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventTemplateTagStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventTemplateTagStreamCursorValueInput {
  createdAt: timestamptz
  eventTemplateId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "event_template_tag"
"""
enum EventTemplateTagUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  eventTemplateId

  """column name"""
  tag

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventTemplateTagUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: EventTemplateTagSetInput

  """filter the rows which have to be updated"""
  where: EventTemplateTagBoolExp!
}

"""
update columns of table "event_template"
"""
enum EventTemplateUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventTemplateUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: EventTemplateSetInput

  """filter the rows which have to be updated"""
  where: EventTemplateBoolExp!
}

"""
columns and relationships of "event_ticket_option"
"""
type EventTicketOption {
  createdAt: timestamptz!

  """An object relationship"""
  event: Event!
  eventId: uuid!
  order: Int

  """An object relationship"""
  product: ShopProduct!
  productId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "event_ticket_option"
"""
type EventTicketOptionAggregate {
  aggregate: EventTicketOptionAggregateFields
  nodes: [EventTicketOption!]!
}

input EventTicketOptionAggregateBoolExp {
  count: eventTicketOptionAggregateBoolExpCount
}

"""
aggregate fields of "event_ticket_option"
"""
type EventTicketOptionAggregateFields {
  avg: EventTicketOptionAvgFields
  count(columns: [EventTicketOptionSelectColumn!], distinct: Boolean): Int!
  max: EventTicketOptionMaxFields
  min: EventTicketOptionMinFields
  stddev: EventTicketOptionStddevFields
  stddevPop: EventTicketOptionStddevPopFields
  stddevSamp: EventTicketOptionStddevSampFields
  sum: EventTicketOptionSumFields
  varPop: EventTicketOptionVarPopFields
  varSamp: EventTicketOptionVarSampFields
  variance: EventTicketOptionVarianceFields
}

"""
order by aggregate values of table "event_ticket_option"
"""
input EventTicketOptionAggregateOrderBy {
  avg: EventTicketOptionAvgOrderBy
  count: OrderBy
  max: EventTicketOptionMaxOrderBy
  min: EventTicketOptionMinOrderBy
  stddev: EventTicketOptionStddevOrderBy
  stddevPop: EventTicketOptionStddevPopOrderBy
  stddevSamp: EventTicketOptionStddevSampOrderBy
  sum: EventTicketOptionSumOrderBy
  varPop: EventTicketOptionVarPopOrderBy
  varSamp: EventTicketOptionVarSampOrderBy
  variance: EventTicketOptionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "event_ticket_option"
"""
input EventTicketOptionArrRelInsertInput {
  data: [EventTicketOptionInsertInput!]!

  """upsert condition"""
  onConflict: EventTicketOptionOnConflict
}

"""aggregate avg on columns"""
type EventTicketOptionAvgFields {
  order: Float
}

"""
order by avg() on columns of table "event_ticket_option"
"""
input EventTicketOptionAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "event_ticket_option". All fields are combined with a logical 'AND'.
"""
input EventTicketOptionBoolExp {
  _and: [EventTicketOptionBoolExp!]
  _not: EventTicketOptionBoolExp
  _or: [EventTicketOptionBoolExp!]
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: UuidComparisonExp
  order: IntComparisonExp
  product: ShopProductBoolExp
  productId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "event_ticket_option"
"""
enum EventTicketOptionConstraint {
  """
  unique or primary key constraint on columns "product_id", "event_id", "tenant_id"
  """
  event_ticket_option_pkey
}

"""
input type for incrementing numeric columns in table "event_ticket_option"
"""
input EventTicketOptionIncInput {
  order: Int
}

"""
input type for inserting data into table "event_ticket_option"
"""
input EventTicketOptionInsertInput {
  createdAt: timestamptz
  event: EventObjRelInsertInput
  eventId: uuid
  order: Int
  product: ShopProductObjRelInsertInput
  productId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type EventTicketOptionMaxFields {
  createdAt: timestamptz
  eventId: uuid
  order: Int
  productId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "event_ticket_option"
"""
input EventTicketOptionMaxOrderBy {
  createdAt: OrderBy
  eventId: OrderBy
  order: OrderBy
  productId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type EventTicketOptionMinFields {
  createdAt: timestamptz
  eventId: uuid
  order: Int
  productId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "event_ticket_option"
"""
input EventTicketOptionMinOrderBy {
  createdAt: OrderBy
  eventId: OrderBy
  order: OrderBy
  productId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "event_ticket_option"
"""
type EventTicketOptionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [EventTicketOption!]!
}

"""
on_conflict condition type for table "event_ticket_option"
"""
input EventTicketOptionOnConflict {
  constraint: EventTicketOptionConstraint!
  updateColumns: [EventTicketOptionUpdateColumn!]! = []
  where: EventTicketOptionBoolExp
}

"""Ordering options when selecting data from "event_ticket_option"."""
input EventTicketOptionOrderBy {
  createdAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  order: OrderBy
  product: ShopProductOrderBy
  productId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: event_ticket_option"""
input EventTicketOptionPkColumnsInput {
  eventId: uuid!
  productId: uuid!
  tenantId: String!
}

"""
select columns of table "event_ticket_option"
"""
enum EventTicketOptionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  order

  """column name"""
  productId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "event_ticket_option"
"""
input EventTicketOptionSetInput {
  createdAt: timestamptz
  eventId: uuid
  order: Int
  productId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type EventTicketOptionStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "event_ticket_option"
"""
input EventTicketOptionStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type EventTicketOptionStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "event_ticket_option"
"""
input EventTicketOptionStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type EventTicketOptionStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "event_ticket_option"
"""
input EventTicketOptionStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "event_ticket_option"
"""
input EventTicketOptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventTicketOptionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventTicketOptionStreamCursorValueInput {
  createdAt: timestamptz
  eventId: uuid
  order: Int
  productId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type EventTicketOptionSumFields {
  order: Int
}

"""
order by sum() on columns of table "event_ticket_option"
"""
input EventTicketOptionSumOrderBy {
  order: OrderBy
}

"""
update columns of table "event_ticket_option"
"""
enum EventTicketOptionUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  order

  """column name"""
  productId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input EventTicketOptionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: EventTicketOptionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: EventTicketOptionSetInput

  """filter the rows which have to be updated"""
  where: EventTicketOptionBoolExp!
}

"""aggregate varPop on columns"""
type EventTicketOptionVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "event_ticket_option"
"""
input EventTicketOptionVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type EventTicketOptionVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "event_ticket_option"
"""
input EventTicketOptionVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type EventTicketOptionVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "event_ticket_option"
"""
input EventTicketOptionVarianceOrderBy {
  order: OrderBy
}

"""
update columns of table "event"
"""
enum EventUpdateColumn {
  """column name"""
  coverPhotoId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  endDate

  """column name"""
  endTimestamp

  """column name"""
  id

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  label

  """column name"""
  link

  """column name"""
  locationId

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  raffleId

  """column name"""
  recurrenceId

  """column name"""
  slug

  """column name"""
  startDate

  """column name"""
  startTimestamp

  """column name"""
  templateId

  """column name"""
  tenantId

  """column name"""
  timezone

  """column name"""
  updatedAt

  """column name"""
  visibility
}

input EventUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: EventAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: EventDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: EventDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: EventDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: EventPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: EventSetInput

  """filter the rows which have to be updated"""
  where: EventBoolExp!
}

input FeedbackInput {
  email: String!
  feedback: String!
  name: String!
  navigationStateJSON: String
  profileId: String
  sourceScreen: String
  tenantId: String!
}

type FeedbackOutput {
  success: Boolean!
}

"""
columns and relationships of "game_raffle"
"""
type GameRaffle {
  createdAt: timestamptz
  description: String
  id: uuid!
  name: String!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  prompt: String
  promptDescription: String

  """An array relationship"""
  rafflePrizes(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!

  """An aggregate relationship"""
  rafflePrizesAggregate(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): GameRafflePrizeAggregate!

  """An array relationship"""
  raffleTicketOptions(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!

  """An aggregate relationship"""
  raffleTicketOptionsAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): GameRaffleTicketOptionAggregate!

  """An array relationship"""
  raffleTickets(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): [GameRaffleTicket!]!

  """An aggregate relationship"""
  raffleTicketsAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): GameRaffleTicketAggregate!
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "game_raffle"
"""
type GameRaffleAggregate {
  aggregate: GameRaffleAggregateFields
  nodes: [GameRaffle!]!
}

"""
aggregate fields of "game_raffle"
"""
type GameRaffleAggregateFields {
  count(columns: [GameRaffleSelectColumn!], distinct: Boolean): Int!
  max: GameRaffleMaxFields
  min: GameRaffleMinFields
}

"""
Boolean expression to filter rows from the table "game_raffle". All fields are combined with a logical 'AND'.
"""
input GameRaffleBoolExp {
  _and: [GameRaffleBoolExp!]
  _not: GameRaffleBoolExp
  _or: [GameRaffleBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  prompt: StringComparisonExp
  promptDescription: StringComparisonExp
  rafflePrizes: GameRafflePrizeBoolExp
  rafflePrizesAggregate: GameRafflePrizeAggregateBoolExp
  raffleTicketOptions: GameRaffleTicketOptionBoolExp
  raffleTicketOptionsAggregate: GameRaffleTicketOptionAggregateBoolExp
  raffleTickets: GameRaffleTicketBoolExp
  raffleTicketsAggregate: GameRaffleTicketAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "game_raffle"
"""
enum GameRaffleConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  game_raffle_pkey
}

"""
input type for inserting data into table "game_raffle"
"""
input GameRaffleInsertInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  profile: ProfileObjRelInsertInput
  profileId: uuid
  prompt: String
  promptDescription: String
  rafflePrizes: GameRafflePrizeArrRelInsertInput
  raffleTicketOptions: GameRaffleTicketOptionArrRelInsertInput
  raffleTickets: GameRaffleTicketArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""aggregate max on columns"""
type GameRaffleMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  profileId: uuid
  prompt: String
  promptDescription: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type GameRaffleMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  profileId: uuid
  prompt: String
  promptDescription: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "game_raffle"
"""
type GameRaffleMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [GameRaffle!]!
}

"""
input type for inserting object relation for remote table "game_raffle"
"""
input GameRaffleObjRelInsertInput {
  data: GameRaffleInsertInput!

  """upsert condition"""
  onConflict: GameRaffleOnConflict
}

"""
on_conflict condition type for table "game_raffle"
"""
input GameRaffleOnConflict {
  constraint: GameRaffleConstraint!
  updateColumns: [GameRaffleUpdateColumn!]! = []
  where: GameRaffleBoolExp
}

"""Ordering options when selecting data from "game_raffle"."""
input GameRaffleOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  prompt: OrderBy
  promptDescription: OrderBy
  rafflePrizesAggregate: GameRafflePrizeAggregateOrderBy
  raffleTicketOptionsAggregate: GameRaffleTicketOptionAggregateOrderBy
  raffleTicketsAggregate: GameRaffleTicketAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: game_raffle"""
input GameRafflePkColumnsInput {
  id: uuid!
}

"""
columns and relationships of "game_raffle_prize"
"""
type GameRafflePrize {
  createdAt: timestamptz
  description: String
  id: uuid!
  name: String!

  """An object relationship"""
  raffle: GameRaffle!
  raffleId: uuid!

  """An array relationship"""
  raffleTickets(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): [GameRaffleTicket!]!

  """An aggregate relationship"""
  raffleTicketsAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): GameRaffleTicketAggregate!
  tenantId: String
  updatedAt: timestamptz
}

"""
aggregated selection of "game_raffle_prize"
"""
type GameRafflePrizeAggregate {
  aggregate: GameRafflePrizeAggregateFields
  nodes: [GameRafflePrize!]!
}

input GameRafflePrizeAggregateBoolExp {
  count: gameRafflePrizeAggregateBoolExpCount
}

"""
aggregate fields of "game_raffle_prize"
"""
type GameRafflePrizeAggregateFields {
  count(columns: [GameRafflePrizeSelectColumn!], distinct: Boolean): Int!
  max: GameRafflePrizeMaxFields
  min: GameRafflePrizeMinFields
}

"""
order by aggregate values of table "game_raffle_prize"
"""
input GameRafflePrizeAggregateOrderBy {
  count: OrderBy
  max: GameRafflePrizeMaxOrderBy
  min: GameRafflePrizeMinOrderBy
}

"""
input type for inserting array relation for remote table "game_raffle_prize"
"""
input GameRafflePrizeArrRelInsertInput {
  data: [GameRafflePrizeInsertInput!]!

  """upsert condition"""
  onConflict: GameRafflePrizeOnConflict
}

"""
Boolean expression to filter rows from the table "game_raffle_prize". All fields are combined with a logical 'AND'.
"""
input GameRafflePrizeBoolExp {
  _and: [GameRafflePrizeBoolExp!]
  _not: GameRafflePrizeBoolExp
  _or: [GameRafflePrizeBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  raffleTickets: GameRaffleTicketBoolExp
  raffleTicketsAggregate: GameRaffleTicketAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "game_raffle_prize"
"""
enum GameRafflePrizeConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  game_raffle_prize_pkey
}

"""
input type for inserting data into table "game_raffle_prize"
"""
input GameRafflePrizeInsertInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffle: GameRaffleObjRelInsertInput
  raffleId: uuid
  raffleTickets: GameRaffleTicketArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type GameRafflePrizeMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "game_raffle_prize"
"""
input GameRafflePrizeMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  raffleId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type GameRafflePrizeMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "game_raffle_prize"
"""
input GameRafflePrizeMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  raffleId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "game_raffle_prize"
"""
type GameRafflePrizeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [GameRafflePrize!]!
}

"""
input type for inserting object relation for remote table "game_raffle_prize"
"""
input GameRafflePrizeObjRelInsertInput {
  data: GameRafflePrizeInsertInput!

  """upsert condition"""
  onConflict: GameRafflePrizeOnConflict
}

"""
on_conflict condition type for table "game_raffle_prize"
"""
input GameRafflePrizeOnConflict {
  constraint: GameRafflePrizeConstraint!
  updateColumns: [GameRafflePrizeUpdateColumn!]! = []
  where: GameRafflePrizeBoolExp
}

"""Ordering options when selecting data from "game_raffle_prize"."""
input GameRafflePrizeOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  raffleTicketsAggregate: GameRaffleTicketAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: game_raffle_prize"""
input GameRafflePrizePkColumnsInput {
  id: uuid!
}

"""
select columns of table "game_raffle_prize"
"""
enum GameRafflePrizeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  raffleId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "game_raffle_prize"
"""
input GameRafflePrizeSetInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "game_raffle_prize"
"""
input GameRafflePrizeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRafflePrizeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRafflePrizeStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "game_raffle_prize"
"""
enum GameRafflePrizeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  raffleId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input GameRafflePrizeUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: GameRafflePrizeSetInput

  """filter the rows which have to be updated"""
  where: GameRafflePrizeBoolExp!
}

"""
select columns of table "game_raffle"
"""
enum GameRaffleSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  prompt

  """column name"""
  promptDescription

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

"""
input type for updating data in table "game_raffle"
"""
input GameRaffleSetInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  profileId: uuid
  prompt: String
  promptDescription: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
Streaming cursor of the table "game_raffle"
"""
input GameRaffleStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRaffleStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRaffleStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  profileId: uuid
  prompt: String
  promptDescription: String
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "game_raffle_ticket"
"""
type GameRaffleTicket {
  createdAt: timestamptz
  eventLiveId: String
  fromOptionId: uuid!
  id: uuid!
  isUsed: Boolean!
  kind: GameRaffleTicketOptionKindEnum!

  """An object relationship"""
  prize: GameRafflePrize

  """An object relationship"""
  profile: Profile!
  profileId: uuid!

  """An object relationship"""
  raffle: GameRaffle!
  raffleId: uuid!
  rafflePrizeId: uuid
  tenantId: String!
  updatedAt: timestamptz
}

"""
aggregated selection of "game_raffle_ticket"
"""
type GameRaffleTicketAggregate {
  aggregate: GameRaffleTicketAggregateFields
  nodes: [GameRaffleTicket!]!
}

input GameRaffleTicketAggregateBoolExp {
  bool_and: gameRaffleTicketAggregateBoolExpBool_and
  bool_or: gameRaffleTicketAggregateBoolExpBool_or
  count: gameRaffleTicketAggregateBoolExpCount
}

"""
aggregate fields of "game_raffle_ticket"
"""
type GameRaffleTicketAggregateFields {
  count(columns: [GameRaffleTicketSelectColumn!], distinct: Boolean): Int!
  max: GameRaffleTicketMaxFields
  min: GameRaffleTicketMinFields
}

"""
order by aggregate values of table "game_raffle_ticket"
"""
input GameRaffleTicketAggregateOrderBy {
  count: OrderBy
  max: GameRaffleTicketMaxOrderBy
  min: GameRaffleTicketMinOrderBy
}

"""
input type for inserting array relation for remote table "game_raffle_ticket"
"""
input GameRaffleTicketArrRelInsertInput {
  data: [GameRaffleTicketInsertInput!]!

  """upsert condition"""
  onConflict: GameRaffleTicketOnConflict
}

"""
Boolean expression to filter rows from the table "game_raffle_ticket". All fields are combined with a logical 'AND'.
"""
input GameRaffleTicketBoolExp {
  _and: [GameRaffleTicketBoolExp!]
  _not: GameRaffleTicketBoolExp
  _or: [GameRaffleTicketBoolExp!]
  createdAt: TimestamptzComparisonExp
  eventLiveId: StringComparisonExp
  fromOptionId: UuidComparisonExp
  id: UuidComparisonExp
  isUsed: BooleanComparisonExp
  kind: GameRaffleTicketOptionKindEnumComparisonExp
  prize: GameRafflePrizeBoolExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  rafflePrizeId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "game_raffle_ticket"
"""
enum GameRaffleTicketConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  game_raffle_ticket_pkey
}

"""
input type for inserting data into table "game_raffle_ticket"
"""
input GameRaffleTicketInsertInput {
  createdAt: timestamptz
  eventLiveId: String
  fromOptionId: uuid
  id: uuid
  isUsed: Boolean
  kind: GameRaffleTicketOptionKindEnum
  prize: GameRafflePrizeObjRelInsertInput
  profile: ProfileObjRelInsertInput
  profileId: uuid
  raffle: GameRaffleObjRelInsertInput
  raffleId: uuid
  rafflePrizeId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type GameRaffleTicketMaxFields {
  createdAt: timestamptz
  eventLiveId: String
  fromOptionId: uuid
  id: uuid
  profileId: uuid
  raffleId: uuid
  rafflePrizeId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "game_raffle_ticket"
"""
input GameRaffleTicketMaxOrderBy {
  createdAt: OrderBy
  eventLiveId: OrderBy
  fromOptionId: OrderBy
  id: OrderBy
  profileId: OrderBy
  raffleId: OrderBy
  rafflePrizeId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type GameRaffleTicketMinFields {
  createdAt: timestamptz
  eventLiveId: String
  fromOptionId: uuid
  id: uuid
  profileId: uuid
  raffleId: uuid
  rafflePrizeId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "game_raffle_ticket"
"""
input GameRaffleTicketMinOrderBy {
  createdAt: OrderBy
  eventLiveId: OrderBy
  fromOptionId: OrderBy
  id: OrderBy
  profileId: OrderBy
  raffleId: OrderBy
  rafflePrizeId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "game_raffle_ticket"
"""
type GameRaffleTicketMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [GameRaffleTicket!]!
}

"""
on_conflict condition type for table "game_raffle_ticket"
"""
input GameRaffleTicketOnConflict {
  constraint: GameRaffleTicketConstraint!
  updateColumns: [GameRaffleTicketUpdateColumn!]! = []
  where: GameRaffleTicketBoolExp
}

"""
columns and relationships of "game_raffle_ticket_option"
"""
type GameRaffleTicketOption {
  createdAt: timestamptz
  id: uuid!
  instructions: String
  isRequired: Boolean
  kind: GameRaffleTicketOptionKindEnum!

  """An object relationship"""
  raffle: GameRaffle!
  raffleId: uuid!
  tenantId: String
  ticketsGranted: Int!
  updatedAt: timestamptz
}

"""
aggregated selection of "game_raffle_ticket_option"
"""
type GameRaffleTicketOptionAggregate {
  aggregate: GameRaffleTicketOptionAggregateFields
  nodes: [GameRaffleTicketOption!]!
}

input GameRaffleTicketOptionAggregateBoolExp {
  bool_and: gameRaffleTicketOptionAggregateBoolExpBool_and
  bool_or: gameRaffleTicketOptionAggregateBoolExpBool_or
  count: gameRaffleTicketOptionAggregateBoolExpCount
}

"""
aggregate fields of "game_raffle_ticket_option"
"""
type GameRaffleTicketOptionAggregateFields {
  avg: GameRaffleTicketOptionAvgFields
  count(columns: [GameRaffleTicketOptionSelectColumn!], distinct: Boolean): Int!
  max: GameRaffleTicketOptionMaxFields
  min: GameRaffleTicketOptionMinFields
  stddev: GameRaffleTicketOptionStddevFields
  stddevPop: GameRaffleTicketOptionStddevPopFields
  stddevSamp: GameRaffleTicketOptionStddevSampFields
  sum: GameRaffleTicketOptionSumFields
  varPop: GameRaffleTicketOptionVarPopFields
  varSamp: GameRaffleTicketOptionVarSampFields
  variance: GameRaffleTicketOptionVarianceFields
}

"""
order by aggregate values of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionAggregateOrderBy {
  avg: GameRaffleTicketOptionAvgOrderBy
  count: OrderBy
  max: GameRaffleTicketOptionMaxOrderBy
  min: GameRaffleTicketOptionMinOrderBy
  stddev: GameRaffleTicketOptionStddevOrderBy
  stddevPop: GameRaffleTicketOptionStddevPopOrderBy
  stddevSamp: GameRaffleTicketOptionStddevSampOrderBy
  sum: GameRaffleTicketOptionSumOrderBy
  varPop: GameRaffleTicketOptionVarPopOrderBy
  varSamp: GameRaffleTicketOptionVarSampOrderBy
  variance: GameRaffleTicketOptionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionArrRelInsertInput {
  data: [GameRaffleTicketOptionInsertInput!]!

  """upsert condition"""
  onConflict: GameRaffleTicketOptionOnConflict
}

"""aggregate avg on columns"""
type GameRaffleTicketOptionAvgFields {
  ticketsGranted: Float
}

"""
order by avg() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionAvgOrderBy {
  ticketsGranted: OrderBy
}

"""
Boolean expression to filter rows from the table "game_raffle_ticket_option". All fields are combined with a logical 'AND'.
"""
input GameRaffleTicketOptionBoolExp {
  _and: [GameRaffleTicketOptionBoolExp!]
  _not: GameRaffleTicketOptionBoolExp
  _or: [GameRaffleTicketOptionBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  instructions: StringComparisonExp
  isRequired: BooleanComparisonExp
  kind: GameRaffleTicketOptionKindEnumComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  tenantId: StringComparisonExp
  ticketsGranted: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionConstraint {
  """
  unique or primary key constraint on columns "kind", "raffle_id"
  """
  game_raffle_ticket_option_game_raffle_id_kind_key

  """
  unique or primary key constraint on columns "id"
  """
  game_raffle_ticket_option_pkey
}

"""
input type for incrementing numeric columns in table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionIncInput {
  ticketsGranted: Int
}

"""
input type for inserting data into table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionInsertInput {
  createdAt: timestamptz
  id: uuid
  instructions: String
  isRequired: Boolean
  kind: GameRaffleTicketOptionKindEnum
  raffle: GameRaffleObjRelInsertInput
  raffleId: uuid
  tenantId: String
  ticketsGranted: Int
  updatedAt: timestamptz
}

enum GameRaffleTicketOptionKindEnum {
  MAILING_LIST
  SMS_NOTIFICATIONS
}

"""
Boolean expression to compare columns of type "GameRaffleTicketOptionKindEnum". All fields are combined with logical 'AND'.
"""
input GameRaffleTicketOptionKindEnumComparisonExp {
  _eq: GameRaffleTicketOptionKindEnum
  _in: [GameRaffleTicketOptionKindEnum!]
  _isNull: Boolean
  _neq: GameRaffleTicketOptionKindEnum
  _nin: [GameRaffleTicketOptionKindEnum!]
}

"""aggregate max on columns"""
type GameRaffleTicketOptionMaxFields {
  createdAt: timestamptz
  id: uuid
  instructions: String
  raffleId: uuid
  tenantId: String
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  instructions: OrderBy
  raffleId: OrderBy
  tenantId: OrderBy
  ticketsGranted: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type GameRaffleTicketOptionMinFields {
  createdAt: timestamptz
  id: uuid
  instructions: String
  raffleId: uuid
  tenantId: String
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  instructions: OrderBy
  raffleId: OrderBy
  tenantId: OrderBy
  ticketsGranted: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "game_raffle_ticket_option"
"""
type GameRaffleTicketOptionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [GameRaffleTicketOption!]!
}

"""
on_conflict condition type for table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionOnConflict {
  constraint: GameRaffleTicketOptionConstraint!
  updateColumns: [GameRaffleTicketOptionUpdateColumn!]! = []
  where: GameRaffleTicketOptionBoolExp
}

"""Ordering options when selecting data from "game_raffle_ticket_option"."""
input GameRaffleTicketOptionOrderBy {
  createdAt: OrderBy
  id: OrderBy
  instructions: OrderBy
  isRequired: OrderBy
  kind: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  tenantId: OrderBy
  ticketsGranted: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: game_raffle_ticket_option"""
input GameRaffleTicketOptionPkColumnsInput {
  id: uuid!
}

"""
select columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  instructions

  """column name"""
  isRequired

  """column name"""
  kind

  """column name"""
  raffleId

  """column name"""
  tenantId

  """column name"""
  ticketsGranted

  """column name"""
  updatedAt
}

"""
select "gameRaffleTicketOptionAggregateBoolExpBool_andArgumentsColumns" columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isRequired
}

"""
select "gameRaffleTicketOptionAggregateBoolExpBool_orArgumentsColumns" columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isRequired
}

"""
input type for updating data in table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionSetInput {
  createdAt: timestamptz
  id: uuid
  instructions: String
  isRequired: Boolean
  kind: GameRaffleTicketOptionKindEnum
  raffleId: uuid
  tenantId: String
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type GameRaffleTicketOptionStddevFields {
  ticketsGranted: Float
}

"""
order by stddev() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStddevOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate stddevPop on columns"""
type GameRaffleTicketOptionStddevPopFields {
  ticketsGranted: Float
}

"""
order by stddevPop() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStddevPopOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate stddevSamp on columns"""
type GameRaffleTicketOptionStddevSampFields {
  ticketsGranted: Float
}

"""
order by stddevSamp() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStddevSampOrderBy {
  ticketsGranted: OrderBy
}

"""
Streaming cursor of the table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRaffleTicketOptionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRaffleTicketOptionStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  instructions: String
  isRequired: Boolean
  kind: GameRaffleTicketOptionKindEnum
  raffleId: uuid
  tenantId: String
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type GameRaffleTicketOptionSumFields {
  ticketsGranted: Int
}

"""
order by sum() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionSumOrderBy {
  ticketsGranted: OrderBy
}

"""
update columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  instructions

  """column name"""
  isRequired

  """column name"""
  kind

  """column name"""
  raffleId

  """column name"""
  tenantId

  """column name"""
  ticketsGranted

  """column name"""
  updatedAt
}

input GameRaffleTicketOptionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: GameRaffleTicketOptionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: GameRaffleTicketOptionSetInput

  """filter the rows which have to be updated"""
  where: GameRaffleTicketOptionBoolExp!
}

"""aggregate varPop on columns"""
type GameRaffleTicketOptionVarPopFields {
  ticketsGranted: Float
}

"""
order by varPop() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionVarPopOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate varSamp on columns"""
type GameRaffleTicketOptionVarSampFields {
  ticketsGranted: Float
}

"""
order by varSamp() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionVarSampOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate variance on columns"""
type GameRaffleTicketOptionVarianceFields {
  ticketsGranted: Float
}

"""
order by variance() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionVarianceOrderBy {
  ticketsGranted: OrderBy
}

"""Ordering options when selecting data from "game_raffle_ticket"."""
input GameRaffleTicketOrderBy {
  createdAt: OrderBy
  eventLiveId: OrderBy
  fromOptionId: OrderBy
  id: OrderBy
  isUsed: OrderBy
  kind: OrderBy
  prize: GameRafflePrizeOrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  rafflePrizeId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: game_raffle_ticket"""
input GameRaffleTicketPkColumnsInput {
  id: uuid!
}

"""
select columns of table "game_raffle_ticket"
"""
enum GameRaffleTicketSelectColumn {
  """column name"""
  createdAt

  """column name"""
  eventLiveId

  """column name"""
  fromOptionId

  """column name"""
  id

  """column name"""
  isUsed

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  raffleId

  """column name"""
  rafflePrizeId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
select "gameRaffleTicketAggregateBoolExpBool_andArgumentsColumns" columns of table "game_raffle_ticket"
"""
enum GameRaffleTicketSelectColumnGameRaffleTicketAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isUsed
}

"""
select "gameRaffleTicketAggregateBoolExpBool_orArgumentsColumns" columns of table "game_raffle_ticket"
"""
enum GameRaffleTicketSelectColumnGameRaffleTicketAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isUsed
}

"""
input type for updating data in table "game_raffle_ticket"
"""
input GameRaffleTicketSetInput {
  createdAt: timestamptz
  eventLiveId: String
  fromOptionId: uuid
  id: uuid
  isUsed: Boolean
  kind: GameRaffleTicketOptionKindEnum
  profileId: uuid
  raffleId: uuid
  rafflePrizeId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "game_raffle_ticket"
"""
input GameRaffleTicketStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRaffleTicketStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRaffleTicketStreamCursorValueInput {
  createdAt: timestamptz
  eventLiveId: String
  fromOptionId: uuid
  id: uuid
  isUsed: Boolean
  kind: GameRaffleTicketOptionKindEnum
  profileId: uuid
  raffleId: uuid
  rafflePrizeId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "game_raffle_ticket"
"""
enum GameRaffleTicketUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  eventLiveId

  """column name"""
  fromOptionId

  """column name"""
  id

  """column name"""
  isUsed

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  raffleId

  """column name"""
  rafflePrizeId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input GameRaffleTicketUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: GameRaffleTicketSetInput

  """filter the rows which have to be updated"""
  where: GameRaffleTicketBoolExp!
}

"""
update columns of table "game_raffle"
"""
enum GameRaffleUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  prompt

  """column name"""
  promptDescription

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

input GameRaffleUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: GameRaffleSetInput

  """filter the rows which have to be updated"""
  where: GameRaffleBoolExp!
}

input GeoEnsureLocationInput {
  latitude: Float
  longitude: Float
  name: String
  search: String!
}

type GeoEnsureLocationOutput {
  id: uuid
  location: GeoLocation
}

"""
columns and relationships of "geo_location"
"""
type GeoLocation {
  city: String
  country: String!
  countryCode: String!
  createdAt: timestamptz!

  """An object relationship"""
  event: Event
  formatted: String
  id: uuid!
  latitude: numeric!
  longitude: numeric!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String
  postalCode: String

  """An object relationship"""
  profile: Profile
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String!
  timezone: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "geo_location"
"""
type GeoLocationAggregate {
  aggregate: GeoLocationAggregateFields
  nodes: [GeoLocation!]!
}

"""
aggregate fields of "geo_location"
"""
type GeoLocationAggregateFields {
  avg: GeoLocationAvgFields
  count(columns: [GeoLocationSelectColumn!], distinct: Boolean): Int!
  max: GeoLocationMaxFields
  min: GeoLocationMinFields
  stddev: GeoLocationStddevFields
  stddevPop: GeoLocationStddevPopFields
  stddevSamp: GeoLocationStddevSampFields
  sum: GeoLocationSumFields
  varPop: GeoLocationVarPopFields
  varSamp: GeoLocationVarSampFields
  variance: GeoLocationVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input GeoLocationAppendInput {
  metadata: jsonb
}

"""aggregate avg on columns"""
type GeoLocationAvgFields {
  latitude: Float
  longitude: Float
}

"""
Boolean expression to filter rows from the table "geo_location". All fields are combined with a logical 'AND'.
"""
input GeoLocationBoolExp {
  _and: [GeoLocationBoolExp!]
  _not: GeoLocationBoolExp
  _or: [GeoLocationBoolExp!]
  city: StringComparisonExp
  country: StringComparisonExp
  countryCode: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  formatted: StringComparisonExp
  id: UuidComparisonExp
  latitude: NumericComparisonExp
  longitude: NumericComparisonExp
  metadata: JsonbComparisonExp
  name: StringComparisonExp
  postalCode: StringComparisonExp
  profile: ProfileBoolExp
  state: StringComparisonExp
  stateCode: StringComparisonExp
  street1: StringComparisonExp
  street2: StringComparisonExp
  tenantId: StringComparisonExp
  timezone: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "geo_location"
"""
enum GeoLocationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  geo_location_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input GeoLocationDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input GeoLocationDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input GeoLocationDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "geo_location"
"""
input GeoLocationIncInput {
  latitude: numeric
  longitude: numeric
}

"""
input type for inserting data into table "geo_location"
"""
input GeoLocationInsertInput {
  city: String
  country: String
  countryCode: String
  createdAt: timestamptz
  event: EventObjRelInsertInput
  formatted: String
  id: uuid
  latitude: numeric
  longitude: numeric
  metadata: jsonb
  name: String
  postalCode: String
  profile: ProfileObjRelInsertInput
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type GeoLocationMaxFields {
  city: String
  country: String
  countryCode: String
  createdAt: timestamptz
  formatted: String
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
  postalCode: String
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type GeoLocationMinFields {
  city: String
  country: String
  countryCode: String
  createdAt: timestamptz
  formatted: String
  id: uuid
  latitude: numeric
  longitude: numeric
  name: String
  postalCode: String
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "geo_location"
"""
type GeoLocationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [GeoLocation!]!
}

"""
input type for inserting object relation for remote table "geo_location"
"""
input GeoLocationObjRelInsertInput {
  data: GeoLocationInsertInput!

  """upsert condition"""
  onConflict: GeoLocationOnConflict
}

"""
on_conflict condition type for table "geo_location"
"""
input GeoLocationOnConflict {
  constraint: GeoLocationConstraint!
  updateColumns: [GeoLocationUpdateColumn!]! = []
  where: GeoLocationBoolExp
}

"""Ordering options when selecting data from "geo_location"."""
input GeoLocationOrderBy {
  city: OrderBy
  country: OrderBy
  countryCode: OrderBy
  createdAt: OrderBy
  event: EventOrderBy
  formatted: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  metadata: OrderBy
  name: OrderBy
  postalCode: OrderBy
  profile: ProfileOrderBy
  state: OrderBy
  stateCode: OrderBy
  street1: OrderBy
  street2: OrderBy
  tenantId: OrderBy
  timezone: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: geo_location"""
input GeoLocationPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input GeoLocationPrependInput {
  metadata: jsonb
}

"""
select columns of table "geo_location"
"""
enum GeoLocationSelectColumn {
  """column name"""
  city

  """column name"""
  country

  """column name"""
  countryCode

  """column name"""
  createdAt

  """column name"""
  formatted

  """column name"""
  id

  """column name"""
  latitude

  """column name"""
  longitude

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  postalCode

  """column name"""
  state

  """column name"""
  stateCode

  """column name"""
  street1

  """column name"""
  street2

  """column name"""
  tenantId

  """column name"""
  timezone

  """column name"""
  updatedAt
}

"""
input type for updating data in table "geo_location"
"""
input GeoLocationSetInput {
  city: String
  country: String
  countryCode: String
  createdAt: timestamptz
  formatted: String
  id: uuid
  latitude: numeric
  longitude: numeric
  metadata: jsonb
  name: String
  postalCode: String
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type GeoLocationStddevFields {
  latitude: Float
  longitude: Float
}

"""aggregate stddevPop on columns"""
type GeoLocationStddevPopFields {
  latitude: Float
  longitude: Float
}

"""aggregate stddevSamp on columns"""
type GeoLocationStddevSampFields {
  latitude: Float
  longitude: Float
}

"""
Streaming cursor of the table "geo_location"
"""
input GeoLocationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GeoLocationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GeoLocationStreamCursorValueInput {
  city: String
  country: String
  countryCode: String
  createdAt: timestamptz
  formatted: String
  id: uuid
  latitude: numeric
  longitude: numeric
  metadata: jsonb
  name: String
  postalCode: String
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type GeoLocationSumFields {
  latitude: numeric
  longitude: numeric
}

"""
update columns of table "geo_location"
"""
enum GeoLocationUpdateColumn {
  """column name"""
  city

  """column name"""
  country

  """column name"""
  countryCode

  """column name"""
  createdAt

  """column name"""
  formatted

  """column name"""
  id

  """column name"""
  latitude

  """column name"""
  longitude

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  postalCode

  """column name"""
  state

  """column name"""
  stateCode

  """column name"""
  street1

  """column name"""
  street2

  """column name"""
  tenantId

  """column name"""
  timezone

  """column name"""
  updatedAt
}

input GeoLocationUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: GeoLocationAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: GeoLocationDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: GeoLocationDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: GeoLocationDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: GeoLocationIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: GeoLocationPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: GeoLocationSetInput

  """filter the rows which have to be updated"""
  where: GeoLocationBoolExp!
}

"""aggregate varPop on columns"""
type GeoLocationVarPopFields {
  latitude: Float
  longitude: Float
}

"""aggregate varSamp on columns"""
type GeoLocationVarSampFields {
  latitude: Float
  longitude: Float
}

"""aggregate variance on columns"""
type GeoLocationVarianceFields {
  latitude: Float
  longitude: Float
}

type GeoPlace {
  city: String
  country: String!
  countryCode: String!
  formatted: String!
  latitude: Float!
  longitude: Float!
  metadata: jsonb!
  name: String
  postalCode: String
  state: String
  stateCode: String
  street1: String
  street2: String
  timezone: String!
}

input GeoPlaceAutocompleteInput {
  autocomplete: Boolean
  search: String!
}

type GeoPlaceOutput {
  places: [GeoPlace!]!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "log"
"""
type Log {
  createdAt: timestamptz!
  id: uuid!
  message: String!
  profileId: uuid
  service: String!
  tenantId: String!
  trace: String!
  type: String!
  updatedAt: timestamptz!
}

"""
columns and relationships of "log_activity"
"""
type LogActivity {
  createdAt: timestamptz!
  id: uuid!
  kind: LogActivityKindEnum!
  message: String!
  primaryKey: String
  profileId: uuid
  tableName: String
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "log_activity"
"""
type LogActivityAggregate {
  aggregate: LogActivityAggregateFields
  nodes: [LogActivity!]!
}

"""
aggregate fields of "log_activity"
"""
type LogActivityAggregateFields {
  count(columns: [LogActivitySelectColumn!], distinct: Boolean): Int!
  max: LogActivityMaxFields
  min: LogActivityMinFields
}

"""
Boolean expression to filter rows from the table "log_activity". All fields are combined with a logical 'AND'.
"""
input LogActivityBoolExp {
  _and: [LogActivityBoolExp!]
  _not: LogActivityBoolExp
  _or: [LogActivityBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  kind: LogActivityKindEnumComparisonExp
  message: StringComparisonExp
  primaryKey: StringComparisonExp
  profileId: UuidComparisonExp
  tableName: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "log_activity"
"""
enum LogActivityConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  log_activity_pkey
}

"""
input type for inserting data into table "log_activity"
"""
input LogActivityInsertInput {
  createdAt: timestamptz
  id: uuid
  kind: LogActivityKindEnum
  message: String
  primaryKey: String
  profileId: uuid
  tableName: String
  tenantId: String
  updatedAt: timestamptz
}

enum LogActivityKindEnum {
  AUTH_ERROR
  AUTH_SIGN_IN
  AUTH_SIGN_UP
  EVENT_LIVE_END
  EVENT_LIVE_QUESTION_SET_START
  EVENT_LIVE_START
  SEARCH
  SESSION_PAUSE
  SESSION_RESUME
  VIEW
}

"""
Boolean expression to compare columns of type "LogActivityKindEnum". All fields are combined with logical 'AND'.
"""
input LogActivityKindEnumComparisonExp {
  _eq: LogActivityKindEnum
  _in: [LogActivityKindEnum!]
  _isNull: Boolean
  _neq: LogActivityKindEnum
  _nin: [LogActivityKindEnum!]
}

"""aggregate max on columns"""
type LogActivityMaxFields {
  createdAt: timestamptz
  id: uuid
  message: String
  primaryKey: String
  profileId: uuid
  tableName: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type LogActivityMinFields {
  createdAt: timestamptz
  id: uuid
  message: String
  primaryKey: String
  profileId: uuid
  tableName: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "log_activity"
"""
type LogActivityMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [LogActivity!]!
}

"""
on_conflict condition type for table "log_activity"
"""
input LogActivityOnConflict {
  constraint: LogActivityConstraint!
  updateColumns: [LogActivityUpdateColumn!]! = []
  where: LogActivityBoolExp
}

"""Ordering options when selecting data from "log_activity"."""
input LogActivityOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  message: OrderBy
  primaryKey: OrderBy
  profileId: OrderBy
  tableName: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: log_activity"""
input LogActivityPkColumnsInput {
  id: uuid!
}

"""
select columns of table "log_activity"
"""
enum LogActivitySelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  message

  """column name"""
  primaryKey

  """column name"""
  profileId

  """column name"""
  tableName

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "log_activity"
"""
input LogActivitySetInput {
  createdAt: timestamptz
  id: uuid
  kind: LogActivityKindEnum
  message: String
  primaryKey: String
  profileId: uuid
  tableName: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "log_activity"
"""
input LogActivityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LogActivityStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LogActivityStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  kind: LogActivityKindEnum
  message: String
  primaryKey: String
  profileId: uuid
  tableName: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "log_activity"
"""
enum LogActivityUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  message

  """column name"""
  primaryKey

  """column name"""
  profileId

  """column name"""
  tableName

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input LogActivityUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: LogActivitySetInput

  """filter the rows which have to be updated"""
  where: LogActivityBoolExp!
}

"""
aggregated selection of "log"
"""
type LogAggregate {
  aggregate: LogAggregateFields
  nodes: [Log!]!
}

input LogAggregateBoolExp {
  count: logAggregateBoolExpCount
}

"""
aggregate fields of "log"
"""
type LogAggregateFields {
  count(columns: [LogSelectColumn!], distinct: Boolean): Int!
  max: LogMaxFields
  min: LogMinFields
}

"""
order by aggregate values of table "log"
"""
input LogAggregateOrderBy {
  count: OrderBy
  max: LogMaxOrderBy
  min: LogMinOrderBy
}

"""
input type for inserting array relation for remote table "log"
"""
input LogArrRelInsertInput {
  data: [LogInsertInput!]!

  """upsert condition"""
  onConflict: LogOnConflict
}

"""
columns and relationships of "log_audit"
"""
type LogAudit {
  createdAt: timestamptz!
  dataNew(
    """JSON select path"""
    path: String
  ): jsonb
  dataOld(
    """JSON select path"""
    path: String
  ): jsonb
  event(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  operationKind: LogOperationKindEnum!
  profileId: uuid
  tableName: String!
  tableSchema: String!
  tenantId: String!
  triggerName: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "log_audit"
"""
type LogAuditAggregate {
  aggregate: LogAuditAggregateFields
  nodes: [LogAudit!]!
}

"""
aggregate fields of "log_audit"
"""
type LogAuditAggregateFields {
  count(columns: [LogAuditSelectColumn!], distinct: Boolean): Int!
  max: LogAuditMaxFields
  min: LogAuditMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input LogAuditAppendInput {
  dataNew: jsonb
  dataOld: jsonb
  event: jsonb
}

"""
Boolean expression to filter rows from the table "log_audit". All fields are combined with a logical 'AND'.
"""
input LogAuditBoolExp {
  _and: [LogAuditBoolExp!]
  _not: LogAuditBoolExp
  _or: [LogAuditBoolExp!]
  createdAt: TimestamptzComparisonExp
  dataNew: JsonbComparisonExp
  dataOld: JsonbComparisonExp
  event: JsonbComparisonExp
  id: UuidComparisonExp
  operationKind: LogOperationKindEnumComparisonExp
  profileId: UuidComparisonExp
  tableName: StringComparisonExp
  tableSchema: StringComparisonExp
  tenantId: StringComparisonExp
  triggerName: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "log_audit"
"""
enum LogAuditConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  log_audit_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input LogAuditDeleteAtPathInput {
  dataNew: [String!]
  dataOld: [String!]
  event: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input LogAuditDeleteElemInput {
  dataNew: Int
  dataOld: Int
  event: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input LogAuditDeleteKeyInput {
  dataNew: String
  dataOld: String
  event: String
}

"""
input type for inserting data into table "log_audit"
"""
input LogAuditInsertInput {
  createdAt: timestamptz
  dataNew: jsonb
  dataOld: jsonb
  event: jsonb
  id: uuid
  operationKind: LogOperationKindEnum
  profileId: uuid
  tableName: String
  tableSchema: String
  tenantId: String
  triggerName: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type LogAuditMaxFields {
  createdAt: timestamptz
  id: uuid
  profileId: uuid
  tableName: String
  tableSchema: String
  tenantId: String
  triggerName: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type LogAuditMinFields {
  createdAt: timestamptz
  id: uuid
  profileId: uuid
  tableName: String
  tableSchema: String
  tenantId: String
  triggerName: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "log_audit"
"""
type LogAuditMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [LogAudit!]!
}

"""
on_conflict condition type for table "log_audit"
"""
input LogAuditOnConflict {
  constraint: LogAuditConstraint!
  updateColumns: [LogAuditUpdateColumn!]! = []
  where: LogAuditBoolExp
}

"""Ordering options when selecting data from "log_audit"."""
input LogAuditOrderBy {
  createdAt: OrderBy
  dataNew: OrderBy
  dataOld: OrderBy
  event: OrderBy
  id: OrderBy
  operationKind: OrderBy
  profileId: OrderBy
  tableName: OrderBy
  tableSchema: OrderBy
  tenantId: OrderBy
  triggerName: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: log_audit"""
input LogAuditPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input LogAuditPrependInput {
  dataNew: jsonb
  dataOld: jsonb
  event: jsonb
}

"""
select columns of table "log_audit"
"""
enum LogAuditSelectColumn {
  """column name"""
  createdAt

  """column name"""
  dataNew

  """column name"""
  dataOld

  """column name"""
  event

  """column name"""
  id

  """column name"""
  operationKind

  """column name"""
  profileId

  """column name"""
  tableName

  """column name"""
  tableSchema

  """column name"""
  tenantId

  """column name"""
  triggerName

  """column name"""
  updatedAt
}

"""
input type for updating data in table "log_audit"
"""
input LogAuditSetInput {
  createdAt: timestamptz
  dataNew: jsonb
  dataOld: jsonb
  event: jsonb
  id: uuid
  operationKind: LogOperationKindEnum
  profileId: uuid
  tableName: String
  tableSchema: String
  tenantId: String
  triggerName: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "log_audit"
"""
input LogAuditStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LogAuditStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LogAuditStreamCursorValueInput {
  createdAt: timestamptz
  dataNew: jsonb
  dataOld: jsonb
  event: jsonb
  id: uuid
  operationKind: LogOperationKindEnum
  profileId: uuid
  tableName: String
  tableSchema: String
  tenantId: String
  triggerName: String
  updatedAt: timestamptz
}

"""
update columns of table "log_audit"
"""
enum LogAuditUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  dataNew

  """column name"""
  dataOld

  """column name"""
  event

  """column name"""
  id

  """column name"""
  operationKind

  """column name"""
  profileId

  """column name"""
  tableName

  """column name"""
  tableSchema

  """column name"""
  tenantId

  """column name"""
  triggerName

  """column name"""
  updatedAt
}

input LogAuditUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: LogAuditAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: LogAuditDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: LogAuditDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: LogAuditDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: LogAuditPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: LogAuditSetInput

  """filter the rows which have to be updated"""
  where: LogAuditBoolExp!
}

"""
Boolean expression to filter rows from the table "log". All fields are combined with a logical 'AND'.
"""
input LogBoolExp {
  _and: [LogBoolExp!]
  _not: LogBoolExp
  _or: [LogBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  message: StringComparisonExp
  profileId: UuidComparisonExp
  service: StringComparisonExp
  tenantId: StringComparisonExp
  trace: StringComparisonExp
  type: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "log"
"""
enum LogConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  log_pkey
}

"""
input type for inserting data into table "log"
"""
input LogInsertInput {
  createdAt: timestamptz
  id: uuid
  message: String
  profileId: uuid
  service: String
  tenantId: String
  trace: String
  type: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type LogMaxFields {
  createdAt: timestamptz
  id: uuid
  message: String
  profileId: uuid
  service: String
  tenantId: String
  trace: String
  type: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "log"
"""
input LogMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  message: OrderBy
  profileId: OrderBy
  service: OrderBy
  tenantId: OrderBy
  trace: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type LogMinFields {
  createdAt: timestamptz
  id: uuid
  message: String
  profileId: uuid
  service: String
  tenantId: String
  trace: String
  type: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "log"
"""
input LogMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  message: OrderBy
  profileId: OrderBy
  service: OrderBy
  tenantId: OrderBy
  trace: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "log"
"""
type LogMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Log!]!
}

"""
on_conflict condition type for table "log"
"""
input LogOnConflict {
  constraint: LogConstraint!
  updateColumns: [LogUpdateColumn!]! = []
  where: LogBoolExp
}

enum LogOperationKindEnum {
  DELETE
  INSERT
  UPDATE
}

"""
Boolean expression to compare columns of type "LogOperationKindEnum". All fields are combined with logical 'AND'.
"""
input LogOperationKindEnumComparisonExp {
  _eq: LogOperationKindEnum
  _in: [LogOperationKindEnum!]
  _isNull: Boolean
  _neq: LogOperationKindEnum
  _nin: [LogOperationKindEnum!]
}

"""Ordering options when selecting data from "log"."""
input LogOrderBy {
  createdAt: OrderBy
  id: OrderBy
  message: OrderBy
  profileId: OrderBy
  service: OrderBy
  tenantId: OrderBy
  trace: OrderBy
  type: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: log"""
input LogPkColumnsInput {
  id: uuid!
}

"""
select columns of table "log"
"""
enum LogSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  message

  """column name"""
  profileId

  """column name"""
  service

  """column name"""
  tenantId

  """column name"""
  trace

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "log"
"""
input LogSetInput {
  createdAt: timestamptz
  id: uuid
  message: String
  profileId: uuid
  service: String
  tenantId: String
  trace: String
  type: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "log"
"""
input LogStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LogStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LogStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  message: String
  profileId: uuid
  service: String
  tenantId: String
  trace: String
  type: String
  updatedAt: timestamptz
}

"""
update columns of table "log"
"""
enum LogUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  message

  """column name"""
  profileId

  """column name"""
  service

  """column name"""
  tenantId

  """column name"""
  trace

  """column name"""
  type

  """column name"""
  updatedAt
}

input LogUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: LogSetInput

  """filter the rows which have to be updated"""
  where: LogBoolExp!
}

"""
columns and relationships of "media_item"
"""
type MediaItem {
  blurHash: String
  contentLength: Int
  contentType: String!
  createdAt: timestamptz!
  defaultUrl: String
  duration: Int
  externalId: String
  filename: String
  height: Int
  id: String!
  kind: MediaKindEnum!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  profile: Profile
  profileId: uuid

  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!

  """An aggregate relationship"""
  tagsAggregate(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): MediaItemTagAggregate!
  tenantId: String!
  thumbnailUrl: String
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
  width: Int
}

"""
aggregated selection of "media_item"
"""
type MediaItemAggregate {
  aggregate: MediaItemAggregateFields
  nodes: [MediaItem!]!
}

"""
aggregate fields of "media_item"
"""
type MediaItemAggregateFields {
  avg: MediaItemAvgFields
  count(columns: [MediaItemSelectColumn!], distinct: Boolean): Int!
  max: MediaItemMaxFields
  min: MediaItemMinFields
  stddev: MediaItemStddevFields
  stddevPop: MediaItemStddevPopFields
  stddevSamp: MediaItemStddevSampFields
  sum: MediaItemSumFields
  varPop: MediaItemVarPopFields
  varSamp: MediaItemVarSampFields
  variance: MediaItemVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input MediaItemAppendInput {
  metadata: jsonb
}

"""aggregate avg on columns"""
type MediaItemAvgFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""
Boolean expression to filter rows from the table "media_item". All fields are combined with a logical 'AND'.
"""
input MediaItemBoolExp {
  _and: [MediaItemBoolExp!]
  _not: MediaItemBoolExp
  _or: [MediaItemBoolExp!]
  blurHash: StringComparisonExp
  contentLength: IntComparisonExp
  contentType: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  defaultUrl: StringComparisonExp
  duration: IntComparisonExp
  externalId: StringComparisonExp
  filename: StringComparisonExp
  height: IntComparisonExp
  id: StringComparisonExp
  kind: MediaKindEnumComparisonExp
  metadata: JsonbComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  tags: MediaItemTagBoolExp
  tagsAggregate: MediaItemTagAggregateBoolExp
  tenantId: StringComparisonExp
  thumbnailUrl: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
  width: IntComparisonExp
}

"""
unique or primary key constraints on table "media_item"
"""
enum MediaItemConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  media_item_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input MediaItemDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input MediaItemDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input MediaItemDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "media_item"
"""
input MediaItemIncInput {
  contentLength: Int
  duration: Int
  height: Int
  width: Int
}

"""
input type for inserting data into table "media_item"
"""
input MediaItemInsertInput {
  blurHash: String
  contentLength: Int
  contentType: String
  createdAt: timestamptz
  defaultUrl: String
  duration: Int
  externalId: String
  filename: String
  height: Int
  id: String
  kind: MediaKindEnum
  metadata: jsonb
  profile: ProfileObjRelInsertInput
  profileId: uuid
  tags: MediaItemTagArrRelInsertInput
  tenantId: String
  thumbnailUrl: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
  width: Int
}

"""aggregate max on columns"""
type MediaItemMaxFields {
  blurHash: String
  contentLength: Int
  contentType: String
  createdAt: timestamptz
  defaultUrl: String
  duration: Int
  externalId: String
  filename: String
  height: Int
  id: String
  profileId: uuid
  tenantId: String
  thumbnailUrl: String
  updatedAt: timestamptz
  width: Int
}

"""aggregate min on columns"""
type MediaItemMinFields {
  blurHash: String
  contentLength: Int
  contentType: String
  createdAt: timestamptz
  defaultUrl: String
  duration: Int
  externalId: String
  filename: String
  height: Int
  id: String
  profileId: uuid
  tenantId: String
  thumbnailUrl: String
  updatedAt: timestamptz
  width: Int
}

"""
response of any mutation on the table "media_item"
"""
type MediaItemMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MediaItem!]!
}

"""
input type for inserting object relation for remote table "media_item"
"""
input MediaItemObjRelInsertInput {
  data: MediaItemInsertInput!

  """upsert condition"""
  onConflict: MediaItemOnConflict
}

"""
on_conflict condition type for table "media_item"
"""
input MediaItemOnConflict {
  constraint: MediaItemConstraint!
  updateColumns: [MediaItemUpdateColumn!]! = []
  where: MediaItemBoolExp
}

"""Ordering options when selecting data from "media_item"."""
input MediaItemOrderBy {
  blurHash: OrderBy
  contentLength: OrderBy
  contentType: OrderBy
  createdAt: OrderBy
  defaultUrl: OrderBy
  duration: OrderBy
  externalId: OrderBy
  filename: OrderBy
  height: OrderBy
  id: OrderBy
  kind: OrderBy
  metadata: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  tagsAggregate: MediaItemTagAggregateOrderBy
  tenantId: OrderBy
  thumbnailUrl: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
  width: OrderBy
}

"""primary key columns input for table: media_item"""
input MediaItemPkColumnsInput {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input MediaItemPrependInput {
  metadata: jsonb
}

"""
select columns of table "media_item"
"""
enum MediaItemSelectColumn {
  """column name"""
  blurHash

  """column name"""
  contentLength

  """column name"""
  contentType

  """column name"""
  createdAt

  """column name"""
  defaultUrl

  """column name"""
  duration

  """column name"""
  externalId

  """column name"""
  filename

  """column name"""
  height

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  thumbnailUrl

  """column name"""
  updatedAt

  """column name"""
  visibility

  """column name"""
  width
}

"""
input type for updating data in table "media_item"
"""
input MediaItemSetInput {
  blurHash: String
  contentLength: Int
  contentType: String
  createdAt: timestamptz
  defaultUrl: String
  duration: Int
  externalId: String
  filename: String
  height: Int
  id: String
  kind: MediaKindEnum
  metadata: jsonb
  profileId: uuid
  tenantId: String
  thumbnailUrl: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
  width: Int
}

"""aggregate stddev on columns"""
type MediaItemStddevFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""aggregate stddevPop on columns"""
type MediaItemStddevPopFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""aggregate stddevSamp on columns"""
type MediaItemStddevSampFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""
Streaming cursor of the table "media_item"
"""
input MediaItemStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MediaItemStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MediaItemStreamCursorValueInput {
  blurHash: String
  contentLength: Int
  contentType: String
  createdAt: timestamptz
  defaultUrl: String
  duration: Int
  externalId: String
  filename: String
  height: Int
  id: String
  kind: MediaKindEnum
  metadata: jsonb
  profileId: uuid
  tenantId: String
  thumbnailUrl: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
  width: Int
}

"""aggregate sum on columns"""
type MediaItemSumFields {
  contentLength: Int
  duration: Int
  height: Int
  width: Int
}

"""
columns and relationships of "media_item_tag"
"""
type MediaItemTag {
  createdAt: timestamptz!

  """An object relationship"""
  mediaItem: MediaItem!
  mediaItemId: String!
  tag: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "media_item_tag"
"""
type MediaItemTagAggregate {
  aggregate: MediaItemTagAggregateFields
  nodes: [MediaItemTag!]!
}

input MediaItemTagAggregateBoolExp {
  count: mediaItemTagAggregateBoolExpCount
}

"""
aggregate fields of "media_item_tag"
"""
type MediaItemTagAggregateFields {
  count(columns: [MediaItemTagSelectColumn!], distinct: Boolean): Int!
  max: MediaItemTagMaxFields
  min: MediaItemTagMinFields
}

"""
order by aggregate values of table "media_item_tag"
"""
input MediaItemTagAggregateOrderBy {
  count: OrderBy
  max: MediaItemTagMaxOrderBy
  min: MediaItemTagMinOrderBy
}

"""
input type for inserting array relation for remote table "media_item_tag"
"""
input MediaItemTagArrRelInsertInput {
  data: [MediaItemTagInsertInput!]!

  """upsert condition"""
  onConflict: MediaItemTagOnConflict
}

"""
Boolean expression to filter rows from the table "media_item_tag". All fields are combined with a logical 'AND'.
"""
input MediaItemTagBoolExp {
  _and: [MediaItemTagBoolExp!]
  _not: MediaItemTagBoolExp
  _or: [MediaItemTagBoolExp!]
  createdAt: TimestamptzComparisonExp
  mediaItem: MediaItemBoolExp
  mediaItemId: StringComparisonExp
  tag: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "media_item_tag"
"""
enum MediaItemTagConstraint {
  """
  unique or primary key constraint on columns "tag", "media_item_id"
  """
  media_item_tag_pkey
}

"""
input type for inserting data into table "media_item_tag"
"""
input MediaItemTagInsertInput {
  createdAt: timestamptz
  mediaItem: MediaItemObjRelInsertInput
  mediaItemId: String
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type MediaItemTagMaxFields {
  createdAt: timestamptz
  mediaItemId: String
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "media_item_tag"
"""
input MediaItemTagMaxOrderBy {
  createdAt: OrderBy
  mediaItemId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type MediaItemTagMinFields {
  createdAt: timestamptz
  mediaItemId: String
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "media_item_tag"
"""
input MediaItemTagMinOrderBy {
  createdAt: OrderBy
  mediaItemId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "media_item_tag"
"""
type MediaItemTagMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [MediaItemTag!]!
}

"""
on_conflict condition type for table "media_item_tag"
"""
input MediaItemTagOnConflict {
  constraint: MediaItemTagConstraint!
  updateColumns: [MediaItemTagUpdateColumn!]! = []
  where: MediaItemTagBoolExp
}

"""Ordering options when selecting data from "media_item_tag"."""
input MediaItemTagOrderBy {
  createdAt: OrderBy
  mediaItem: MediaItemOrderBy
  mediaItemId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: media_item_tag"""
input MediaItemTagPkColumnsInput {
  mediaItemId: String!
  tag: String!
}

"""
select columns of table "media_item_tag"
"""
enum MediaItemTagSelectColumn {
  """column name"""
  createdAt

  """column name"""
  mediaItemId

  """column name"""
  tag

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "media_item_tag"
"""
input MediaItemTagSetInput {
  createdAt: timestamptz
  mediaItemId: String
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "media_item_tag"
"""
input MediaItemTagStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MediaItemTagStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MediaItemTagStreamCursorValueInput {
  createdAt: timestamptz
  mediaItemId: String
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "media_item_tag"
"""
enum MediaItemTagUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  mediaItemId

  """column name"""
  tag

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input MediaItemTagUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: MediaItemTagSetInput

  """filter the rows which have to be updated"""
  where: MediaItemTagBoolExp!
}

"""
update columns of table "media_item"
"""
enum MediaItemUpdateColumn {
  """column name"""
  blurHash

  """column name"""
  contentLength

  """column name"""
  contentType

  """column name"""
  createdAt

  """column name"""
  defaultUrl

  """column name"""
  duration

  """column name"""
  externalId

  """column name"""
  filename

  """column name"""
  height

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  thumbnailUrl

  """column name"""
  updatedAt

  """column name"""
  visibility

  """column name"""
  width
}

input MediaItemUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: MediaItemAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: MediaItemDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: MediaItemDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: MediaItemDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: MediaItemIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: MediaItemPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: MediaItemSetInput

  """filter the rows which have to be updated"""
  where: MediaItemBoolExp!
}

"""aggregate varPop on columns"""
type MediaItemVarPopFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""aggregate varSamp on columns"""
type MediaItemVarSampFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""aggregate variance on columns"""
type MediaItemVarianceFields {
  contentLength: Float
  duration: Float
  height: Float
  width: Float
}

"""
columns and relationships of "media_kind"
"""
type MediaKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "media_kind". All fields are combined with a logical 'AND'.
"""
input MediaKindBoolExp {
  _and: [MediaKindBoolExp!]
  _not: MediaKindBoolExp
  _or: [MediaKindBoolExp!]
  id: StringComparisonExp
}

enum MediaKindEnum {
  AUDIO_URL
  CLOUDFLARE_IMAGE
  CLOUDFLARE_VIDEO
  SVG_AVATAR
  VIDEO_URL
  WEB_IMAGE
  YOUTUBE_VIDEO
}

"""
Boolean expression to compare columns of type "MediaKindEnum". All fields are combined with logical 'AND'.
"""
input MediaKindEnumComparisonExp {
  _eq: MediaKindEnum
  _in: [MediaKindEnum!]
  _isNull: Boolean
  _neq: MediaKindEnum
  _nin: [MediaKindEnum!]
}

"""Ordering options when selecting data from "media_kind"."""
input MediaKindOrderBy {
  id: OrderBy
}

"""
select columns of table "media_kind"
"""
enum MediaKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "media_kind"
"""
input MediaKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MediaKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MediaKindStreamCursorValueInput {
  id: String
}

"""
columns and relationships of "notification"
"""
type Notification {
  body: String
  createdAt: timestamptz!
  fromAddress: String
  fromName: String
  id: uuid!
  kind: NotificationKindEnum!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  profileId: uuid
  referenceId: String
  status: NotificationStatusEnum!
  subject: String!
  tenantId: String!
  toAddress: String
  toName: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "notification"
"""
type NotificationAggregate {
  aggregate: NotificationAggregateFields
  nodes: [Notification!]!
}

"""
aggregate fields of "notification"
"""
type NotificationAggregateFields {
  count(columns: [NotificationSelectColumn!], distinct: Boolean): Int!
  max: NotificationMaxFields
  min: NotificationMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input NotificationAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'.
"""
input NotificationBoolExp {
  _and: [NotificationBoolExp!]
  _not: NotificationBoolExp
  _or: [NotificationBoolExp!]
  body: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  fromAddress: StringComparisonExp
  fromName: StringComparisonExp
  id: UuidComparisonExp
  kind: NotificationKindEnumComparisonExp
  metadata: JsonbComparisonExp
  profileId: UuidComparisonExp
  referenceId: StringComparisonExp
  status: NotificationStatusEnumComparisonExp
  subject: StringComparisonExp
  tenantId: StringComparisonExp
  toAddress: StringComparisonExp
  toName: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "notification"
"""
enum NotificationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  notification_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input NotificationDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input NotificationDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input NotificationDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "notification"
"""
input NotificationInsertInput {
  body: String
  createdAt: timestamptz
  fromAddress: String
  fromName: String
  id: uuid
  kind: NotificationKindEnum
  metadata: jsonb
  profileId: uuid
  referenceId: String
  status: NotificationStatusEnum
  subject: String
  tenantId: String
  toAddress: String
  toName: String
  updatedAt: timestamptz
}

enum NotificationKindEnum {
  EMAIL_HTML
  EMAIL_MARKDOWN
  PUSH_NOTIFICATION
  SMS
}

"""
Boolean expression to compare columns of type "NotificationKindEnum". All fields are combined with logical 'AND'.
"""
input NotificationKindEnumComparisonExp {
  _eq: NotificationKindEnum
  _in: [NotificationKindEnum!]
  _isNull: Boolean
  _neq: NotificationKindEnum
  _nin: [NotificationKindEnum!]
}

"""aggregate max on columns"""
type NotificationMaxFields {
  body: String
  createdAt: timestamptz
  fromAddress: String
  fromName: String
  id: uuid
  profileId: uuid
  referenceId: String
  subject: String
  tenantId: String
  toAddress: String
  toName: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type NotificationMinFields {
  body: String
  createdAt: timestamptz
  fromAddress: String
  fromName: String
  id: uuid
  profileId: uuid
  referenceId: String
  subject: String
  tenantId: String
  toAddress: String
  toName: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "notification"
"""
type NotificationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Notification!]!
}

"""
on_conflict condition type for table "notification"
"""
input NotificationOnConflict {
  constraint: NotificationConstraint!
  updateColumns: [NotificationUpdateColumn!]! = []
  where: NotificationBoolExp
}

"""Ordering options when selecting data from "notification"."""
input NotificationOrderBy {
  body: OrderBy
  createdAt: OrderBy
  fromAddress: OrderBy
  fromName: OrderBy
  id: OrderBy
  kind: OrderBy
  metadata: OrderBy
  profileId: OrderBy
  referenceId: OrderBy
  status: OrderBy
  subject: OrderBy
  tenantId: OrderBy
  toAddress: OrderBy
  toName: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: notification"""
input NotificationPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input NotificationPrependInput {
  metadata: jsonb
}

"""
select columns of table "notification"
"""
enum NotificationSelectColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  fromAddress

  """column name"""
  fromName

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  referenceId

  """column name"""
  status

  """column name"""
  subject

  """column name"""
  tenantId

  """column name"""
  toAddress

  """column name"""
  toName

  """column name"""
  updatedAt
}

"""
input type for updating data in table "notification"
"""
input NotificationSetInput {
  body: String
  createdAt: timestamptz
  fromAddress: String
  fromName: String
  id: uuid
  kind: NotificationKindEnum
  metadata: jsonb
  profileId: uuid
  referenceId: String
  status: NotificationStatusEnum
  subject: String
  tenantId: String
  toAddress: String
  toName: String
  updatedAt: timestamptz
}

enum NotificationStatusEnum {
  FAILED
  PENDING
  SENT
}

"""
Boolean expression to compare columns of type "NotificationStatusEnum". All fields are combined with logical 'AND'.
"""
input NotificationStatusEnumComparisonExp {
  _eq: NotificationStatusEnum
  _in: [NotificationStatusEnum!]
  _isNull: Boolean
  _neq: NotificationStatusEnum
  _nin: [NotificationStatusEnum!]
}

"""
Streaming cursor of the table "notification"
"""
input NotificationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NotificationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NotificationStreamCursorValueInput {
  body: String
  createdAt: timestamptz
  fromAddress: String
  fromName: String
  id: uuid
  kind: NotificationKindEnum
  metadata: jsonb
  profileId: uuid
  referenceId: String
  status: NotificationStatusEnum
  subject: String
  tenantId: String
  toAddress: String
  toName: String
  updatedAt: timestamptz
}

"""
update columns of table "notification"
"""
enum NotificationUpdateColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  fromAddress

  """column name"""
  fromName

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  referenceId

  """column name"""
  status

  """column name"""
  subject

  """column name"""
  tenantId

  """column name"""
  toAddress

  """column name"""
  toName

  """column name"""
  updatedAt
}

input NotificationUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: NotificationAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: NotificationDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: NotificationDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: NotificationDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: NotificationPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: NotificationSetInput

  """filter the rows which have to be updated"""
  where: NotificationBoolExp!
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
columns and relationships of "nutrition_day"
"""
type NutritionDay {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int
  createdAt: timestamptz!
  date: date

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  id: uuid!

  """An array relationship"""
  meals(
    """distinct select on columns"""
    distinctOn: [NutritionMealSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealOrderBy!]

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): [NutritionMeal!]!

  """An aggregate relationship"""
  mealsAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionMealSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealOrderBy!]

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): NutritionMealAggregate!
  order: Int

  """An object relationship"""
  plan: NutritionPlan
  planId: uuid

  """An object relationship"""
  profile: Profile!
  profileId: uuid!

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "nutrition_day"
"""
type NutritionDayAggregate {
  aggregate: NutritionDayAggregateFields
  nodes: [NutritionDay!]!
}

input NutritionDayAggregateBoolExp {
  count: nutritionDayAggregateBoolExpCount
}

"""
aggregate fields of "nutrition_day"
"""
type NutritionDayAggregateFields {
  avg: NutritionDayAvgFields
  count(columns: [NutritionDaySelectColumn!], distinct: Boolean): Int!
  max: NutritionDayMaxFields
  min: NutritionDayMinFields
  stddev: NutritionDayStddevFields
  stddevPop: NutritionDayStddevPopFields
  stddevSamp: NutritionDayStddevSampFields
  sum: NutritionDaySumFields
  varPop: NutritionDayVarPopFields
  varSamp: NutritionDayVarSampFields
  variance: NutritionDayVarianceFields
}

"""
order by aggregate values of table "nutrition_day"
"""
input NutritionDayAggregateOrderBy {
  avg: NutritionDayAvgOrderBy
  count: OrderBy
  max: NutritionDayMaxOrderBy
  min: NutritionDayMinOrderBy
  stddev: NutritionDayStddevOrderBy
  stddevPop: NutritionDayStddevPopOrderBy
  stddevSamp: NutritionDayStddevSampOrderBy
  sum: NutritionDaySumOrderBy
  varPop: NutritionDayVarPopOrderBy
  varSamp: NutritionDayVarSampOrderBy
  variance: NutritionDayVarianceOrderBy
}

"""
input type for inserting array relation for remote table "nutrition_day"
"""
input NutritionDayArrRelInsertInput {
  data: [NutritionDayInsertInput!]!

  """upsert condition"""
  onConflict: NutritionDayOnConflict
}

"""aggregate avg on columns"""
type NutritionDayAvgFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by avg() on columns of table "nutrition_day"
"""
input NutritionDayAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "nutrition_day". All fields are combined with a logical 'AND'.
"""
input NutritionDayBoolExp {
  _and: [NutritionDayBoolExp!]
  _not: NutritionDayBoolExp
  _or: [NutritionDayBoolExp!]
  calories: IntComparisonExp
  carbGrams: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  date: DateComparisonExp
  fatGrams: IntComparisonExp
  id: UuidComparisonExp
  meals: NutritionMealBoolExp
  mealsAggregate: NutritionMealAggregateBoolExp
  order: IntComparisonExp
  plan: NutritionPlanBoolExp
  planId: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  proteinGrams: IntComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "nutrition_day"
"""
enum NutritionDayConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  nutrition_day_pkey
}

"""
input type for incrementing numeric columns in table "nutrition_day"
"""
input NutritionDayIncInput {
  order: Int
}

"""
input type for inserting data into table "nutrition_day"
"""
input NutritionDayInsertInput {
  createdAt: timestamptz
  date: date
  id: uuid
  meals: NutritionMealArrRelInsertInput
  order: Int
  plan: NutritionPlanObjRelInsertInput
  planId: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type NutritionDayMaxFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int
  createdAt: timestamptz
  date: date

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  id: uuid
  order: Int
  planId: uuid
  profileId: uuid

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "nutrition_day"
"""
input NutritionDayMaxOrderBy {
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  order: OrderBy
  planId: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type NutritionDayMinFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int
  createdAt: timestamptz
  date: date

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  id: uuid
  order: Int
  planId: uuid
  profileId: uuid

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "nutrition_day"
"""
input NutritionDayMinOrderBy {
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  order: OrderBy
  planId: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "nutrition_day"
"""
type NutritionDayMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [NutritionDay!]!
}

"""
input type for inserting object relation for remote table "nutrition_day"
"""
input NutritionDayObjRelInsertInput {
  data: NutritionDayInsertInput!

  """upsert condition"""
  onConflict: NutritionDayOnConflict
}

"""
on_conflict condition type for table "nutrition_day"
"""
input NutritionDayOnConflict {
  constraint: NutritionDayConstraint!
  updateColumns: [NutritionDayUpdateColumn!]! = []
  where: NutritionDayBoolExp
}

"""Ordering options when selecting data from "nutrition_day"."""
input NutritionDayOrderBy {
  calories: OrderBy
  carbGrams: OrderBy
  createdAt: OrderBy
  date: OrderBy
  fatGrams: OrderBy
  id: OrderBy
  mealsAggregate: NutritionMealAggregateOrderBy
  order: OrderBy
  plan: NutritionPlanOrderBy
  planId: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  proteinGrams: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: nutrition_day"""
input NutritionDayPkColumnsInput {
  id: uuid!
}

"""
select columns of table "nutrition_day"
"""
enum NutritionDaySelectColumn {
  """column name"""
  createdAt

  """column name"""
  date

  """column name"""
  id

  """column name"""
  order

  """column name"""
  planId

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "nutrition_day"
"""
input NutritionDaySetInput {
  createdAt: timestamptz
  date: date
  id: uuid
  order: Int
  planId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type NutritionDayStddevFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by stddev() on columns of table "nutrition_day"
"""
input NutritionDayStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type NutritionDayStddevPopFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by stddevPop() on columns of table "nutrition_day"
"""
input NutritionDayStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type NutritionDayStddevSampFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by stddevSamp() on columns of table "nutrition_day"
"""
input NutritionDayStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "nutrition_day"
"""
input NutritionDayStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NutritionDayStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NutritionDayStreamCursorValueInput {
  createdAt: timestamptz
  date: date
  id: uuid
  order: Int
  planId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type NutritionDaySumFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Int

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by sum() on columns of table "nutrition_day"
"""
input NutritionDaySumOrderBy {
  order: OrderBy
}

"""
update columns of table "nutrition_day"
"""
enum NutritionDayUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  date

  """column name"""
  id

  """column name"""
  order

  """column name"""
  planId

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input NutritionDayUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: NutritionDayIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: NutritionDaySetInput

  """filter the rows which have to be updated"""
  where: NutritionDayBoolExp!
}

"""aggregate varPop on columns"""
type NutritionDayVarPopFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by varPop() on columns of table "nutrition_day"
"""
input NutritionDayVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type NutritionDayVarSampFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by varSamp() on columns of table "nutrition_day"
"""
input NutritionDayVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type NutritionDayVarianceFields {
  """
  A computed field, executes function "nutrition_day_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_day_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_day_total_fat_grams"
  """
  fatGrams: Int
  order: Float

  """
  A computed field, executes function "nutrition_day_total_protein_grams"
  """
  proteinGrams: Int
}

"""
order by variance() on columns of table "nutrition_day"
"""
input NutritionDayVarianceOrderBy {
  order: OrderBy
}

"""
columns and relationships of "nutrition_food"
"""
type NutritionFood {
  calories: Int!
  carbGrams: Int!
  createdAt: timestamptz!
  fatGrams: Int!
  id: uuid!
  isFavorite: Boolean!
  name: String!
  portionUnit: String!
  portionValue: numeric!
  profileId: uuid!
  proteinGrams: Int!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "nutrition_food"
"""
type NutritionFoodAggregate {
  aggregate: NutritionFoodAggregateFields
  nodes: [NutritionFood!]!
}

"""
aggregate fields of "nutrition_food"
"""
type NutritionFoodAggregateFields {
  avg: NutritionFoodAvgFields
  count(columns: [NutritionFoodSelectColumn!], distinct: Boolean): Int!
  max: NutritionFoodMaxFields
  min: NutritionFoodMinFields
  stddev: NutritionFoodStddevFields
  stddevPop: NutritionFoodStddevPopFields
  stddevSamp: NutritionFoodStddevSampFields
  sum: NutritionFoodSumFields
  varPop: NutritionFoodVarPopFields
  varSamp: NutritionFoodVarSampFields
  variance: NutritionFoodVarianceFields
}

"""aggregate avg on columns"""
type NutritionFoodAvgFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""
Boolean expression to filter rows from the table "nutrition_food". All fields are combined with a logical 'AND'.
"""
input NutritionFoodBoolExp {
  _and: [NutritionFoodBoolExp!]
  _not: NutritionFoodBoolExp
  _or: [NutritionFoodBoolExp!]
  calories: IntComparisonExp
  carbGrams: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  fatGrams: IntComparisonExp
  id: UuidComparisonExp
  isFavorite: BooleanComparisonExp
  name: StringComparisonExp
  portionUnit: StringComparisonExp
  portionValue: NumericComparisonExp
  profileId: UuidComparisonExp
  proteinGrams: IntComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "nutrition_food"
"""
enum NutritionFoodConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  nutrition_food_pkey
}

"""
input type for incrementing numeric columns in table "nutrition_food"
"""
input NutritionFoodIncInput {
  calories: Int
  carbGrams: Int
  fatGrams: Int
  portionValue: numeric
  proteinGrams: Int
}

"""
input type for inserting data into table "nutrition_food"
"""
input NutritionFoodInsertInput {
  calories: Int
  carbGrams: Int
  createdAt: timestamptz
  fatGrams: Int
  id: uuid
  isFavorite: Boolean
  name: String
  portionUnit: String
  portionValue: numeric
  profileId: uuid
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type NutritionFoodMaxFields {
  calories: Int
  carbGrams: Int
  createdAt: timestamptz
  fatGrams: Int
  id: uuid
  name: String
  portionUnit: String
  portionValue: numeric
  profileId: uuid
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type NutritionFoodMinFields {
  calories: Int
  carbGrams: Int
  createdAt: timestamptz
  fatGrams: Int
  id: uuid
  name: String
  portionUnit: String
  portionValue: numeric
  profileId: uuid
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "nutrition_food"
"""
type NutritionFoodMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [NutritionFood!]!
}

"""
input type for inserting object relation for remote table "nutrition_food"
"""
input NutritionFoodObjRelInsertInput {
  data: NutritionFoodInsertInput!

  """upsert condition"""
  onConflict: NutritionFoodOnConflict
}

"""
on_conflict condition type for table "nutrition_food"
"""
input NutritionFoodOnConflict {
  constraint: NutritionFoodConstraint!
  updateColumns: [NutritionFoodUpdateColumn!]! = []
  where: NutritionFoodBoolExp
}

"""Ordering options when selecting data from "nutrition_food"."""
input NutritionFoodOrderBy {
  calories: OrderBy
  carbGrams: OrderBy
  createdAt: OrderBy
  fatGrams: OrderBy
  id: OrderBy
  isFavorite: OrderBy
  name: OrderBy
  portionUnit: OrderBy
  portionValue: OrderBy
  profileId: OrderBy
  proteinGrams: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: nutrition_food"""
input NutritionFoodPkColumnsInput {
  id: uuid!
}

"""
select columns of table "nutrition_food"
"""
enum NutritionFoodSelectColumn {
  """column name"""
  calories

  """column name"""
  carbGrams

  """column name"""
  createdAt

  """column name"""
  fatGrams

  """column name"""
  id

  """column name"""
  isFavorite

  """column name"""
  name

  """column name"""
  portionUnit

  """column name"""
  portionValue

  """column name"""
  profileId

  """column name"""
  proteinGrams

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "nutrition_food"
"""
input NutritionFoodSetInput {
  calories: Int
  carbGrams: Int
  createdAt: timestamptz
  fatGrams: Int
  id: uuid
  isFavorite: Boolean
  name: String
  portionUnit: String
  portionValue: numeric
  profileId: uuid
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type NutritionFoodStddevFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""aggregate stddevPop on columns"""
type NutritionFoodStddevPopFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""aggregate stddevSamp on columns"""
type NutritionFoodStddevSampFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""
Streaming cursor of the table "nutrition_food"
"""
input NutritionFoodStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NutritionFoodStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NutritionFoodStreamCursorValueInput {
  calories: Int
  carbGrams: Int
  createdAt: timestamptz
  fatGrams: Int
  id: uuid
  isFavorite: Boolean
  name: String
  portionUnit: String
  portionValue: numeric
  profileId: uuid
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type NutritionFoodSumFields {
  calories: Int
  carbGrams: Int
  fatGrams: Int
  portionValue: numeric
  proteinGrams: Int
}

"""
update columns of table "nutrition_food"
"""
enum NutritionFoodUpdateColumn {
  """column name"""
  calories

  """column name"""
  carbGrams

  """column name"""
  createdAt

  """column name"""
  fatGrams

  """column name"""
  id

  """column name"""
  isFavorite

  """column name"""
  name

  """column name"""
  portionUnit

  """column name"""
  portionValue

  """column name"""
  profileId

  """column name"""
  proteinGrams

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input NutritionFoodUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: NutritionFoodIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: NutritionFoodSetInput

  """filter the rows which have to be updated"""
  where: NutritionFoodBoolExp!
}

"""aggregate varPop on columns"""
type NutritionFoodVarPopFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""aggregate varSamp on columns"""
type NutritionFoodVarSampFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""aggregate variance on columns"""
type NutritionFoodVarianceFields {
  calories: Float
  carbGrams: Float
  fatGrams: Float
  portionValue: Float
  proteinGrams: Float
}

"""
columns and relationships of "nutrition_meal"
"""
type NutritionMeal {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int
  createdAt: timestamptz!

  """An object relationship"""
  day: NutritionDay!
  dayId: uuid!

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int
  id: uuid!

  """An array relationship"""
  mealFoods(
    """distinct select on columns"""
    distinctOn: [NutritionMealFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): [NutritionMealFood!]!

  """An aggregate relationship"""
  mealFoodsAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionMealFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): NutritionMealFoodAggregate!
  name: String!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
  tenantId: String!
  time: time!
  updatedAt: timestamptz!
}

"""
aggregated selection of "nutrition_meal"
"""
type NutritionMealAggregate {
  aggregate: NutritionMealAggregateFields
  nodes: [NutritionMeal!]!
}

input NutritionMealAggregateBoolExp {
  count: nutritionMealAggregateBoolExpCount
}

"""
aggregate fields of "nutrition_meal"
"""
type NutritionMealAggregateFields {
  avg: NutritionMealAvgFields
  count(columns: [NutritionMealSelectColumn!], distinct: Boolean): Int!
  max: NutritionMealMaxFields
  min: NutritionMealMinFields
  stddev: NutritionMealStddevFields
  stddevPop: NutritionMealStddevPopFields
  stddevSamp: NutritionMealStddevSampFields
  sum: NutritionMealSumFields
  varPop: NutritionMealVarPopFields
  varSamp: NutritionMealVarSampFields
  variance: NutritionMealVarianceFields
}

"""
order by aggregate values of table "nutrition_meal"
"""
input NutritionMealAggregateOrderBy {
  count: OrderBy
  max: NutritionMealMaxOrderBy
  min: NutritionMealMinOrderBy
}

"""
input type for inserting array relation for remote table "nutrition_meal"
"""
input NutritionMealArrRelInsertInput {
  data: [NutritionMealInsertInput!]!

  """upsert condition"""
  onConflict: NutritionMealOnConflict
}

"""aggregate avg on columns"""
type NutritionMealAvgFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""
Boolean expression to filter rows from the table "nutrition_meal". All fields are combined with a logical 'AND'.
"""
input NutritionMealBoolExp {
  _and: [NutritionMealBoolExp!]
  _not: NutritionMealBoolExp
  _or: [NutritionMealBoolExp!]
  calories: IntComparisonExp
  carbGrams: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  day: NutritionDayBoolExp
  dayId: UuidComparisonExp
  fatGrams: IntComparisonExp
  id: UuidComparisonExp
  mealFoods: NutritionMealFoodBoolExp
  mealFoodsAggregate: NutritionMealFoodAggregateBoolExp
  name: StringComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  proteinGrams: IntComparisonExp
  tenantId: StringComparisonExp
  time: TimeComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "nutrition_meal"
"""
enum NutritionMealConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  nutrition_meal_pkey
}

"""
columns and relationships of "nutrition_meal_food"
"""
type NutritionMealFood {
  createdAt: timestamptz!

  """An object relationship"""
  food: NutritionFood!
  foodId: uuid!

  """An object relationship"""
  meal: NutritionMeal!
  mealId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "nutrition_meal_food"
"""
type NutritionMealFoodAggregate {
  aggregate: NutritionMealFoodAggregateFields
  nodes: [NutritionMealFood!]!
}

input NutritionMealFoodAggregateBoolExp {
  count: nutritionMealFoodAggregateBoolExpCount
}

"""
aggregate fields of "nutrition_meal_food"
"""
type NutritionMealFoodAggregateFields {
  count(columns: [NutritionMealFoodSelectColumn!], distinct: Boolean): Int!
  max: NutritionMealFoodMaxFields
  min: NutritionMealFoodMinFields
}

"""
order by aggregate values of table "nutrition_meal_food"
"""
input NutritionMealFoodAggregateOrderBy {
  count: OrderBy
  max: NutritionMealFoodMaxOrderBy
  min: NutritionMealFoodMinOrderBy
}

"""
input type for inserting array relation for remote table "nutrition_meal_food"
"""
input NutritionMealFoodArrRelInsertInput {
  data: [NutritionMealFoodInsertInput!]!

  """upsert condition"""
  onConflict: NutritionMealFoodOnConflict
}

"""
Boolean expression to filter rows from the table "nutrition_meal_food". All fields are combined with a logical 'AND'.
"""
input NutritionMealFoodBoolExp {
  _and: [NutritionMealFoodBoolExp!]
  _not: NutritionMealFoodBoolExp
  _or: [NutritionMealFoodBoolExp!]
  createdAt: TimestamptzComparisonExp
  food: NutritionFoodBoolExp
  foodId: UuidComparisonExp
  meal: NutritionMealBoolExp
  mealId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "nutrition_meal_food"
"""
enum NutritionMealFoodConstraint {
  """
  unique or primary key constraint on columns "food_id", "meal_id"
  """
  nutrition_meal_food_pkey
}

"""
input type for inserting data into table "nutrition_meal_food"
"""
input NutritionMealFoodInsertInput {
  createdAt: timestamptz
  food: NutritionFoodObjRelInsertInput
  foodId: uuid
  meal: NutritionMealObjRelInsertInput
  mealId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type NutritionMealFoodMaxFields {
  createdAt: timestamptz
  foodId: uuid
  mealId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "nutrition_meal_food"
"""
input NutritionMealFoodMaxOrderBy {
  createdAt: OrderBy
  foodId: OrderBy
  mealId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type NutritionMealFoodMinFields {
  createdAt: timestamptz
  foodId: uuid
  mealId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "nutrition_meal_food"
"""
input NutritionMealFoodMinOrderBy {
  createdAt: OrderBy
  foodId: OrderBy
  mealId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "nutrition_meal_food"
"""
type NutritionMealFoodMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [NutritionMealFood!]!
}

"""
on_conflict condition type for table "nutrition_meal_food"
"""
input NutritionMealFoodOnConflict {
  constraint: NutritionMealFoodConstraint!
  updateColumns: [NutritionMealFoodUpdateColumn!]! = []
  where: NutritionMealFoodBoolExp
}

"""Ordering options when selecting data from "nutrition_meal_food"."""
input NutritionMealFoodOrderBy {
  createdAt: OrderBy
  food: NutritionFoodOrderBy
  foodId: OrderBy
  meal: NutritionMealOrderBy
  mealId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: nutrition_meal_food"""
input NutritionMealFoodPkColumnsInput {
  foodId: uuid!
  mealId: uuid!
}

"""
select columns of table "nutrition_meal_food"
"""
enum NutritionMealFoodSelectColumn {
  """column name"""
  createdAt

  """column name"""
  foodId

  """column name"""
  mealId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "nutrition_meal_food"
"""
input NutritionMealFoodSetInput {
  createdAt: timestamptz
  foodId: uuid
  mealId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "nutrition_meal_food"
"""
input NutritionMealFoodStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NutritionMealFoodStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NutritionMealFoodStreamCursorValueInput {
  createdAt: timestamptz
  foodId: uuid
  mealId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "nutrition_meal_food"
"""
enum NutritionMealFoodUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  foodId

  """column name"""
  mealId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input NutritionMealFoodUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: NutritionMealFoodSetInput

  """filter the rows which have to be updated"""
  where: NutritionMealFoodBoolExp!
}

"""
input type for inserting data into table "nutrition_meal"
"""
input NutritionMealInsertInput {
  createdAt: timestamptz
  day: NutritionDayObjRelInsertInput
  dayId: uuid
  id: uuid
  mealFoods: NutritionMealFoodArrRelInsertInput
  name: String
  profile: ProfileObjRelInsertInput
  profileId: uuid
  tenantId: String
  time: time
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type NutritionMealMaxFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int
  createdAt: timestamptz
  dayId: uuid

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int
  id: uuid
  name: String
  profileId: uuid

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "nutrition_meal"
"""
input NutritionMealMaxOrderBy {
  createdAt: OrderBy
  dayId: OrderBy
  id: OrderBy
  name: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type NutritionMealMinFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int
  createdAt: timestamptz
  dayId: uuid

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int
  id: uuid
  name: String
  profileId: uuid

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "nutrition_meal"
"""
input NutritionMealMinOrderBy {
  createdAt: OrderBy
  dayId: OrderBy
  id: OrderBy
  name: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "nutrition_meal"
"""
type NutritionMealMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [NutritionMeal!]!
}

"""
input type for inserting object relation for remote table "nutrition_meal"
"""
input NutritionMealObjRelInsertInput {
  data: NutritionMealInsertInput!

  """upsert condition"""
  onConflict: NutritionMealOnConflict
}

"""
on_conflict condition type for table "nutrition_meal"
"""
input NutritionMealOnConflict {
  constraint: NutritionMealConstraint!
  updateColumns: [NutritionMealUpdateColumn!]! = []
  where: NutritionMealBoolExp
}

"""Ordering options when selecting data from "nutrition_meal"."""
input NutritionMealOrderBy {
  calories: OrderBy
  carbGrams: OrderBy
  createdAt: OrderBy
  day: NutritionDayOrderBy
  dayId: OrderBy
  fatGrams: OrderBy
  id: OrderBy
  mealFoodsAggregate: NutritionMealFoodAggregateOrderBy
  name: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  proteinGrams: OrderBy
  tenantId: OrderBy
  time: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: nutrition_meal"""
input NutritionMealPkColumnsInput {
  id: uuid!
}

"""
select columns of table "nutrition_meal"
"""
enum NutritionMealSelectColumn {
  """column name"""
  createdAt

  """column name"""
  dayId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  time

  """column name"""
  updatedAt
}

"""
input type for updating data in table "nutrition_meal"
"""
input NutritionMealSetInput {
  createdAt: timestamptz
  dayId: uuid
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  time: time
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type NutritionMealStddevFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""aggregate stddevPop on columns"""
type NutritionMealStddevPopFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""aggregate stddevSamp on columns"""
type NutritionMealStddevSampFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""
Streaming cursor of the table "nutrition_meal"
"""
input NutritionMealStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NutritionMealStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NutritionMealStreamCursorValueInput {
  createdAt: timestamptz
  dayId: uuid
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  time: time
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type NutritionMealSumFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""
update columns of table "nutrition_meal"
"""
enum NutritionMealUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  dayId

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  time

  """column name"""
  updatedAt
}

input NutritionMealUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: NutritionMealSetInput

  """filter the rows which have to be updated"""
  where: NutritionMealBoolExp!
}

"""aggregate varPop on columns"""
type NutritionMealVarPopFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""aggregate varSamp on columns"""
type NutritionMealVarSampFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""aggregate variance on columns"""
type NutritionMealVarianceFields {
  """
  A computed field, executes function "nutrition_meal_total_calories"
  """
  calories: Int

  """
  A computed field, executes function "nutrition_meal_total_carb_grams"
  """
  carbGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_fat_grams"
  """
  fatGrams: Int

  """
  A computed field, executes function "nutrition_meal_total_protein_grams"
  """
  proteinGrams: Int
}

"""
columns and relationships of "nutrition_plan"
"""
type NutritionPlan {
  createdAt: timestamptz!

  """An array relationship"""
  days(
    """distinct select on columns"""
    distinctOn: [NutritionDaySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionDayOrderBy!]

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): [NutritionDay!]!

  """An aggregate relationship"""
  daysAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionDaySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionDayOrderBy!]

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): NutritionDayAggregate!
  id: uuid!
  name: String!
  profileId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "nutrition_plan"
"""
type NutritionPlanAggregate {
  aggregate: NutritionPlanAggregateFields
  nodes: [NutritionPlan!]!
}

"""
aggregate fields of "nutrition_plan"
"""
type NutritionPlanAggregateFields {
  count(columns: [NutritionPlanSelectColumn!], distinct: Boolean): Int!
  max: NutritionPlanMaxFields
  min: NutritionPlanMinFields
}

"""
Boolean expression to filter rows from the table "nutrition_plan". All fields are combined with a logical 'AND'.
"""
input NutritionPlanBoolExp {
  _and: [NutritionPlanBoolExp!]
  _not: NutritionPlanBoolExp
  _or: [NutritionPlanBoolExp!]
  createdAt: TimestamptzComparisonExp
  days: NutritionDayBoolExp
  daysAggregate: NutritionDayAggregateBoolExp
  id: UuidComparisonExp
  name: StringComparisonExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "nutrition_plan"
"""
enum NutritionPlanConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  nutrition_plan_pkey
}

"""
input type for inserting data into table "nutrition_plan"
"""
input NutritionPlanInsertInput {
  createdAt: timestamptz
  days: NutritionDayArrRelInsertInput
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type NutritionPlanMaxFields {
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type NutritionPlanMinFields {
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "nutrition_plan"
"""
type NutritionPlanMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [NutritionPlan!]!
}

"""
input type for inserting object relation for remote table "nutrition_plan"
"""
input NutritionPlanObjRelInsertInput {
  data: NutritionPlanInsertInput!

  """upsert condition"""
  onConflict: NutritionPlanOnConflict
}

"""
on_conflict condition type for table "nutrition_plan"
"""
input NutritionPlanOnConflict {
  constraint: NutritionPlanConstraint!
  updateColumns: [NutritionPlanUpdateColumn!]! = []
  where: NutritionPlanBoolExp
}

"""Ordering options when selecting data from "nutrition_plan"."""
input NutritionPlanOrderBy {
  createdAt: OrderBy
  daysAggregate: NutritionDayAggregateOrderBy
  id: OrderBy
  name: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: nutrition_plan"""
input NutritionPlanPkColumnsInput {
  id: uuid!
}

"""
select columns of table "nutrition_plan"
"""
enum NutritionPlanSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "nutrition_plan"
"""
input NutritionPlanSetInput {
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "nutrition_plan"
"""
input NutritionPlanStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NutritionPlanStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NutritionPlanStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  name: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "nutrition_plan"
"""
enum NutritionPlanUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input NutritionPlanUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: NutritionPlanSetInput

  """filter the rows which have to be updated"""
  where: NutritionPlanBoolExp!
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "post"
"""
type Post {
  body: String

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): [PostComment!]!

  """An aggregate relationship"""
  commentsAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): PostCommentAggregate!
  createdAt: timestamptz!
  id: uuid!
  isDeleted: Boolean!
  kind: String!

  """An array relationship"""
  mediaItems(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): [PostMediaItem!]!

  """An aggregate relationship"""
  mediaItemsAggregate(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): PostMediaItemAggregate!

  """An array relationship"""
  postMediaItems(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): [PostMediaItem!]!

  """An aggregate relationship"""
  postMediaItemsAggregate(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): PostMediaItemAggregate!
  postedToProfileId: uuid!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!

  """An array relationship"""
  reactions(
    """distinct select on columns"""
    distinctOn: [PostReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionOrderBy!]

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): [PostReaction!]!

  """An aggregate relationship"""
  reactionsAggregate(
    """distinct select on columns"""
    distinctOn: [PostReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionOrderBy!]

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): PostReactionAggregate!
  tenantId: String!
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "post"
"""
type PostAggregate {
  aggregate: PostAggregateFields
  nodes: [Post!]!
}

input PostAggregateBoolExp {
  bool_and: postAggregateBoolExpBool_and
  bool_or: postAggregateBoolExpBool_or
  count: postAggregateBoolExpCount
}

"""
aggregate fields of "post"
"""
type PostAggregateFields {
  count(columns: [PostSelectColumn!], distinct: Boolean): Int!
  max: PostMaxFields
  min: PostMinFields
}

"""
order by aggregate values of table "post"
"""
input PostAggregateOrderBy {
  count: OrderBy
  max: PostMaxOrderBy
  min: PostMinOrderBy
}

"""
input type for inserting array relation for remote table "post"
"""
input PostArrRelInsertInput {
  data: [PostInsertInput!]!

  """upsert condition"""
  onConflict: PostOnConflict
}

"""
Boolean expression to filter rows from the table "post". All fields are combined with a logical 'AND'.
"""
input PostBoolExp {
  _and: [PostBoolExp!]
  _not: PostBoolExp
  _or: [PostBoolExp!]
  body: StringComparisonExp
  comments: PostCommentBoolExp
  commentsAggregate: PostCommentAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isDeleted: BooleanComparisonExp
  kind: StringComparisonExp
  mediaItems: PostMediaItemBoolExp
  mediaItemsAggregate: PostMediaItemAggregateBoolExp
  postMediaItems: PostMediaItemBoolExp
  postMediaItemsAggregate: PostMediaItemAggregateBoolExp
  postedToProfileId: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  reactions: PostReactionBoolExp
  reactionsAggregate: PostReactionAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
columns and relationships of "post_comment"
"""
type PostComment {
  body: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  post: Post!
  postId: uuid!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!

  """An array relationship"""
  reactions(
    """distinct select on columns"""
    distinctOn: [PostCommentReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentReactionOrderBy!]

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): [PostCommentReaction!]!

  """An aggregate relationship"""
  reactionsAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentReactionOrderBy!]

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): PostCommentReactionAggregate!

  """An array relationship"""
  replies(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): [PostComment!]!

  """An aggregate relationship"""
  repliesAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): PostCommentAggregate!
  replyToCommentId: uuid
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_comment"
"""
type PostCommentAggregate {
  aggregate: PostCommentAggregateFields
  nodes: [PostComment!]!
}

input PostCommentAggregateBoolExp {
  count: postCommentAggregateBoolExpCount
}

"""
aggregate fields of "post_comment"
"""
type PostCommentAggregateFields {
  count(columns: [PostCommentSelectColumn!], distinct: Boolean): Int!
  max: PostCommentMaxFields
  min: PostCommentMinFields
}

"""
order by aggregate values of table "post_comment"
"""
input PostCommentAggregateOrderBy {
  count: OrderBy
  max: PostCommentMaxOrderBy
  min: PostCommentMinOrderBy
}

"""
input type for inserting array relation for remote table "post_comment"
"""
input PostCommentArrRelInsertInput {
  data: [PostCommentInsertInput!]!

  """upsert condition"""
  onConflict: PostCommentOnConflict
}

"""
Boolean expression to filter rows from the table "post_comment". All fields are combined with a logical 'AND'.
"""
input PostCommentBoolExp {
  _and: [PostCommentBoolExp!]
  _not: PostCommentBoolExp
  _or: [PostCommentBoolExp!]
  body: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  post: PostBoolExp
  postId: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  reactions: PostCommentReactionBoolExp
  reactionsAggregate: PostCommentReactionAggregateBoolExp
  replies: PostCommentBoolExp
  repliesAggregate: PostCommentAggregateBoolExp
  replyToCommentId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_comment"
"""
enum PostCommentConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_comment_pkey
}

"""
input type for inserting data into table "post_comment"
"""
input PostCommentInsertInput {
  body: String
  createdAt: timestamptz
  id: uuid
  post: PostObjRelInsertInput
  postId: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  reactions: PostCommentReactionArrRelInsertInput
  replies: PostCommentArrRelInsertInput
  replyToCommentId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PostCommentMaxFields {
  body: String
  createdAt: timestamptz
  id: uuid
  postId: uuid
  profileId: uuid
  replyToCommentId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "post_comment"
"""
input PostCommentMaxOrderBy {
  body: OrderBy
  createdAt: OrderBy
  id: OrderBy
  postId: OrderBy
  profileId: OrderBy
  replyToCommentId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PostCommentMinFields {
  body: String
  createdAt: timestamptz
  id: uuid
  postId: uuid
  profileId: uuid
  replyToCommentId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "post_comment"
"""
input PostCommentMinOrderBy {
  body: OrderBy
  createdAt: OrderBy
  id: OrderBy
  postId: OrderBy
  profileId: OrderBy
  replyToCommentId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "post_comment"
"""
type PostCommentMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostComment!]!
}

"""
on_conflict condition type for table "post_comment"
"""
input PostCommentOnConflict {
  constraint: PostCommentConstraint!
  updateColumns: [PostCommentUpdateColumn!]! = []
  where: PostCommentBoolExp
}

"""Ordering options when selecting data from "post_comment"."""
input PostCommentOrderBy {
  body: OrderBy
  createdAt: OrderBy
  id: OrderBy
  post: PostOrderBy
  postId: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  reactionsAggregate: PostCommentReactionAggregateOrderBy
  repliesAggregate: PostCommentAggregateOrderBy
  replyToCommentId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_comment"""
input PostCommentPkColumnsInput {
  id: uuid!
}

"""
columns and relationships of "post_comment_reaction"
"""
type PostCommentReaction {
  commentId: uuid!
  createdAt: timestamptz!

  """An object relationship"""
  profile: Profile
  profileId: uuid!
  reactionId: String!

  """An array relationship"""
  reactions(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): [PostComment!]!

  """An aggregate relationship"""
  reactionsAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): PostCommentAggregate!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_comment_reaction"
"""
type PostCommentReactionAggregate {
  aggregate: PostCommentReactionAggregateFields
  nodes: [PostCommentReaction!]!
}

input PostCommentReactionAggregateBoolExp {
  count: postCommentReactionAggregateBoolExpCount
}

"""
aggregate fields of "post_comment_reaction"
"""
type PostCommentReactionAggregateFields {
  count(columns: [PostCommentReactionSelectColumn!], distinct: Boolean): Int!
  max: PostCommentReactionMaxFields
  min: PostCommentReactionMinFields
}

"""
order by aggregate values of table "post_comment_reaction"
"""
input PostCommentReactionAggregateOrderBy {
  count: OrderBy
  max: PostCommentReactionMaxOrderBy
  min: PostCommentReactionMinOrderBy
}

"""
input type for inserting array relation for remote table "post_comment_reaction"
"""
input PostCommentReactionArrRelInsertInput {
  data: [PostCommentReactionInsertInput!]!

  """upsert condition"""
  onConflict: PostCommentReactionOnConflict
}

"""
Boolean expression to filter rows from the table "post_comment_reaction". All fields are combined with a logical 'AND'.
"""
input PostCommentReactionBoolExp {
  _and: [PostCommentReactionBoolExp!]
  _not: PostCommentReactionBoolExp
  _or: [PostCommentReactionBoolExp!]
  commentId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  reactionId: StringComparisonExp
  reactions: PostCommentBoolExp
  reactionsAggregate: PostCommentAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_comment_reaction"
"""
enum PostCommentReactionConstraint {
  """
  unique or primary key constraint on columns "comment_id", "profile_id"
  """
  post_comment_reaction_pkey
}

"""
input type for inserting data into table "post_comment_reaction"
"""
input PostCommentReactionInsertInput {
  commentId: uuid
  createdAt: timestamptz
  profile: ProfileObjRelInsertInput
  profileId: uuid
  reactionId: String
  reactions: PostCommentArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PostCommentReactionMaxFields {
  commentId: uuid
  createdAt: timestamptz
  profileId: uuid
  reactionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "post_comment_reaction"
"""
input PostCommentReactionMaxOrderBy {
  commentId: OrderBy
  createdAt: OrderBy
  profileId: OrderBy
  reactionId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PostCommentReactionMinFields {
  commentId: uuid
  createdAt: timestamptz
  profileId: uuid
  reactionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "post_comment_reaction"
"""
input PostCommentReactionMinOrderBy {
  commentId: OrderBy
  createdAt: OrderBy
  profileId: OrderBy
  reactionId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "post_comment_reaction"
"""
type PostCommentReactionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostCommentReaction!]!
}

"""
on_conflict condition type for table "post_comment_reaction"
"""
input PostCommentReactionOnConflict {
  constraint: PostCommentReactionConstraint!
  updateColumns: [PostCommentReactionUpdateColumn!]! = []
  where: PostCommentReactionBoolExp
}

"""Ordering options when selecting data from "post_comment_reaction"."""
input PostCommentReactionOrderBy {
  commentId: OrderBy
  createdAt: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  reactionId: OrderBy
  reactionsAggregate: PostCommentAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_comment_reaction"""
input PostCommentReactionPkColumnsInput {
  commentId: uuid!
  profileId: uuid!
}

"""
select columns of table "post_comment_reaction"
"""
enum PostCommentReactionSelectColumn {
  """column name"""
  commentId

  """column name"""
  createdAt

  """column name"""
  profileId

  """column name"""
  reactionId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_comment_reaction"
"""
input PostCommentReactionSetInput {
  commentId: uuid
  createdAt: timestamptz
  profileId: uuid
  reactionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_comment_reaction"
"""
input PostCommentReactionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostCommentReactionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostCommentReactionStreamCursorValueInput {
  commentId: uuid
  createdAt: timestamptz
  profileId: uuid
  reactionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_comment_reaction"
"""
enum PostCommentReactionUpdateColumn {
  """column name"""
  commentId

  """column name"""
  createdAt

  """column name"""
  profileId

  """column name"""
  reactionId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostCommentReactionUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostCommentReactionSetInput

  """filter the rows which have to be updated"""
  where: PostCommentReactionBoolExp!
}

"""
select columns of table "post_comment"
"""
enum PostCommentSelectColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  postId

  """column name"""
  profileId

  """column name"""
  replyToCommentId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_comment"
"""
input PostCommentSetInput {
  body: String
  createdAt: timestamptz
  id: uuid
  postId: uuid
  profileId: uuid
  replyToCommentId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_comment"
"""
input PostCommentStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostCommentStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostCommentStreamCursorValueInput {
  body: String
  createdAt: timestamptz
  id: uuid
  postId: uuid
  profileId: uuid
  replyToCommentId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_comment"
"""
enum PostCommentUpdateColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  postId

  """column name"""
  profileId

  """column name"""
  replyToCommentId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostCommentUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostCommentSetInput

  """filter the rows which have to be updated"""
  where: PostCommentBoolExp!
}

"""
unique or primary key constraints on table "post"
"""
enum PostConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_pkey
}

"""
input type for inserting data into table "post"
"""
input PostInsertInput {
  body: String
  comments: PostCommentArrRelInsertInput
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: String
  mediaItems: PostMediaItemArrRelInsertInput
  postMediaItems: PostMediaItemArrRelInsertInput
  postedToProfileId: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  reactions: PostReactionArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "post_kind"
"""
type PostKind {
  createdAt: timestamptz!
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_kind"
"""
type PostKindAggregate {
  aggregate: PostKindAggregateFields
  nodes: [PostKind!]!
}

"""
aggregate fields of "post_kind"
"""
type PostKindAggregateFields {
  count(columns: [PostKindSelectColumn!], distinct: Boolean): Int!
  max: PostKindMaxFields
  min: PostKindMinFields
}

"""
Boolean expression to filter rows from the table "post_kind". All fields are combined with a logical 'AND'.
"""
input PostKindBoolExp {
  _and: [PostKindBoolExp!]
  _not: PostKindBoolExp
  _or: [PostKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_kind"
"""
enum PostKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  post_kind_pkey
}

"""
input type for inserting data into table "post_kind"
"""
input PostKindInsertInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PostKindMaxFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type PostKindMinFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "post_kind"
"""
type PostKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostKind!]!
}

"""
on_conflict condition type for table "post_kind"
"""
input PostKindOnConflict {
  constraint: PostKindConstraint!
  updateColumns: [PostKindUpdateColumn!]! = []
  where: PostKindBoolExp
}

"""Ordering options when selecting data from "post_kind"."""
input PostKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_kind"""
input PostKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "post_kind"
"""
enum PostKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_kind"
"""
input PostKindSetInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_kind"
"""
input PostKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostKindStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_kind"
"""
enum PostKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostKindSetInput

  """filter the rows which have to be updated"""
  where: PostKindBoolExp!
}

"""aggregate max on columns"""
type PostMaxFields {
  body: String
  createdAt: timestamptz
  id: uuid
  kind: String
  postedToProfileId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "post"
"""
input PostMaxOrderBy {
  body: OrderBy
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  postedToProfileId: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
columns and relationships of "post_media_item"
"""
type PostMediaItem {
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  mediaItem: MediaItem!
  mediaItemId: String!

  """An object relationship"""
  post: Post!
  postId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_media_item"
"""
type PostMediaItemAggregate {
  aggregate: PostMediaItemAggregateFields
  nodes: [PostMediaItem!]!
}

input PostMediaItemAggregateBoolExp {
  count: postMediaItemAggregateBoolExpCount
}

"""
aggregate fields of "post_media_item"
"""
type PostMediaItemAggregateFields {
  count(columns: [PostMediaItemSelectColumn!], distinct: Boolean): Int!
  max: PostMediaItemMaxFields
  min: PostMediaItemMinFields
}

"""
order by aggregate values of table "post_media_item"
"""
input PostMediaItemAggregateOrderBy {
  count: OrderBy
  max: PostMediaItemMaxOrderBy
  min: PostMediaItemMinOrderBy
}

"""
input type for inserting array relation for remote table "post_media_item"
"""
input PostMediaItemArrRelInsertInput {
  data: [PostMediaItemInsertInput!]!

  """upsert condition"""
  onConflict: PostMediaItemOnConflict
}

"""
Boolean expression to filter rows from the table "post_media_item". All fields are combined with a logical 'AND'.
"""
input PostMediaItemBoolExp {
  _and: [PostMediaItemBoolExp!]
  _not: PostMediaItemBoolExp
  _or: [PostMediaItemBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  mediaItem: MediaItemBoolExp
  mediaItemId: StringComparisonExp
  post: PostBoolExp
  postId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_media_item"
"""
enum PostMediaItemConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  post_media_pkey
}

"""
input type for inserting data into table "post_media_item"
"""
input PostMediaItemInsertInput {
  createdAt: timestamptz
  id: uuid
  mediaItem: MediaItemObjRelInsertInput
  mediaItemId: String
  post: PostObjRelInsertInput
  postId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PostMediaItemMaxFields {
  createdAt: timestamptz
  id: uuid
  mediaItemId: String
  postId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "post_media_item"
"""
input PostMediaItemMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  mediaItemId: OrderBy
  postId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PostMediaItemMinFields {
  createdAt: timestamptz
  id: uuid
  mediaItemId: String
  postId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "post_media_item"
"""
input PostMediaItemMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  mediaItemId: OrderBy
  postId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "post_media_item"
"""
type PostMediaItemMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostMediaItem!]!
}

"""
on_conflict condition type for table "post_media_item"
"""
input PostMediaItemOnConflict {
  constraint: PostMediaItemConstraint!
  updateColumns: [PostMediaItemUpdateColumn!]! = []
  where: PostMediaItemBoolExp
}

"""Ordering options when selecting data from "post_media_item"."""
input PostMediaItemOrderBy {
  createdAt: OrderBy
  id: OrderBy
  mediaItem: MediaItemOrderBy
  mediaItemId: OrderBy
  post: PostOrderBy
  postId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_media_item"""
input PostMediaItemPkColumnsInput {
  id: uuid!
}

"""
select columns of table "post_media_item"
"""
enum PostMediaItemSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  mediaItemId

  """column name"""
  postId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_media_item"
"""
input PostMediaItemSetInput {
  createdAt: timestamptz
  id: uuid
  mediaItemId: String
  postId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_media_item"
"""
input PostMediaItemStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostMediaItemStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostMediaItemStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  mediaItemId: String
  postId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_media_item"
"""
enum PostMediaItemUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  mediaItemId

  """column name"""
  postId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostMediaItemUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostMediaItemSetInput

  """filter the rows which have to be updated"""
  where: PostMediaItemBoolExp!
}

"""aggregate min on columns"""
type PostMinFields {
  body: String
  createdAt: timestamptz
  id: uuid
  kind: String
  postedToProfileId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "post"
"""
input PostMinOrderBy {
  body: OrderBy
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  postedToProfileId: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "post"
"""
type PostMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Post!]!
}

"""
input type for inserting object relation for remote table "post"
"""
input PostObjRelInsertInput {
  data: PostInsertInput!

  """upsert condition"""
  onConflict: PostOnConflict
}

"""
on_conflict condition type for table "post"
"""
input PostOnConflict {
  constraint: PostConstraint!
  updateColumns: [PostUpdateColumn!]! = []
  where: PostBoolExp
}

"""Ordering options when selecting data from "post"."""
input PostOrderBy {
  body: OrderBy
  commentsAggregate: PostCommentAggregateOrderBy
  createdAt: OrderBy
  id: OrderBy
  isDeleted: OrderBy
  kind: OrderBy
  mediaItemsAggregate: PostMediaItemAggregateOrderBy
  postMediaItemsAggregate: PostMediaItemAggregateOrderBy
  postedToProfileId: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  reactionsAggregate: PostReactionAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: post"""
input PostPkColumnsInput {
  id: uuid!
}

"""
columns and relationships of "post_reaction"
"""
type PostReaction {
  createdAt: timestamptz!
  kind: String!
  postId: uuid!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_reaction"
"""
type PostReactionAggregate {
  aggregate: PostReactionAggregateFields
  nodes: [PostReaction!]!
}

input PostReactionAggregateBoolExp {
  count: postReactionAggregateBoolExpCount
}

"""
aggregate fields of "post_reaction"
"""
type PostReactionAggregateFields {
  count(columns: [PostReactionSelectColumn!], distinct: Boolean): Int!
  max: PostReactionMaxFields
  min: PostReactionMinFields
}

"""
order by aggregate values of table "post_reaction"
"""
input PostReactionAggregateOrderBy {
  count: OrderBy
  max: PostReactionMaxOrderBy
  min: PostReactionMinOrderBy
}

"""
input type for inserting array relation for remote table "post_reaction"
"""
input PostReactionArrRelInsertInput {
  data: [PostReactionInsertInput!]!

  """upsert condition"""
  onConflict: PostReactionOnConflict
}

"""
Boolean expression to filter rows from the table "post_reaction". All fields are combined with a logical 'AND'.
"""
input PostReactionBoolExp {
  _and: [PostReactionBoolExp!]
  _not: PostReactionBoolExp
  _or: [PostReactionBoolExp!]
  createdAt: TimestamptzComparisonExp
  kind: StringComparisonExp
  postId: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_reaction"
"""
enum PostReactionConstraint {
  """
  unique or primary key constraint on columns "post_id", "kind", "profile_id"
  """
  post_reaction_pkey
}

"""
input type for inserting data into table "post_reaction"
"""
input PostReactionInsertInput {
  createdAt: timestamptz
  kind: String
  postId: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "post_reaction_kind"
"""
type PostReactionKind {
  createdAt: timestamptz!
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_reaction_kind"
"""
type PostReactionKindAggregate {
  aggregate: PostReactionKindAggregateFields
  nodes: [PostReactionKind!]!
}

"""
aggregate fields of "post_reaction_kind"
"""
type PostReactionKindAggregateFields {
  count(columns: [PostReactionKindSelectColumn!], distinct: Boolean): Int!
  max: PostReactionKindMaxFields
  min: PostReactionKindMinFields
}

"""
Boolean expression to filter rows from the table "post_reaction_kind". All fields are combined with a logical 'AND'.
"""
input PostReactionKindBoolExp {
  _and: [PostReactionKindBoolExp!]
  _not: PostReactionKindBoolExp
  _or: [PostReactionKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_reaction_kind"
"""
enum PostReactionKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  post_reaction_kind_pkey
}

"""
input type for inserting data into table "post_reaction_kind"
"""
input PostReactionKindInsertInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PostReactionKindMaxFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type PostReactionKindMinFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "post_reaction_kind"
"""
type PostReactionKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostReactionKind!]!
}

"""
on_conflict condition type for table "post_reaction_kind"
"""
input PostReactionKindOnConflict {
  constraint: PostReactionKindConstraint!
  updateColumns: [PostReactionKindUpdateColumn!]! = []
  where: PostReactionKindBoolExp
}

"""Ordering options when selecting data from "post_reaction_kind"."""
input PostReactionKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_reaction_kind"""
input PostReactionKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "post_reaction_kind"
"""
enum PostReactionKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_reaction_kind"
"""
input PostReactionKindSetInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_reaction_kind"
"""
input PostReactionKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostReactionKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostReactionKindStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_reaction_kind"
"""
enum PostReactionKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostReactionKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostReactionKindSetInput

  """filter the rows which have to be updated"""
  where: PostReactionKindBoolExp!
}

"""aggregate max on columns"""
type PostReactionMaxFields {
  createdAt: timestamptz
  kind: String
  postId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "post_reaction"
"""
input PostReactionMaxOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  postId: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PostReactionMinFields {
  createdAt: timestamptz
  kind: String
  postId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "post_reaction"
"""
input PostReactionMinOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  postId: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "post_reaction"
"""
type PostReactionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostReaction!]!
}

"""
on_conflict condition type for table "post_reaction"
"""
input PostReactionOnConflict {
  constraint: PostReactionConstraint!
  updateColumns: [PostReactionUpdateColumn!]! = []
  where: PostReactionBoolExp
}

"""Ordering options when selecting data from "post_reaction"."""
input PostReactionOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  postId: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_reaction"""
input PostReactionPkColumnsInput {
  kind: String!
  postId: uuid!
  profileId: uuid!
}

"""
select columns of table "post_reaction"
"""
enum PostReactionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  kind

  """column name"""
  postId

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_reaction"
"""
input PostReactionSetInput {
  createdAt: timestamptz
  kind: String
  postId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_reaction"
"""
input PostReactionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostReactionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostReactionStreamCursorValueInput {
  createdAt: timestamptz
  kind: String
  postId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_reaction"
"""
enum PostReactionUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  kind

  """column name"""
  postId

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostReactionUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostReactionSetInput

  """filter the rows which have to be updated"""
  where: PostReactionBoolExp!
}

"""
select columns of table "post"
"""
enum PostSelectColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  postedToProfileId

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

"""
select "postAggregateBoolExpBool_andArgumentsColumns" columns of table "post"
"""
enum PostSelectColumnPostAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isDeleted
}

"""
select "postAggregateBoolExpBool_orArgumentsColumns" columns of table "post"
"""
enum PostSelectColumnPostAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isDeleted
}

"""
input type for updating data in table "post"
"""
input PostSetInput {
  body: String
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: String
  postedToProfileId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
Streaming cursor of the table "post"
"""
input PostStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostStreamCursorValueInput {
  body: String
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: String
  postedToProfileId: uuid
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "post_tag"
"""
type PostTag {
  createdAt: timestamptz!
  postId: uuid!
  tag: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "post_tag"
"""
type PostTagAggregate {
  aggregate: PostTagAggregateFields
  nodes: [PostTag!]!
}

"""
aggregate fields of "post_tag"
"""
type PostTagAggregateFields {
  count(columns: [PostTagSelectColumn!], distinct: Boolean): Int!
  max: PostTagMaxFields
  min: PostTagMinFields
}

"""
Boolean expression to filter rows from the table "post_tag". All fields are combined with a logical 'AND'.
"""
input PostTagBoolExp {
  _and: [PostTagBoolExp!]
  _not: PostTagBoolExp
  _or: [PostTagBoolExp!]
  createdAt: TimestamptzComparisonExp
  postId: UuidComparisonExp
  tag: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "post_tag"
"""
enum PostTagConstraint {
  """
  unique or primary key constraint on columns "tag", "post_id"
  """
  post_tag_pkey
}

"""
input type for inserting data into table "post_tag"
"""
input PostTagInsertInput {
  createdAt: timestamptz
  postId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PostTagMaxFields {
  createdAt: timestamptz
  postId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type PostTagMinFields {
  createdAt: timestamptz
  postId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "post_tag"
"""
type PostTagMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [PostTag!]!
}

"""
on_conflict condition type for table "post_tag"
"""
input PostTagOnConflict {
  constraint: PostTagConstraint!
  updateColumns: [PostTagUpdateColumn!]! = []
  where: PostTagBoolExp
}

"""Ordering options when selecting data from "post_tag"."""
input PostTagOrderBy {
  createdAt: OrderBy
  postId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: post_tag"""
input PostTagPkColumnsInput {
  postId: uuid!
  tag: String!
}

"""
select columns of table "post_tag"
"""
enum PostTagSelectColumn {
  """column name"""
  createdAt

  """column name"""
  postId

  """column name"""
  tag

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "post_tag"
"""
input PostTagSetInput {
  createdAt: timestamptz
  postId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "post_tag"
"""
input PostTagStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostTagStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostTagStreamCursorValueInput {
  createdAt: timestamptz
  postId: uuid
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "post_tag"
"""
enum PostTagUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  postId

  """column name"""
  tag

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input PostTagUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostTagSetInput

  """filter the rows which have to be updated"""
  where: PostTagBoolExp!
}

"""
update columns of table "post"
"""
enum PostUpdateColumn {
  """column name"""
  body

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  postedToProfileId

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  visibility
}

input PostUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PostSetInput

  """filter the rows which have to be updated"""
  where: PostBoolExp!
}

"""
columns and relationships of "profile"
"""
type Profile {
  """typically a device id the anonymous user registered with"""
  anonymousId: String

  """An array relationship"""
  attributes(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!

  """An aggregate relationship"""
  attributesAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): ProfileAttributeAggregate!
  bio: String

  """An array relationship"""
  childProfileNodes(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]

    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!

  """An aggregate relationship"""
  childProfileNodesAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]

    """filter the rows returned"""
    where: ProfileBoolExp
  ): ProfileAggregate!
  createdAt: timestamptz!

  """An array relationship"""
  devices(
    """distinct select on columns"""
    distinctOn: [ProfileDeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileDeviceOrderBy!]

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): [ProfileDevice!]!

  """An aggregate relationship"""
  devicesAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileDeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileDeviceOrderBy!]

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): ProfileDeviceAggregate!

  """
  A computed field, executes function "display_name"
  """
  displayName: String
  displayNameOverride: String
  facebookUsername: String

  """An array relationship"""
  followedProfiles(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!

  """An aggregate relationship"""
  followedProfilesAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!

  """An array relationship"""
  followers(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!

  """An aggregate relationship"""
  followersAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!
  id: uuid!

  """An object relationship"""
  identity: ProfileIdentity
  instagramUsername: String
  isDeleted: Boolean!
  kind: String!
  level: Int

  """An object relationship"""
  location: GeoLocation
  locationId: uuid

  """An array relationship"""
  logs(
    """distinct select on columns"""
    distinctOn: [LogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogOrderBy!]

    """filter the rows returned"""
    where: LogBoolExp
  ): [Log!]!

  """An aggregate relationship"""
  logsAggregate(
    """distinct select on columns"""
    distinctOn: [LogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogOrderBy!]

    """filter the rows returned"""
    where: LogBoolExp
  ): LogAggregate!

  """An array relationship"""
  managedProfiles(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): [ProfileManager!]!

  """An aggregate relationship"""
  managedProfilesAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): ProfileManagerAggregate!
  metaData(
    """JSON select path"""
    path: String
  ): jsonb!

  """An array relationship"""
  optIns(
    """distinct select on columns"""
    distinctOn: [ContactOptInSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ContactOptInOrderBy!]

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): [ContactOptIn!]!

  """An aggregate relationship"""
  optInsAggregate(
    """distinct select on columns"""
    distinctOn: [ContactOptInSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ContactOptInOrderBy!]

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): ContactOptInAggregate!

  """An array relationship"""
  orders(
    """distinct select on columns"""
    distinctOn: [ShopOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderOrderBy!]

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): [ShopOrder!]!

  """An aggregate relationship"""
  ordersAggregate(
    """distinct select on columns"""
    distinctOn: [ShopOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderOrderBy!]

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): ShopOrderAggregate!
  parentNodeId: uuid

  """An object relationship"""
  parentProfileNode: Profile

  """An object relationship"""
  photo: MediaItem
  photoId: String

  """An array relationship"""
  postsCreated(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): [Post!]!

  """An aggregate relationship"""
  postsCreatedAggregate(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): PostAggregate!

  """An array relationship"""
  postsToProfile(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): [Post!]!

  """An aggregate relationship"""
  postsToProfileAggregate(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): PostAggregate!

  """An array relationship"""
  profileManagers(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): [ProfileManager!]!

  """An aggregate relationship"""
  profileManagersAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): ProfileManagerAggregate!

  """An array relationship"""
  profileStats(
    """distinct select on columns"""
    distinctOn: [ProfileStatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatOrderBy!]

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): [ProfileStat!]!

  """An aggregate relationship"""
  profileStatsAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileStatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatOrderBy!]

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): ProfileStatAggregate!

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinctOn: [AuthSessionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthSessionOrderBy!]

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): [AuthSession!]!

  """An aggregate relationship"""
  sessionsAggregate(
    """distinct select on columns"""
    distinctOn: [AuthSessionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthSessionOrderBy!]

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): AuthSessionAggregate!
  startDate: date

  """An array relationship"""
  subscriptions(
    """distinct select on columns"""
    distinctOn: [ShopSubscriptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopSubscriptionOrderBy!]

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): [ShopSubscription!]!

  """An aggregate relationship"""
  subscriptionsAggregate(
    """distinct select on columns"""
    distinctOn: [ShopSubscriptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopSubscriptionOrderBy!]

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): ShopSubscriptionAggregate!

  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  tiktokUsername: String
  updatedAt: timestamptz!
  username: citext!
  xUsername: String
}

"""
aggregated selection of "profile"
"""
type ProfileAggregate {
  aggregate: ProfileAggregateFields
  nodes: [Profile!]!
}

input ProfileAggregateBoolExp {
  bool_and: profileAggregateBoolExpBool_and
  bool_or: profileAggregateBoolExpBool_or
  count: profileAggregateBoolExpCount
}

"""
aggregate fields of "profile"
"""
type ProfileAggregateFields {
  avg: ProfileAvgFields
  count(columns: [ProfileSelectColumn!], distinct: Boolean): Int!
  max: ProfileMaxFields
  min: ProfileMinFields
  stddev: ProfileStddevFields
  stddevPop: ProfileStddevPopFields
  stddevSamp: ProfileStddevSampFields
  sum: ProfileSumFields
  varPop: ProfileVarPopFields
  varSamp: ProfileVarSampFields
  variance: ProfileVarianceFields
}

"""
order by aggregate values of table "profile"
"""
input ProfileAggregateOrderBy {
  avg: ProfileAvgOrderBy
  count: OrderBy
  max: ProfileMaxOrderBy
  min: ProfileMinOrderBy
  stddev: ProfileStddevOrderBy
  stddevPop: ProfileStddevPopOrderBy
  stddevSamp: ProfileStddevSampOrderBy
  sum: ProfileSumOrderBy
  varPop: ProfileVarPopOrderBy
  varSamp: ProfileVarSampOrderBy
  variance: ProfileVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ProfileAppendInput {
  metaData: jsonb
}

"""
input type for inserting array relation for remote table "profile"
"""
input ProfileArrRelInsertInput {
  data: [ProfileInsertInput!]!

  """upsert condition"""
  onConflict: ProfileOnConflict
}

"""
columns and relationships of "profile_attribute"
"""
type ProfileAttribute {
  createdAt: timestamptz!
  id: String
  kind: String!
  order: Int
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz!
  value: String!
  visibility: VisibilityKindEnum
}

"""
aggregated selection of "profile_attribute"
"""
type ProfileAttributeAggregate {
  aggregate: ProfileAttributeAggregateFields
  nodes: [ProfileAttribute!]!
}

input ProfileAttributeAggregateBoolExp {
  count: profileAttributeAggregateBoolExpCount
}

"""
aggregate fields of "profile_attribute"
"""
type ProfileAttributeAggregateFields {
  avg: ProfileAttributeAvgFields
  count(columns: [ProfileAttributeSelectColumn!], distinct: Boolean): Int!
  max: ProfileAttributeMaxFields
  min: ProfileAttributeMinFields
  stddev: ProfileAttributeStddevFields
  stddevPop: ProfileAttributeStddevPopFields
  stddevSamp: ProfileAttributeStddevSampFields
  sum: ProfileAttributeSumFields
  varPop: ProfileAttributeVarPopFields
  varSamp: ProfileAttributeVarSampFields
  variance: ProfileAttributeVarianceFields
}

"""
order by aggregate values of table "profile_attribute"
"""
input ProfileAttributeAggregateOrderBy {
  avg: ProfileAttributeAvgOrderBy
  count: OrderBy
  max: ProfileAttributeMaxOrderBy
  min: ProfileAttributeMinOrderBy
  stddev: ProfileAttributeStddevOrderBy
  stddevPop: ProfileAttributeStddevPopOrderBy
  stddevSamp: ProfileAttributeStddevSampOrderBy
  sum: ProfileAttributeSumOrderBy
  varPop: ProfileAttributeVarPopOrderBy
  varSamp: ProfileAttributeVarSampOrderBy
  variance: ProfileAttributeVarianceOrderBy
}

"""
input type for inserting array relation for remote table "profile_attribute"
"""
input ProfileAttributeArrRelInsertInput {
  data: [ProfileAttributeInsertInput!]!

  """upsert condition"""
  onConflict: ProfileAttributeOnConflict
}

"""aggregate avg on columns"""
type ProfileAttributeAvgFields {
  order: Float
}

"""
order by avg() on columns of table "profile_attribute"
"""
input ProfileAttributeAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "profile_attribute". All fields are combined with a logical 'AND'.
"""
input ProfileAttributeBoolExp {
  _and: [ProfileAttributeBoolExp!]
  _not: ProfileAttributeBoolExp
  _or: [ProfileAttributeBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  kind: StringComparisonExp
  order: IntComparisonExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "profile_attribute"
"""
enum ProfileAttributeConstraint {
  """
  unique or primary key constraint on columns "id", "profile_id"
  """
  profile_attribute_pkey
}

"""
input type for incrementing numeric columns in table "profile_attribute"
"""
input ProfileAttributeIncInput {
  order: Int
}

"""
input type for inserting data into table "profile_attribute"
"""
input ProfileAttributeInsertInput {
  createdAt: timestamptz
  id: String
  kind: String
  order: Int
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "profile_attribute_kind"
"""
type ProfileAttributeKind {
  createdAt: timestamptz!
  defaultVisibilityKind: VisibilityKindEnum!
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
  valueKind: ValueKindEnum!
}

"""
aggregated selection of "profile_attribute_kind"
"""
type ProfileAttributeKindAggregate {
  aggregate: ProfileAttributeKindAggregateFields
  nodes: [ProfileAttributeKind!]!
}

"""
aggregate fields of "profile_attribute_kind"
"""
type ProfileAttributeKindAggregateFields {
  count(columns: [ProfileAttributeKindSelectColumn!], distinct: Boolean): Int!
  max: ProfileAttributeKindMaxFields
  min: ProfileAttributeKindMinFields
}

"""
Boolean expression to filter rows from the table "profile_attribute_kind". All fields are combined with a logical 'AND'.
"""
input ProfileAttributeKindBoolExp {
  _and: [ProfileAttributeKindBoolExp!]
  _not: ProfileAttributeKindBoolExp
  _or: [ProfileAttributeKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  defaultVisibilityKind: VisibilityKindEnumComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  valueKind: ValueKindEnumComparisonExp
}

"""
unique or primary key constraints on table "profile_attribute_kind"
"""
enum ProfileAttributeKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  profile_attribute_kind_pkey
}

"""
input type for inserting data into table "profile_attribute_kind"
"""
input ProfileAttributeKindInsertInput {
  createdAt: timestamptz
  defaultVisibilityKind: VisibilityKindEnum
  id: String
  tenantId: String
  updatedAt: timestamptz
  valueKind: ValueKindEnum
}

"""aggregate max on columns"""
type ProfileAttributeKindMaxFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ProfileAttributeKindMinFields {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "profile_attribute_kind"
"""
type ProfileAttributeKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileAttributeKind!]!
}

"""
on_conflict condition type for table "profile_attribute_kind"
"""
input ProfileAttributeKindOnConflict {
  constraint: ProfileAttributeKindConstraint!
  updateColumns: [ProfileAttributeKindUpdateColumn!]! = []
  where: ProfileAttributeKindBoolExp
}

"""Ordering options when selecting data from "profile_attribute_kind"."""
input ProfileAttributeKindOrderBy {
  createdAt: OrderBy
  defaultVisibilityKind: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  valueKind: OrderBy
}

"""primary key columns input for table: profile_attribute_kind"""
input ProfileAttributeKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "profile_attribute_kind"
"""
enum ProfileAttributeKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  defaultVisibilityKind

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  valueKind
}

"""
input type for updating data in table "profile_attribute_kind"
"""
input ProfileAttributeKindSetInput {
  createdAt: timestamptz
  defaultVisibilityKind: VisibilityKindEnum
  id: String
  tenantId: String
  updatedAt: timestamptz
  valueKind: ValueKindEnum
}

"""
Streaming cursor of the table "profile_attribute_kind"
"""
input ProfileAttributeKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileAttributeKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileAttributeKindStreamCursorValueInput {
  createdAt: timestamptz
  defaultVisibilityKind: VisibilityKindEnum
  id: String
  tenantId: String
  updatedAt: timestamptz
  valueKind: ValueKindEnum
}

"""
update columns of table "profile_attribute_kind"
"""
enum ProfileAttributeKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  defaultVisibilityKind

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  valueKind
}

input ProfileAttributeKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileAttributeKindSetInput

  """filter the rows which have to be updated"""
  where: ProfileAttributeKindBoolExp!
}

"""aggregate max on columns"""
type ProfileAttributeMaxFields {
  createdAt: timestamptz
  id: String
  kind: String
  order: Int
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""
order by max() on columns of table "profile_attribute"
"""
input ProfileAttributeMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  order: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""aggregate min on columns"""
type ProfileAttributeMinFields {
  createdAt: timestamptz
  id: String
  kind: String
  order: Int
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""
order by min() on columns of table "profile_attribute"
"""
input ProfileAttributeMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  order: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""
response of any mutation on the table "profile_attribute"
"""
type ProfileAttributeMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileAttribute!]!
}

"""
on_conflict condition type for table "profile_attribute"
"""
input ProfileAttributeOnConflict {
  constraint: ProfileAttributeConstraint!
  updateColumns: [ProfileAttributeUpdateColumn!]! = []
  where: ProfileAttributeBoolExp
}

"""
columns and relationships of "profile_attribute_option"
"""
type ProfileAttributeOption {
  allowsUserAdditions: Boolean!
  createdAt: timestamptz!
  id: String!
  kind: String!
  label: String!
  parentOptionId: String
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_attribute_option"
"""
type ProfileAttributeOptionAggregate {
  aggregate: ProfileAttributeOptionAggregateFields
  nodes: [ProfileAttributeOption!]!
}

"""
aggregate fields of "profile_attribute_option"
"""
type ProfileAttributeOptionAggregateFields {
  count(columns: [ProfileAttributeOptionSelectColumn!], distinct: Boolean): Int!
  max: ProfileAttributeOptionMaxFields
  min: ProfileAttributeOptionMinFields
}

"""
Boolean expression to filter rows from the table "profile_attribute_option". All fields are combined with a logical 'AND'.
"""
input ProfileAttributeOptionBoolExp {
  _and: [ProfileAttributeOptionBoolExp!]
  _not: ProfileAttributeOptionBoolExp
  _or: [ProfileAttributeOptionBoolExp!]
  allowsUserAdditions: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  kind: StringComparisonExp
  label: StringComparisonExp
  parentOptionId: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_attribute_option"
"""
enum ProfileAttributeOptionConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  profile_attribute_option_pkey
}

"""
input type for inserting data into table "profile_attribute_option"
"""
input ProfileAttributeOptionInsertInput {
  allowsUserAdditions: Boolean
  createdAt: timestamptz
  id: String
  kind: String
  label: String
  parentOptionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ProfileAttributeOptionMaxFields {
  createdAt: timestamptz
  id: String
  kind: String
  label: String
  parentOptionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ProfileAttributeOptionMinFields {
  createdAt: timestamptz
  id: String
  kind: String
  label: String
  parentOptionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "profile_attribute_option"
"""
type ProfileAttributeOptionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileAttributeOption!]!
}

"""
on_conflict condition type for table "profile_attribute_option"
"""
input ProfileAttributeOptionOnConflict {
  constraint: ProfileAttributeOptionConstraint!
  updateColumns: [ProfileAttributeOptionUpdateColumn!]! = []
  where: ProfileAttributeOptionBoolExp
}

"""Ordering options when selecting data from "profile_attribute_option"."""
input ProfileAttributeOptionOrderBy {
  allowsUserAdditions: OrderBy
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  label: OrderBy
  parentOptionId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_attribute_option"""
input ProfileAttributeOptionPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "profile_attribute_option"
"""
enum ProfileAttributeOptionSelectColumn {
  """column name"""
  allowsUserAdditions

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  label

  """column name"""
  parentOptionId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "profile_attribute_option"
"""
input ProfileAttributeOptionSetInput {
  allowsUserAdditions: Boolean
  createdAt: timestamptz
  id: String
  kind: String
  label: String
  parentOptionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_attribute_option"
"""
input ProfileAttributeOptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileAttributeOptionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileAttributeOptionStreamCursorValueInput {
  allowsUserAdditions: Boolean
  createdAt: timestamptz
  id: String
  kind: String
  label: String
  parentOptionId: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "profile_attribute_option"
"""
enum ProfileAttributeOptionUpdateColumn {
  """column name"""
  allowsUserAdditions

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  label

  """column name"""
  parentOptionId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ProfileAttributeOptionUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileAttributeOptionSetInput

  """filter the rows which have to be updated"""
  where: ProfileAttributeOptionBoolExp!
}

"""Ordering options when selecting data from "profile_attribute"."""
input ProfileAttributeOrderBy {
  createdAt: OrderBy
  id: OrderBy
  kind: OrderBy
  order: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: profile_attribute"""
input ProfileAttributePkColumnsInput {
  id: String!
  profileId: uuid!
}

"""
select columns of table "profile_attribute"
"""
enum ProfileAttributeSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  order

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  value

  """column name"""
  visibility
}

"""
input type for updating data in table "profile_attribute"
"""
input ProfileAttributeSetInput {
  createdAt: timestamptz
  id: String
  kind: String
  order: Int
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
  visibility: VisibilityKindEnum
}

"""aggregate stddev on columns"""
type ProfileAttributeStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "profile_attribute"
"""
input ProfileAttributeStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type ProfileAttributeStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "profile_attribute"
"""
input ProfileAttributeStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type ProfileAttributeStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "profile_attribute"
"""
input ProfileAttributeStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "profile_attribute"
"""
input ProfileAttributeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileAttributeStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileAttributeStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  kind: String
  order: Int
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
  visibility: VisibilityKindEnum
}

"""aggregate sum on columns"""
type ProfileAttributeSumFields {
  order: Int
}

"""
order by sum() on columns of table "profile_attribute"
"""
input ProfileAttributeSumOrderBy {
  order: OrderBy
}

"""
update columns of table "profile_attribute"
"""
enum ProfileAttributeUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  order

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  value

  """column name"""
  visibility
}

input ProfileAttributeUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProfileAttributeIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProfileAttributeSetInput

  """filter the rows which have to be updated"""
  where: ProfileAttributeBoolExp!
}

"""aggregate varPop on columns"""
type ProfileAttributeVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "profile_attribute"
"""
input ProfileAttributeVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type ProfileAttributeVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "profile_attribute"
"""
input ProfileAttributeVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type ProfileAttributeVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "profile_attribute"
"""
input ProfileAttributeVarianceOrderBy {
  order: OrderBy
}

"""aggregate avg on columns"""
type ProfileAvgFields {
  level: Float
}

"""
order by avg() on columns of table "profile"
"""
input ProfileAvgOrderBy {
  level: OrderBy
}

"""
Boolean expression to filter rows from the table "profile". All fields are combined with a logical 'AND'.
"""
input ProfileBoolExp {
  _and: [ProfileBoolExp!]
  _not: ProfileBoolExp
  _or: [ProfileBoolExp!]
  anonymousId: StringComparisonExp
  attributes: ProfileAttributeBoolExp
  attributesAggregate: ProfileAttributeAggregateBoolExp
  bio: StringComparisonExp
  childProfileNodes: ProfileBoolExp
  childProfileNodesAggregate: ProfileAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  devices: ProfileDeviceBoolExp
  devicesAggregate: ProfileDeviceAggregateBoolExp
  displayName: StringComparisonExp
  displayNameOverride: StringComparisonExp
  facebookUsername: StringComparisonExp
  followedProfiles: ProfileFollowerBoolExp
  followedProfilesAggregate: ProfileFollowerAggregateBoolExp
  followers: ProfileFollowerBoolExp
  followersAggregate: ProfileFollowerAggregateBoolExp
  id: UuidComparisonExp
  identity: ProfileIdentityBoolExp
  instagramUsername: StringComparisonExp
  isDeleted: BooleanComparisonExp
  kind: StringComparisonExp
  level: IntComparisonExp
  location: GeoLocationBoolExp
  locationId: UuidComparisonExp
  logs: LogBoolExp
  logsAggregate: LogAggregateBoolExp
  managedProfiles: ProfileManagerBoolExp
  managedProfilesAggregate: ProfileManagerAggregateBoolExp
  metaData: JsonbComparisonExp
  optIns: ContactOptInBoolExp
  optInsAggregate: ContactOptInAggregateBoolExp
  orders: ShopOrderBoolExp
  ordersAggregate: ShopOrderAggregateBoolExp
  parentNodeId: UuidComparisonExp
  parentProfileNode: ProfileBoolExp
  photo: MediaItemBoolExp
  photoId: StringComparisonExp
  postsCreated: PostBoolExp
  postsCreatedAggregate: PostAggregateBoolExp
  postsToProfile: PostBoolExp
  postsToProfileAggregate: PostAggregateBoolExp
  profileManagers: ProfileManagerBoolExp
  profileManagersAggregate: ProfileManagerAggregateBoolExp
  profileStats: ProfileStatBoolExp
  profileStatsAggregate: ProfileStatAggregateBoolExp
  sessions: AuthSessionBoolExp
  sessionsAggregate: AuthSessionAggregateBoolExp
  startDate: DateComparisonExp
  subscriptions: ShopSubscriptionBoolExp
  subscriptionsAggregate: ShopSubscriptionAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  tiktokUsername: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  username: CitextComparisonExp
  xUsername: StringComparisonExp
}

input ProfileCheckUsernameInput {
  username: citext!
}

type ProfileCheckUsernameOutput {
  isAvailable: Boolean!
  suggestedUsername: String
}

type ProfileCompleteOnboardingOutput {
  message: String!
  success: Boolean!
}

"""
unique or primary key constraints on table "profile"
"""
enum ProfileConstraint {
  """
  unique or primary key constraint on columns "anonymous_id"
  """
  profile_anonymous_id_key

  """
  unique or primary key constraint on columns "id"
  """
  profile_pkey

  """
  unique or primary key constraint on columns "username", "tenant_id"
  """
  profile_username_tenant_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ProfileDeleteAtPathInput {
  metaData: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ProfileDeleteElemInput {
  metaData: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ProfileDeleteKeyInput {
  metaData: String
}

"""
columns and relationships of "profile_device"
"""
type ProfileDevice {
  appVersion: String
  brand: String
  browser: String
  createdAt: timestamptz!

  """unique push token"""
  id: String!
  lastNotificationAt: timestamptz
  model: String
  notificationsEnabled: Boolean!
  os: String
  osVersion: String
  profileId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_device"
"""
type ProfileDeviceAggregate {
  aggregate: ProfileDeviceAggregateFields
  nodes: [ProfileDevice!]!
}

input ProfileDeviceAggregateBoolExp {
  bool_and: profileDeviceAggregateBoolExpBool_and
  bool_or: profileDeviceAggregateBoolExpBool_or
  count: profileDeviceAggregateBoolExpCount
}

"""
aggregate fields of "profile_device"
"""
type ProfileDeviceAggregateFields {
  count(columns: [ProfileDeviceSelectColumn!], distinct: Boolean): Int!
  max: ProfileDeviceMaxFields
  min: ProfileDeviceMinFields
}

"""
order by aggregate values of table "profile_device"
"""
input ProfileDeviceAggregateOrderBy {
  count: OrderBy
  max: ProfileDeviceMaxOrderBy
  min: ProfileDeviceMinOrderBy
}

"""
input type for inserting array relation for remote table "profile_device"
"""
input ProfileDeviceArrRelInsertInput {
  data: [ProfileDeviceInsertInput!]!

  """upsert condition"""
  onConflict: ProfileDeviceOnConflict
}

"""
Boolean expression to filter rows from the table "profile_device". All fields are combined with a logical 'AND'.
"""
input ProfileDeviceBoolExp {
  _and: [ProfileDeviceBoolExp!]
  _not: ProfileDeviceBoolExp
  _or: [ProfileDeviceBoolExp!]
  appVersion: StringComparisonExp
  brand: StringComparisonExp
  browser: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  lastNotificationAt: TimestamptzComparisonExp
  model: StringComparisonExp
  notificationsEnabled: BooleanComparisonExp
  os: StringComparisonExp
  osVersion: StringComparisonExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_device"
"""
enum ProfileDeviceConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  profile_device_pkey
}

"""
input type for inserting data into table "profile_device"
"""
input ProfileDeviceInsertInput {
  appVersion: String
  brand: String
  browser: String
  createdAt: timestamptz

  """unique push token"""
  id: String
  lastNotificationAt: timestamptz
  model: String
  notificationsEnabled: Boolean
  os: String
  osVersion: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ProfileDeviceMaxFields {
  appVersion: String
  brand: String
  browser: String
  createdAt: timestamptz

  """unique push token"""
  id: String
  lastNotificationAt: timestamptz
  model: String
  os: String
  osVersion: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "profile_device"
"""
input ProfileDeviceMaxOrderBy {
  appVersion: OrderBy
  brand: OrderBy
  browser: OrderBy
  createdAt: OrderBy

  """unique push token"""
  id: OrderBy
  lastNotificationAt: OrderBy
  model: OrderBy
  os: OrderBy
  osVersion: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ProfileDeviceMinFields {
  appVersion: String
  brand: String
  browser: String
  createdAt: timestamptz

  """unique push token"""
  id: String
  lastNotificationAt: timestamptz
  model: String
  os: String
  osVersion: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "profile_device"
"""
input ProfileDeviceMinOrderBy {
  appVersion: OrderBy
  brand: OrderBy
  browser: OrderBy
  createdAt: OrderBy

  """unique push token"""
  id: OrderBy
  lastNotificationAt: OrderBy
  model: OrderBy
  os: OrderBy
  osVersion: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "profile_device"
"""
type ProfileDeviceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileDevice!]!
}

"""
on_conflict condition type for table "profile_device"
"""
input ProfileDeviceOnConflict {
  constraint: ProfileDeviceConstraint!
  updateColumns: [ProfileDeviceUpdateColumn!]! = []
  where: ProfileDeviceBoolExp
}

"""Ordering options when selecting data from "profile_device"."""
input ProfileDeviceOrderBy {
  appVersion: OrderBy
  brand: OrderBy
  browser: OrderBy
  createdAt: OrderBy
  id: OrderBy
  lastNotificationAt: OrderBy
  model: OrderBy
  notificationsEnabled: OrderBy
  os: OrderBy
  osVersion: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_device"""
input ProfileDevicePkColumnsInput {
  """unique push token"""
  id: String!
}

"""
select columns of table "profile_device"
"""
enum ProfileDeviceSelectColumn {
  """column name"""
  appVersion

  """column name"""
  brand

  """column name"""
  browser

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  lastNotificationAt

  """column name"""
  model

  """column name"""
  notificationsEnabled

  """column name"""
  os

  """column name"""
  osVersion

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
select "profileDeviceAggregateBoolExpBool_andArgumentsColumns" columns of table "profile_device"
"""
enum ProfileDeviceSelectColumnProfileDeviceAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  notificationsEnabled
}

"""
select "profileDeviceAggregateBoolExpBool_orArgumentsColumns" columns of table "profile_device"
"""
enum ProfileDeviceSelectColumnProfileDeviceAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  notificationsEnabled
}

"""
input type for updating data in table "profile_device"
"""
input ProfileDeviceSetInput {
  appVersion: String
  brand: String
  browser: String
  createdAt: timestamptz

  """unique push token"""
  id: String
  lastNotificationAt: timestamptz
  model: String
  notificationsEnabled: Boolean
  os: String
  osVersion: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_device"
"""
input ProfileDeviceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileDeviceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileDeviceStreamCursorValueInput {
  appVersion: String
  brand: String
  browser: String
  createdAt: timestamptz

  """unique push token"""
  id: String
  lastNotificationAt: timestamptz
  model: String
  notificationsEnabled: Boolean
  os: String
  osVersion: String
  profileId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "profile_device"
"""
enum ProfileDeviceUpdateColumn {
  """column name"""
  appVersion

  """column name"""
  brand

  """column name"""
  browser

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  lastNotificationAt

  """column name"""
  model

  """column name"""
  notificationsEnabled

  """column name"""
  os

  """column name"""
  osVersion

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ProfileDeviceUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileDeviceSetInput

  """filter the rows which have to be updated"""
  where: ProfileDeviceBoolExp!
}

"""
columns and relationships of "profile_follower"
"""
type ProfileFollower {
  createdAt: timestamptz!

  """An object relationship"""
  followedProfile: Profile!
  followedProfileId: uuid!

  """An object relationship"""
  follower: Profile!
  followerId: uuid!
  kind: ProfileFollowerKindEnum!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_follower"
"""
type ProfileFollowerAggregate {
  aggregate: ProfileFollowerAggregateFields
  nodes: [ProfileFollower!]!
}

input ProfileFollowerAggregateBoolExp {
  count: profileFollowerAggregateBoolExpCount
}

"""
aggregate fields of "profile_follower"
"""
type ProfileFollowerAggregateFields {
  count(columns: [ProfileFollowerSelectColumn!], distinct: Boolean): Int!
  max: ProfileFollowerMaxFields
  min: ProfileFollowerMinFields
}

"""
order by aggregate values of table "profile_follower"
"""
input ProfileFollowerAggregateOrderBy {
  count: OrderBy
  max: ProfileFollowerMaxOrderBy
  min: ProfileFollowerMinOrderBy
}

"""
input type for inserting array relation for remote table "profile_follower"
"""
input ProfileFollowerArrRelInsertInput {
  data: [ProfileFollowerInsertInput!]!

  """upsert condition"""
  onConflict: ProfileFollowerOnConflict
}

"""
Boolean expression to filter rows from the table "profile_follower". All fields are combined with a logical 'AND'.
"""
input ProfileFollowerBoolExp {
  _and: [ProfileFollowerBoolExp!]
  _not: ProfileFollowerBoolExp
  _or: [ProfileFollowerBoolExp!]
  createdAt: TimestamptzComparisonExp
  followedProfile: ProfileBoolExp
  followedProfileId: UuidComparisonExp
  follower: ProfileBoolExp
  followerId: UuidComparisonExp
  kind: ProfileFollowerKindEnumComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_follower"
"""
enum ProfileFollowerConstraint {
  """
  unique or primary key constraint on columns "followed_profile_id", "follower_id"
  """
  profile_follower_pkey
}

"""
input type for inserting data into table "profile_follower"
"""
input ProfileFollowerInsertInput {
  createdAt: timestamptz
  followedProfile: ProfileObjRelInsertInput
  followedProfileId: uuid
  follower: ProfileObjRelInsertInput
  followerId: uuid
  kind: ProfileFollowerKindEnum
  tenantId: String
  updatedAt: timestamptz
}

enum ProfileFollowerKindEnum {
  ORGANIZATION
  SOCIAL
}

"""
Boolean expression to compare columns of type "ProfileFollowerKindEnum". All fields are combined with logical 'AND'.
"""
input ProfileFollowerKindEnumComparisonExp {
  _eq: ProfileFollowerKindEnum
  _in: [ProfileFollowerKindEnum!]
  _isNull: Boolean
  _neq: ProfileFollowerKindEnum
  _nin: [ProfileFollowerKindEnum!]
}

"""aggregate max on columns"""
type ProfileFollowerMaxFields {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "profile_follower"
"""
input ProfileFollowerMaxOrderBy {
  createdAt: OrderBy
  followedProfileId: OrderBy
  followerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ProfileFollowerMinFields {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "profile_follower"
"""
input ProfileFollowerMinOrderBy {
  createdAt: OrderBy
  followedProfileId: OrderBy
  followerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "profile_follower"
"""
type ProfileFollowerMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileFollower!]!
}

"""
on_conflict condition type for table "profile_follower"
"""
input ProfileFollowerOnConflict {
  constraint: ProfileFollowerConstraint!
  updateColumns: [ProfileFollowerUpdateColumn!]! = []
  where: ProfileFollowerBoolExp
}

"""Ordering options when selecting data from "profile_follower"."""
input ProfileFollowerOrderBy {
  createdAt: OrderBy
  followedProfile: ProfileOrderBy
  followedProfileId: OrderBy
  follower: ProfileOrderBy
  followerId: OrderBy
  kind: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_follower"""
input ProfileFollowerPkColumnsInput {
  followedProfileId: uuid!
  followerId: uuid!
}

"""
select columns of table "profile_follower"
"""
enum ProfileFollowerSelectColumn {
  """column name"""
  createdAt

  """column name"""
  followedProfileId

  """column name"""
  followerId

  """column name"""
  kind

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "profile_follower"
"""
input ProfileFollowerSetInput {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  kind: ProfileFollowerKindEnum
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_follower"
"""
input ProfileFollowerStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileFollowerStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileFollowerStreamCursorValueInput {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  kind: ProfileFollowerKindEnum
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "profile_follower"
"""
enum ProfileFollowerUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  followedProfileId

  """column name"""
  followerId

  """column name"""
  kind

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ProfileFollowerUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileFollowerSetInput

  """filter the rows which have to be updated"""
  where: ProfileFollowerBoolExp!
}

"""
columns and relationships of "profile_health_configuration"
"""
type ProfileHealthConfiguration {
  carbsPercent: Int
  createdAt: timestamptz!
  dailyCalorieGoal: Int
  fatPercent: Int
  foodPlan: String
  heightInches: numeric
  id: uuid!
  profileId: uuid!
  proteinPercent: Int
  tenantId: String!
  updatedAt: timestamptz!
  weightGoalLbs: numeric
  weightLbs: numeric
  workoutPlan: String
}

"""
aggregated selection of "profile_health_configuration"
"""
type ProfileHealthConfigurationAggregate {
  aggregate: ProfileHealthConfigurationAggregateFields
  nodes: [ProfileHealthConfiguration!]!
}

"""
aggregate fields of "profile_health_configuration"
"""
type ProfileHealthConfigurationAggregateFields {
  avg: ProfileHealthConfigurationAvgFields
  count(columns: [ProfileHealthConfigurationSelectColumn!], distinct: Boolean): Int!
  max: ProfileHealthConfigurationMaxFields
  min: ProfileHealthConfigurationMinFields
  stddev: ProfileHealthConfigurationStddevFields
  stddevPop: ProfileHealthConfigurationStddevPopFields
  stddevSamp: ProfileHealthConfigurationStddevSampFields
  sum: ProfileHealthConfigurationSumFields
  varPop: ProfileHealthConfigurationVarPopFields
  varSamp: ProfileHealthConfigurationVarSampFields
  variance: ProfileHealthConfigurationVarianceFields
}

"""aggregate avg on columns"""
type ProfileHealthConfigurationAvgFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""
Boolean expression to filter rows from the table "profile_health_configuration". All fields are combined with a logical 'AND'.
"""
input ProfileHealthConfigurationBoolExp {
  _and: [ProfileHealthConfigurationBoolExp!]
  _not: ProfileHealthConfigurationBoolExp
  _or: [ProfileHealthConfigurationBoolExp!]
  carbsPercent: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  dailyCalorieGoal: IntComparisonExp
  fatPercent: IntComparisonExp
  foodPlan: StringComparisonExp
  heightInches: NumericComparisonExp
  id: UuidComparisonExp
  profileId: UuidComparisonExp
  proteinPercent: IntComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  weightGoalLbs: NumericComparisonExp
  weightLbs: NumericComparisonExp
  workoutPlan: StringComparisonExp
}

"""
unique or primary key constraints on table "profile_health_configuration"
"""
enum ProfileHealthConfigurationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  profile_health_metrics_pkey

  """
  unique or primary key constraint on columns "profile_id"
  """
  profile_health_metrics_profile_id_key
}

"""
input type for incrementing numeric columns in table "profile_health_configuration"
"""
input ProfileHealthConfigurationIncInput {
  carbsPercent: Int
  dailyCalorieGoal: Int
  fatPercent: Int
  heightInches: numeric
  proteinPercent: Int
  weightGoalLbs: numeric
  weightLbs: numeric
}

"""
input type for inserting data into table "profile_health_configuration"
"""
input ProfileHealthConfigurationInsertInput {
  carbsPercent: Int
  createdAt: timestamptz
  dailyCalorieGoal: Int
  fatPercent: Int
  foodPlan: String
  heightInches: numeric
  id: uuid
  profileId: uuid
  proteinPercent: Int
  tenantId: String
  updatedAt: timestamptz
  weightGoalLbs: numeric
  weightLbs: numeric
  workoutPlan: String
}

"""aggregate max on columns"""
type ProfileHealthConfigurationMaxFields {
  carbsPercent: Int
  createdAt: timestamptz
  dailyCalorieGoal: Int
  fatPercent: Int
  foodPlan: String
  heightInches: numeric
  id: uuid
  profileId: uuid
  proteinPercent: Int
  tenantId: String
  updatedAt: timestamptz
  weightGoalLbs: numeric
  weightLbs: numeric
  workoutPlan: String
}

"""aggregate min on columns"""
type ProfileHealthConfigurationMinFields {
  carbsPercent: Int
  createdAt: timestamptz
  dailyCalorieGoal: Int
  fatPercent: Int
  foodPlan: String
  heightInches: numeric
  id: uuid
  profileId: uuid
  proteinPercent: Int
  tenantId: String
  updatedAt: timestamptz
  weightGoalLbs: numeric
  weightLbs: numeric
  workoutPlan: String
}

"""
response of any mutation on the table "profile_health_configuration"
"""
type ProfileHealthConfigurationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileHealthConfiguration!]!
}

"""
on_conflict condition type for table "profile_health_configuration"
"""
input ProfileHealthConfigurationOnConflict {
  constraint: ProfileHealthConfigurationConstraint!
  updateColumns: [ProfileHealthConfigurationUpdateColumn!]! = []
  where: ProfileHealthConfigurationBoolExp
}

"""
Ordering options when selecting data from "profile_health_configuration".
"""
input ProfileHealthConfigurationOrderBy {
  carbsPercent: OrderBy
  createdAt: OrderBy
  dailyCalorieGoal: OrderBy
  fatPercent: OrderBy
  foodPlan: OrderBy
  heightInches: OrderBy
  id: OrderBy
  profileId: OrderBy
  proteinPercent: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  weightGoalLbs: OrderBy
  weightLbs: OrderBy
  workoutPlan: OrderBy
}

"""primary key columns input for table: profile_health_configuration"""
input ProfileHealthConfigurationPkColumnsInput {
  id: uuid!
}

"""
select columns of table "profile_health_configuration"
"""
enum ProfileHealthConfigurationSelectColumn {
  """column name"""
  carbsPercent

  """column name"""
  createdAt

  """column name"""
  dailyCalorieGoal

  """column name"""
  fatPercent

  """column name"""
  foodPlan

  """column name"""
  heightInches

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  proteinPercent

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  weightGoalLbs

  """column name"""
  weightLbs

  """column name"""
  workoutPlan
}

"""
input type for updating data in table "profile_health_configuration"
"""
input ProfileHealthConfigurationSetInput {
  carbsPercent: Int
  createdAt: timestamptz
  dailyCalorieGoal: Int
  fatPercent: Int
  foodPlan: String
  heightInches: numeric
  id: uuid
  profileId: uuid
  proteinPercent: Int
  tenantId: String
  updatedAt: timestamptz
  weightGoalLbs: numeric
  weightLbs: numeric
  workoutPlan: String
}

"""aggregate stddev on columns"""
type ProfileHealthConfigurationStddevFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""aggregate stddevPop on columns"""
type ProfileHealthConfigurationStddevPopFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""aggregate stddevSamp on columns"""
type ProfileHealthConfigurationStddevSampFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""
Streaming cursor of the table "profile_health_configuration"
"""
input ProfileHealthConfigurationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileHealthConfigurationStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileHealthConfigurationStreamCursorValueInput {
  carbsPercent: Int
  createdAt: timestamptz
  dailyCalorieGoal: Int
  fatPercent: Int
  foodPlan: String
  heightInches: numeric
  id: uuid
  profileId: uuid
  proteinPercent: Int
  tenantId: String
  updatedAt: timestamptz
  weightGoalLbs: numeric
  weightLbs: numeric
  workoutPlan: String
}

"""aggregate sum on columns"""
type ProfileHealthConfigurationSumFields {
  carbsPercent: Int
  dailyCalorieGoal: Int
  fatPercent: Int
  heightInches: numeric
  proteinPercent: Int
  weightGoalLbs: numeric
  weightLbs: numeric
}

"""
update columns of table "profile_health_configuration"
"""
enum ProfileHealthConfigurationUpdateColumn {
  """column name"""
  carbsPercent

  """column name"""
  createdAt

  """column name"""
  dailyCalorieGoal

  """column name"""
  fatPercent

  """column name"""
  foodPlan

  """column name"""
  heightInches

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  proteinPercent

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  weightGoalLbs

  """column name"""
  weightLbs

  """column name"""
  workoutPlan
}

input ProfileHealthConfigurationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProfileHealthConfigurationIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProfileHealthConfigurationSetInput

  """filter the rows which have to be updated"""
  where: ProfileHealthConfigurationBoolExp!
}

"""aggregate varPop on columns"""
type ProfileHealthConfigurationVarPopFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""aggregate varSamp on columns"""
type ProfileHealthConfigurationVarSampFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""aggregate variance on columns"""
type ProfileHealthConfigurationVarianceFields {
  carbsPercent: Float
  dailyCalorieGoal: Float
  fatPercent: Float
  heightInches: Float
  proteinPercent: Float
  weightGoalLbs: Float
  weightLbs: Float
}

"""
columns and relationships of "profile_identity"
"""
type ProfileIdentity {
  createdAt: timestamptz!
  dob: date
  email: citext
  firstName: String
  gender: String
  id: uuid!
  ipAddress: String
  isManaged: Boolean!
  lastName: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  mobile: citext
  name: String
  onboardedAt: timestamptz

  """An object relationship"""
  profile: Profile!
  tenantId: String!
  termsAcceptedOn: timestamptz
  unverifiedEmail: citext
  unverifiedMobile: citext
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_identity"
"""
type ProfileIdentityAggregate {
  aggregate: ProfileIdentityAggregateFields
  nodes: [ProfileIdentity!]!
}

"""
aggregate fields of "profile_identity"
"""
type ProfileIdentityAggregateFields {
  count(columns: [ProfileIdentitySelectColumn!], distinct: Boolean): Int!
  max: ProfileIdentityMaxFields
  min: ProfileIdentityMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ProfileIdentityAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "profile_identity". All fields are combined with a logical 'AND'.
"""
input ProfileIdentityBoolExp {
  _and: [ProfileIdentityBoolExp!]
  _not: ProfileIdentityBoolExp
  _or: [ProfileIdentityBoolExp!]
  createdAt: TimestamptzComparisonExp
  dob: DateComparisonExp
  email: CitextComparisonExp
  firstName: StringComparisonExp
  gender: StringComparisonExp
  id: UuidComparisonExp
  ipAddress: StringComparisonExp
  isManaged: BooleanComparisonExp
  lastName: StringComparisonExp
  metadata: JsonbComparisonExp
  mobile: CitextComparisonExp
  name: StringComparisonExp
  onboardedAt: TimestamptzComparisonExp
  profile: ProfileBoolExp
  tenantId: StringComparisonExp
  termsAcceptedOn: TimestamptzComparisonExp
  unverifiedEmail: CitextComparisonExp
  unverifiedMobile: CitextComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_identity"
"""
enum ProfileIdentityConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  profile_identity_pkey

  """
  unique or primary key constraint on columns "email", "tenant_id"
  """
  profile_identity_tenant_id_email_key

  """
  unique or primary key constraint on columns "mobile", "tenant_id"
  """
  profile_identity_tenant_id_mobile_key

  """
  unique or primary key constraint on columns "unverified_email", "tenant_id"
  """
  profile_identity_tenant_id_unverified_email_key

  """
  unique or primary key constraint on columns "unverified_mobile", "tenant_id"
  """
  profile_identity_tenant_id_unverified_mobile_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ProfileIdentityDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ProfileIdentityDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ProfileIdentityDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "profile_identity"
"""
input ProfileIdentityInsertInput {
  createdAt: timestamptz
  dob: date
  email: citext
  firstName: String
  gender: String
  id: uuid
  ipAddress: String
  isManaged: Boolean
  lastName: String
  metadata: jsonb
  mobile: citext
  onboardedAt: timestamptz
  profile: ProfileObjRelInsertInput
  tenantId: String
  termsAcceptedOn: timestamptz
  unverifiedEmail: citext
  unverifiedMobile: citext
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ProfileIdentityMaxFields {
  createdAt: timestamptz
  dob: date
  email: citext
  firstName: String
  gender: String
  id: uuid
  ipAddress: String
  lastName: String
  mobile: citext
  name: String
  onboardedAt: timestamptz
  tenantId: String
  termsAcceptedOn: timestamptz
  unverifiedEmail: citext
  unverifiedMobile: citext
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ProfileIdentityMinFields {
  createdAt: timestamptz
  dob: date
  email: citext
  firstName: String
  gender: String
  id: uuid
  ipAddress: String
  lastName: String
  mobile: citext
  name: String
  onboardedAt: timestamptz
  tenantId: String
  termsAcceptedOn: timestamptz
  unverifiedEmail: citext
  unverifiedMobile: citext
  updatedAt: timestamptz
}

"""
response of any mutation on the table "profile_identity"
"""
type ProfileIdentityMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileIdentity!]!
}

"""
input type for inserting object relation for remote table "profile_identity"
"""
input ProfileIdentityObjRelInsertInput {
  data: ProfileIdentityInsertInput!

  """upsert condition"""
  onConflict: ProfileIdentityOnConflict
}

"""
on_conflict condition type for table "profile_identity"
"""
input ProfileIdentityOnConflict {
  constraint: ProfileIdentityConstraint!
  updateColumns: [ProfileIdentityUpdateColumn!]! = []
  where: ProfileIdentityBoolExp
}

"""Ordering options when selecting data from "profile_identity"."""
input ProfileIdentityOrderBy {
  createdAt: OrderBy
  dob: OrderBy
  email: OrderBy
  firstName: OrderBy
  gender: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  isManaged: OrderBy
  lastName: OrderBy
  metadata: OrderBy
  mobile: OrderBy
  name: OrderBy
  onboardedAt: OrderBy
  profile: ProfileOrderBy
  tenantId: OrderBy
  termsAcceptedOn: OrderBy
  unverifiedEmail: OrderBy
  unverifiedMobile: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_identity"""
input ProfileIdentityPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ProfileIdentityPrependInput {
  metadata: jsonb
}

"""
select columns of table "profile_identity"
"""
enum ProfileIdentitySelectColumn {
  """column name"""
  createdAt

  """column name"""
  dob

  """column name"""
  email

  """column name"""
  firstName

  """column name"""
  gender

  """column name"""
  id

  """column name"""
  ipAddress

  """column name"""
  isManaged

  """column name"""
  lastName

  """column name"""
  metadata

  """column name"""
  mobile

  """column name"""
  name

  """column name"""
  onboardedAt

  """column name"""
  tenantId

  """column name"""
  termsAcceptedOn

  """column name"""
  unverifiedEmail

  """column name"""
  unverifiedMobile

  """column name"""
  updatedAt
}

"""
input type for updating data in table "profile_identity"
"""
input ProfileIdentitySetInput {
  createdAt: timestamptz
  dob: date
  email: citext
  firstName: String
  gender: String
  id: uuid
  ipAddress: String
  isManaged: Boolean
  lastName: String
  metadata: jsonb
  mobile: citext
  onboardedAt: timestamptz
  tenantId: String
  termsAcceptedOn: timestamptz
  unverifiedEmail: citext
  unverifiedMobile: citext
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_identity"
"""
input ProfileIdentityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileIdentityStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileIdentityStreamCursorValueInput {
  createdAt: timestamptz
  dob: date
  email: citext
  firstName: String
  gender: String
  id: uuid
  ipAddress: String
  isManaged: Boolean
  lastName: String
  metadata: jsonb
  mobile: citext
  name: String
  onboardedAt: timestamptz
  tenantId: String
  termsAcceptedOn: timestamptz
  unverifiedEmail: citext
  unverifiedMobile: citext
  updatedAt: timestamptz
}

"""
update columns of table "profile_identity"
"""
enum ProfileIdentityUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  dob

  """column name"""
  email

  """column name"""
  firstName

  """column name"""
  gender

  """column name"""
  id

  """column name"""
  ipAddress

  """column name"""
  isManaged

  """column name"""
  lastName

  """column name"""
  metadata

  """column name"""
  mobile

  """column name"""
  onboardedAt

  """column name"""
  tenantId

  """column name"""
  termsAcceptedOn

  """column name"""
  unverifiedEmail

  """column name"""
  unverifiedMobile

  """column name"""
  updatedAt
}

input ProfileIdentityUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ProfileIdentityAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ProfileIdentityDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ProfileIdentityDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ProfileIdentityDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ProfileIdentityPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProfileIdentitySetInput

  """filter the rows which have to be updated"""
  where: ProfileIdentityBoolExp!
}

"""
input type for incrementing numeric columns in table "profile"
"""
input ProfileIncInput {
  level: Int
}

"""
input type for inserting data into table "profile"
"""
input ProfileInsertInput {
  """typically a device id the anonymous user registered with"""
  anonymousId: String
  attributes: ProfileAttributeArrRelInsertInput
  bio: String
  childProfileNodes: ProfileArrRelInsertInput
  createdAt: timestamptz
  devices: ProfileDeviceArrRelInsertInput
  displayNameOverride: String
  facebookUsername: String
  followedProfiles: ProfileFollowerArrRelInsertInput
  followers: ProfileFollowerArrRelInsertInput
  id: uuid
  identity: ProfileIdentityObjRelInsertInput
  instagramUsername: String
  isDeleted: Boolean
  kind: String
  level: Int
  location: GeoLocationObjRelInsertInput
  locationId: uuid
  logs: LogArrRelInsertInput
  managedProfiles: ProfileManagerArrRelInsertInput
  metaData: jsonb
  optIns: ContactOptInArrRelInsertInput
  orders: ShopOrderArrRelInsertInput
  parentNodeId: uuid
  parentProfileNode: ProfileObjRelInsertInput
  photo: MediaItemObjRelInsertInput
  photoId: String
  postsCreated: PostArrRelInsertInput
  postsToProfile: PostArrRelInsertInput
  profileManagers: ProfileManagerArrRelInsertInput
  profileStats: ProfileStatArrRelInsertInput
  sessions: AuthSessionArrRelInsertInput
  startDate: date
  subscriptions: ShopSubscriptionArrRelInsertInput
  tenantId: String
  tiktokUsername: String
  updatedAt: timestamptz
  username: citext
  xUsername: String
}

"""
columns and relationships of "profile_kind"
"""
type ProfileKind {
  createdAt: timestamptz!

  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_kind"
"""
type ProfileKindAggregate {
  aggregate: ProfileKindAggregateFields
  nodes: [ProfileKind!]!
}

"""
aggregate fields of "profile_kind"
"""
type ProfileKindAggregateFields {
  count(columns: [ProfileKindSelectColumn!], distinct: Boolean): Int!
  max: ProfileKindMaxFields
  min: ProfileKindMinFields
}

"""
Boolean expression to filter rows from the table "profile_kind". All fields are combined with a logical 'AND'.
"""
input ProfileKindBoolExp {
  _and: [ProfileKindBoolExp!]
  _not: ProfileKindBoolExp
  _or: [ProfileKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_kind"
"""
enum ProfileKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  profile_kind_pkey
}

"""
input type for inserting data into table "profile_kind"
"""
input ProfileKindInsertInput {
  createdAt: timestamptz

  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ProfileKindMaxFields {
  createdAt: timestamptz

  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ProfileKindMinFields {
  createdAt: timestamptz

  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "profile_kind"
"""
type ProfileKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileKind!]!
}

"""
on_conflict condition type for table "profile_kind"
"""
input ProfileKindOnConflict {
  constraint: ProfileKindConstraint!
  updateColumns: [ProfileKindUpdateColumn!]! = []
  where: ProfileKindBoolExp
}

"""Ordering options when selecting data from "profile_kind"."""
input ProfileKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_kind"""
input ProfileKindPkColumnsInput {
  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String!
  tenantId: String!
}

"""
select columns of table "profile_kind"
"""
enum ProfileKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "profile_kind"
"""
input ProfileKindSetInput {
  createdAt: timestamptz

  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_kind"
"""
input ProfileKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileKindStreamCursorValueInput {
  createdAt: timestamptz

  """anonymous_user, user, service_provider, artist, community, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "profile_kind"
"""
enum ProfileKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ProfileKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileKindSetInput

  """filter the rows which have to be updated"""
  where: ProfileKindBoolExp!
}

"""
columns and relationships of "profile_manager"
"""
type ProfileManager {
  createdAt: timestamptz!
  kind: String!
  managedProfileId: uuid!
  managerId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_manager"
"""
type ProfileManagerAggregate {
  aggregate: ProfileManagerAggregateFields
  nodes: [ProfileManager!]!
}

input ProfileManagerAggregateBoolExp {
  count: profileManagerAggregateBoolExpCount
}

"""
aggregate fields of "profile_manager"
"""
type ProfileManagerAggregateFields {
  count(columns: [ProfileManagerSelectColumn!], distinct: Boolean): Int!
  max: ProfileManagerMaxFields
  min: ProfileManagerMinFields
}

"""
order by aggregate values of table "profile_manager"
"""
input ProfileManagerAggregateOrderBy {
  count: OrderBy
  max: ProfileManagerMaxOrderBy
  min: ProfileManagerMinOrderBy
}

"""
input type for inserting array relation for remote table "profile_manager"
"""
input ProfileManagerArrRelInsertInput {
  data: [ProfileManagerInsertInput!]!

  """upsert condition"""
  onConflict: ProfileManagerOnConflict
}

"""
Boolean expression to filter rows from the table "profile_manager". All fields are combined with a logical 'AND'.
"""
input ProfileManagerBoolExp {
  _and: [ProfileManagerBoolExp!]
  _not: ProfileManagerBoolExp
  _or: [ProfileManagerBoolExp!]
  createdAt: TimestamptzComparisonExp
  kind: StringComparisonExp
  managedProfileId: UuidComparisonExp
  managerId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_manager"
"""
enum ProfileManagerConstraint {
  """
  unique or primary key constraint on columns "managed_profile_id", "manager_id"
  """
  profile_manager_pkey
}

"""
input type for inserting data into table "profile_manager"
"""
input ProfileManagerInsertInput {
  createdAt: timestamptz
  kind: String
  managedProfileId: uuid
  managerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "profile_manager_kind"
"""
type ProfileManagerKind {
  createdAt: timestamptz!

  """owner, manager, etc."""
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_manager_kind"
"""
type ProfileManagerKindAggregate {
  aggregate: ProfileManagerKindAggregateFields
  nodes: [ProfileManagerKind!]!
}

"""
aggregate fields of "profile_manager_kind"
"""
type ProfileManagerKindAggregateFields {
  count(columns: [ProfileManagerKindSelectColumn!], distinct: Boolean): Int!
  max: ProfileManagerKindMaxFields
  min: ProfileManagerKindMinFields
}

"""
Boolean expression to filter rows from the table "profile_manager_kind". All fields are combined with a logical 'AND'.
"""
input ProfileManagerKindBoolExp {
  _and: [ProfileManagerKindBoolExp!]
  _not: ProfileManagerKindBoolExp
  _or: [ProfileManagerKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "profile_manager_kind"
"""
enum ProfileManagerKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  profile_manager_kind_pkey
}

"""
input type for inserting data into table "profile_manager_kind"
"""
input ProfileManagerKindInsertInput {
  createdAt: timestamptz

  """owner, manager, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ProfileManagerKindMaxFields {
  createdAt: timestamptz

  """owner, manager, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ProfileManagerKindMinFields {
  createdAt: timestamptz

  """owner, manager, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "profile_manager_kind"
"""
type ProfileManagerKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileManagerKind!]!
}

"""
on_conflict condition type for table "profile_manager_kind"
"""
input ProfileManagerKindOnConflict {
  constraint: ProfileManagerKindConstraint!
  updateColumns: [ProfileManagerKindUpdateColumn!]! = []
  where: ProfileManagerKindBoolExp
}

"""Ordering options when selecting data from "profile_manager_kind"."""
input ProfileManagerKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_manager_kind"""
input ProfileManagerKindPkColumnsInput {
  """owner, manager, etc."""
  id: String!
  tenantId: String!
}

"""
select columns of table "profile_manager_kind"
"""
enum ProfileManagerKindSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "profile_manager_kind"
"""
input ProfileManagerKindSetInput {
  createdAt: timestamptz

  """owner, manager, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_manager_kind"
"""
input ProfileManagerKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileManagerKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileManagerKindStreamCursorValueInput {
  createdAt: timestamptz

  """owner, manager, etc."""
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "profile_manager_kind"
"""
enum ProfileManagerKindUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ProfileManagerKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileManagerKindSetInput

  """filter the rows which have to be updated"""
  where: ProfileManagerKindBoolExp!
}

"""aggregate max on columns"""
type ProfileManagerMaxFields {
  createdAt: timestamptz
  kind: String
  managedProfileId: uuid
  managerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "profile_manager"
"""
input ProfileManagerMaxOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  managedProfileId: OrderBy
  managerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ProfileManagerMinFields {
  createdAt: timestamptz
  kind: String
  managedProfileId: uuid
  managerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "profile_manager"
"""
input ProfileManagerMinOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  managedProfileId: OrderBy
  managerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "profile_manager"
"""
type ProfileManagerMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileManager!]!
}

"""
on_conflict condition type for table "profile_manager"
"""
input ProfileManagerOnConflict {
  constraint: ProfileManagerConstraint!
  updateColumns: [ProfileManagerUpdateColumn!]! = []
  where: ProfileManagerBoolExp
}

"""Ordering options when selecting data from "profile_manager"."""
input ProfileManagerOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  managedProfileId: OrderBy
  managerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: profile_manager"""
input ProfileManagerPkColumnsInput {
  managedProfileId: uuid!
  managerId: uuid!
}

"""
select columns of table "profile_manager"
"""
enum ProfileManagerSelectColumn {
  """column name"""
  createdAt

  """column name"""
  kind

  """column name"""
  managedProfileId

  """column name"""
  managerId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "profile_manager"
"""
input ProfileManagerSetInput {
  createdAt: timestamptz
  kind: String
  managedProfileId: uuid
  managerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "profile_manager"
"""
input ProfileManagerStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileManagerStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileManagerStreamCursorValueInput {
  createdAt: timestamptz
  kind: String
  managedProfileId: uuid
  managerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "profile_manager"
"""
enum ProfileManagerUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  kind

  """column name"""
  managedProfileId

  """column name"""
  managerId

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ProfileManagerUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileManagerSetInput

  """filter the rows which have to be updated"""
  where: ProfileManagerBoolExp!
}

"""aggregate max on columns"""
type ProfileMaxFields {
  """typically a device id the anonymous user registered with"""
  anonymousId: String
  bio: String
  createdAt: timestamptz

  """
  A computed field, executes function "display_name"
  """
  displayName: String
  displayNameOverride: String
  facebookUsername: String
  id: uuid
  instagramUsername: String
  kind: String
  level: Int
  locationId: uuid
  parentNodeId: uuid
  photoId: String
  startDate: date
  tenantId: String
  tiktokUsername: String
  updatedAt: timestamptz
  username: citext
  xUsername: String
}

"""
order by max() on columns of table "profile"
"""
input ProfileMaxOrderBy {
  """typically a device id the anonymous user registered with"""
  anonymousId: OrderBy
  bio: OrderBy
  createdAt: OrderBy
  displayNameOverride: OrderBy
  facebookUsername: OrderBy
  id: OrderBy
  instagramUsername: OrderBy
  kind: OrderBy
  level: OrderBy
  locationId: OrderBy
  parentNodeId: OrderBy
  photoId: OrderBy
  startDate: OrderBy
  tenantId: OrderBy
  tiktokUsername: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  xUsername: OrderBy
}

"""aggregate min on columns"""
type ProfileMinFields {
  """typically a device id the anonymous user registered with"""
  anonymousId: String
  bio: String
  createdAt: timestamptz

  """
  A computed field, executes function "display_name"
  """
  displayName: String
  displayNameOverride: String
  facebookUsername: String
  id: uuid
  instagramUsername: String
  kind: String
  level: Int
  locationId: uuid
  parentNodeId: uuid
  photoId: String
  startDate: date
  tenantId: String
  tiktokUsername: String
  updatedAt: timestamptz
  username: citext
  xUsername: String
}

"""
order by min() on columns of table "profile"
"""
input ProfileMinOrderBy {
  """typically a device id the anonymous user registered with"""
  anonymousId: OrderBy
  bio: OrderBy
  createdAt: OrderBy
  displayNameOverride: OrderBy
  facebookUsername: OrderBy
  id: OrderBy
  instagramUsername: OrderBy
  kind: OrderBy
  level: OrderBy
  locationId: OrderBy
  parentNodeId: OrderBy
  photoId: OrderBy
  startDate: OrderBy
  tenantId: OrderBy
  tiktokUsername: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  xUsername: OrderBy
}

"""
response of any mutation on the table "profile"
"""
type ProfileMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Profile!]!
}

"""
input type for inserting object relation for remote table "profile"
"""
input ProfileObjRelInsertInput {
  data: ProfileInsertInput!

  """upsert condition"""
  onConflict: ProfileOnConflict
}

"""
on_conflict condition type for table "profile"
"""
input ProfileOnConflict {
  constraint: ProfileConstraint!
  updateColumns: [ProfileUpdateColumn!]! = []
  where: ProfileBoolExp
}

"""Ordering options when selecting data from "profile"."""
input ProfileOrderBy {
  anonymousId: OrderBy
  attributesAggregate: ProfileAttributeAggregateOrderBy
  bio: OrderBy
  childProfileNodesAggregate: ProfileAggregateOrderBy
  createdAt: OrderBy
  devicesAggregate: ProfileDeviceAggregateOrderBy
  displayName: OrderBy
  displayNameOverride: OrderBy
  facebookUsername: OrderBy
  followedProfilesAggregate: ProfileFollowerAggregateOrderBy
  followersAggregate: ProfileFollowerAggregateOrderBy
  id: OrderBy
  identity: ProfileIdentityOrderBy
  instagramUsername: OrderBy
  isDeleted: OrderBy
  kind: OrderBy
  level: OrderBy
  location: GeoLocationOrderBy
  locationId: OrderBy
  logsAggregate: LogAggregateOrderBy
  managedProfilesAggregate: ProfileManagerAggregateOrderBy
  metaData: OrderBy
  optInsAggregate: ContactOptInAggregateOrderBy
  ordersAggregate: ShopOrderAggregateOrderBy
  parentNodeId: OrderBy
  parentProfileNode: ProfileOrderBy
  photo: MediaItemOrderBy
  photoId: OrderBy
  postsCreatedAggregate: PostAggregateOrderBy
  postsToProfileAggregate: PostAggregateOrderBy
  profileManagersAggregate: ProfileManagerAggregateOrderBy
  profileStatsAggregate: ProfileStatAggregateOrderBy
  sessionsAggregate: AuthSessionAggregateOrderBy
  startDate: OrderBy
  subscriptionsAggregate: ShopSubscriptionAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  tiktokUsername: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  xUsername: OrderBy
}

"""primary key columns input for table: profile"""
input ProfilePkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ProfilePrependInput {
  metaData: jsonb
}

"""
select columns of table "profile"
"""
enum ProfileSelectColumn {
  """column name"""
  anonymousId

  """column name"""
  bio

  """column name"""
  createdAt

  """column name"""
  displayNameOverride

  """column name"""
  facebookUsername

  """column name"""
  id

  """column name"""
  instagramUsername

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  level

  """column name"""
  locationId

  """column name"""
  metaData

  """column name"""
  parentNodeId

  """column name"""
  photoId

  """column name"""
  startDate

  """column name"""
  tenantId

  """column name"""
  tiktokUsername

  """column name"""
  updatedAt

  """column name"""
  username

  """column name"""
  xUsername
}

"""
select "profileAggregateBoolExpBool_andArgumentsColumns" columns of table "profile"
"""
enum ProfileSelectColumnProfileAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isDeleted
}

"""
select "profileAggregateBoolExpBool_orArgumentsColumns" columns of table "profile"
"""
enum ProfileSelectColumnProfileAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isDeleted
}

"""
input type for updating data in table "profile"
"""
input ProfileSetInput {
  """typically a device id the anonymous user registered with"""
  anonymousId: String
  bio: String
  createdAt: timestamptz
  displayNameOverride: String
  facebookUsername: String
  id: uuid
  instagramUsername: String
  isDeleted: Boolean
  kind: String
  level: Int
  locationId: uuid
  metaData: jsonb
  parentNodeId: uuid
  photoId: String
  startDate: date
  tenantId: String
  tiktokUsername: String
  updatedAt: timestamptz
  username: citext
  xUsername: String
}

input ProfileSetParentNodeInput {
  parentId: uuid!
  profileId: uuid!
}

type ProfileSetParentNodeOutput {
  message: String!
  success: Boolean!
}

"""
columns and relationships of "profile_stat"
"""
type ProfileStat {
  createdAt: timestamptz!
  date: date
  id: uuid!
  kind: String!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  tenantId: String!
  timestamp: timestamptz
  updatedAt: timestamptz!
  value: numeric!
  visibility: VisibilityKindEnum!
}

"""
aggregated selection of "profile_stat"
"""
type ProfileStatAggregate {
  aggregate: ProfileStatAggregateFields
  nodes: [ProfileStat!]!
}

input ProfileStatAggregateBoolExp {
  count: profileStatAggregateBoolExpCount
}

"""
aggregate fields of "profile_stat"
"""
type ProfileStatAggregateFields {
  avg: ProfileStatAvgFields
  count(columns: [ProfileStatSelectColumn!], distinct: Boolean): Int!
  max: ProfileStatMaxFields
  min: ProfileStatMinFields
  stddev: ProfileStatStddevFields
  stddevPop: ProfileStatStddevPopFields
  stddevSamp: ProfileStatStddevSampFields
  sum: ProfileStatSumFields
  varPop: ProfileStatVarPopFields
  varSamp: ProfileStatVarSampFields
  variance: ProfileStatVarianceFields
}

"""
order by aggregate values of table "profile_stat"
"""
input ProfileStatAggregateOrderBy {
  avg: ProfileStatAvgOrderBy
  count: OrderBy
  max: ProfileStatMaxOrderBy
  min: ProfileStatMinOrderBy
  stddev: ProfileStatStddevOrderBy
  stddevPop: ProfileStatStddevPopOrderBy
  stddevSamp: ProfileStatStddevSampOrderBy
  sum: ProfileStatSumOrderBy
  varPop: ProfileStatVarPopOrderBy
  varSamp: ProfileStatVarSampOrderBy
  variance: ProfileStatVarianceOrderBy
}

"""
input type for inserting array relation for remote table "profile_stat"
"""
input ProfileStatArrRelInsertInput {
  data: [ProfileStatInsertInput!]!

  """upsert condition"""
  onConflict: ProfileStatOnConflict
}

"""aggregate avg on columns"""
type ProfileStatAvgFields {
  value: Float
}

"""
order by avg() on columns of table "profile_stat"
"""
input ProfileStatAvgOrderBy {
  value: OrderBy
}

"""
Boolean expression to filter rows from the table "profile_stat". All fields are combined with a logical 'AND'.
"""
input ProfileStatBoolExp {
  _and: [ProfileStatBoolExp!]
  _not: ProfileStatBoolExp
  _or: [ProfileStatBoolExp!]
  createdAt: TimestamptzComparisonExp
  date: DateComparisonExp
  id: UuidComparisonExp
  kind: StringComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  tenantId: StringComparisonExp
  timestamp: TimestamptzComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: NumericComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "profile_stat"
"""
enum ProfileStatConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  profile_stat_pkey
}

"""
input type for incrementing numeric columns in table "profile_stat"
"""
input ProfileStatIncInput {
  value: numeric
}

"""
input type for inserting data into table "profile_stat"
"""
input ProfileStatInsertInput {
  createdAt: timestamptz
  date: date
  id: uuid
  kind: String
  profile: ProfileObjRelInsertInput
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
  value: numeric
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "profile_stat_kind"
"""
type ProfileStatKind {
  id: String!
  tenantId: String!
}

"""
aggregated selection of "profile_stat_kind"
"""
type ProfileStatKindAggregate {
  aggregate: ProfileStatKindAggregateFields
  nodes: [ProfileStatKind!]!
}

"""
aggregate fields of "profile_stat_kind"
"""
type ProfileStatKindAggregateFields {
  count(columns: [ProfileStatKindSelectColumn!], distinct: Boolean): Int!
  max: ProfileStatKindMaxFields
  min: ProfileStatKindMinFields
}

"""
Boolean expression to filter rows from the table "profile_stat_kind". All fields are combined with a logical 'AND'.
"""
input ProfileStatKindBoolExp {
  _and: [ProfileStatKindBoolExp!]
  _not: ProfileStatKindBoolExp
  _or: [ProfileStatKindBoolExp!]
  id: StringComparisonExp
  tenantId: StringComparisonExp
}

"""
unique or primary key constraints on table "profile_stat_kind"
"""
enum ProfileStatKindConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  profile_stat_kind_pkey
}

"""
input type for inserting data into table "profile_stat_kind"
"""
input ProfileStatKindInsertInput {
  id: String
  tenantId: String
}

"""aggregate max on columns"""
type ProfileStatKindMaxFields {
  id: String
  tenantId: String
}

"""aggregate min on columns"""
type ProfileStatKindMinFields {
  id: String
  tenantId: String
}

"""
response of any mutation on the table "profile_stat_kind"
"""
type ProfileStatKindMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileStatKind!]!
}

"""
on_conflict condition type for table "profile_stat_kind"
"""
input ProfileStatKindOnConflict {
  constraint: ProfileStatKindConstraint!
  updateColumns: [ProfileStatKindUpdateColumn!]! = []
  where: ProfileStatKindBoolExp
}

"""Ordering options when selecting data from "profile_stat_kind"."""
input ProfileStatKindOrderBy {
  id: OrderBy
  tenantId: OrderBy
}

"""primary key columns input for table: profile_stat_kind"""
input ProfileStatKindPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
select columns of table "profile_stat_kind"
"""
enum ProfileStatKindSelectColumn {
  """column name"""
  id

  """column name"""
  tenantId
}

"""
input type for updating data in table "profile_stat_kind"
"""
input ProfileStatKindSetInput {
  id: String
  tenantId: String
}

"""
Streaming cursor of the table "profile_stat_kind"
"""
input ProfileStatKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileStatKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileStatKindStreamCursorValueInput {
  id: String
  tenantId: String
}

"""
update columns of table "profile_stat_kind"
"""
enum ProfileStatKindUpdateColumn {
  """column name"""
  id

  """column name"""
  tenantId
}

input ProfileStatKindUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ProfileStatKindSetInput

  """filter the rows which have to be updated"""
  where: ProfileStatKindBoolExp!
}

"""aggregate max on columns"""
type ProfileStatMaxFields {
  createdAt: timestamptz
  date: date
  id: uuid
  kind: String
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
  value: numeric
}

"""
order by max() on columns of table "profile_stat"
"""
input ProfileStatMaxOrderBy {
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  kind: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""aggregate min on columns"""
type ProfileStatMinFields {
  createdAt: timestamptz
  date: date
  id: uuid
  kind: String
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
  value: numeric
}

"""
order by min() on columns of table "profile_stat"
"""
input ProfileStatMinOrderBy {
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  kind: OrderBy
  profileId: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""
response of any mutation on the table "profile_stat"
"""
type ProfileStatMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProfileStat!]!
}

"""
on_conflict condition type for table "profile_stat"
"""
input ProfileStatOnConflict {
  constraint: ProfileStatConstraint!
  updateColumns: [ProfileStatUpdateColumn!]! = []
  where: ProfileStatBoolExp
}

"""Ordering options when selecting data from "profile_stat"."""
input ProfileStatOrderBy {
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  kind: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  tenantId: OrderBy
  timestamp: OrderBy
  updatedAt: OrderBy
  value: OrderBy
  visibility: OrderBy
}

"""primary key columns input for table: profile_stat"""
input ProfileStatPkColumnsInput {
  id: uuid!
}

"""
select columns of table "profile_stat"
"""
enum ProfileStatSelectColumn {
  """column name"""
  createdAt

  """column name"""
  date

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  timestamp

  """column name"""
  updatedAt

  """column name"""
  value

  """column name"""
  visibility
}

"""
input type for updating data in table "profile_stat"
"""
input ProfileStatSetInput {
  createdAt: timestamptz
  date: date
  id: uuid
  kind: String
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
  value: numeric
  visibility: VisibilityKindEnum
}

"""aggregate stddev on columns"""
type ProfileStatStddevFields {
  value: Float
}

"""
order by stddev() on columns of table "profile_stat"
"""
input ProfileStatStddevOrderBy {
  value: OrderBy
}

"""aggregate stddevPop on columns"""
type ProfileStatStddevPopFields {
  value: Float
}

"""
order by stddevPop() on columns of table "profile_stat"
"""
input ProfileStatStddevPopOrderBy {
  value: OrderBy
}

"""aggregate stddevSamp on columns"""
type ProfileStatStddevSampFields {
  value: Float
}

"""
order by stddevSamp() on columns of table "profile_stat"
"""
input ProfileStatStddevSampOrderBy {
  value: OrderBy
}

"""
Streaming cursor of the table "profile_stat"
"""
input ProfileStatStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileStatStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileStatStreamCursorValueInput {
  createdAt: timestamptz
  date: date
  id: uuid
  kind: String
  profileId: uuid
  tenantId: String
  timestamp: timestamptz
  updatedAt: timestamptz
  value: numeric
  visibility: VisibilityKindEnum
}

"""aggregate sum on columns"""
type ProfileStatSumFields {
  value: numeric
}

"""
order by sum() on columns of table "profile_stat"
"""
input ProfileStatSumOrderBy {
  value: OrderBy
}

"""
update columns of table "profile_stat"
"""
enum ProfileStatUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  date

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  profileId

  """column name"""
  tenantId

  """column name"""
  timestamp

  """column name"""
  updatedAt

  """column name"""
  value

  """column name"""
  visibility
}

input ProfileStatUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProfileStatIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProfileStatSetInput

  """filter the rows which have to be updated"""
  where: ProfileStatBoolExp!
}

"""aggregate varPop on columns"""
type ProfileStatVarPopFields {
  value: Float
}

"""
order by varPop() on columns of table "profile_stat"
"""
input ProfileStatVarPopOrderBy {
  value: OrderBy
}

"""aggregate varSamp on columns"""
type ProfileStatVarSampFields {
  value: Float
}

"""
order by varSamp() on columns of table "profile_stat"
"""
input ProfileStatVarSampOrderBy {
  value: OrderBy
}

"""aggregate variance on columns"""
type ProfileStatVarianceFields {
  value: Float
}

"""
order by variance() on columns of table "profile_stat"
"""
input ProfileStatVarianceOrderBy {
  value: OrderBy
}

"""aggregate stddev on columns"""
type ProfileStddevFields {
  level: Float
}

"""
order by stddev() on columns of table "profile"
"""
input ProfileStddevOrderBy {
  level: OrderBy
}

"""aggregate stddevPop on columns"""
type ProfileStddevPopFields {
  level: Float
}

"""
order by stddevPop() on columns of table "profile"
"""
input ProfileStddevPopOrderBy {
  level: OrderBy
}

"""aggregate stddevSamp on columns"""
type ProfileStddevSampFields {
  level: Float
}

"""
order by stddevSamp() on columns of table "profile"
"""
input ProfileStddevSampOrderBy {
  level: OrderBy
}

"""
Streaming cursor of the table "profile"
"""
input ProfileStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileStreamCursorValueInput {
  """typically a device id the anonymous user registered with"""
  anonymousId: String
  bio: String
  createdAt: timestamptz
  displayNameOverride: String
  facebookUsername: String
  id: uuid
  instagramUsername: String
  isDeleted: Boolean
  kind: String
  level: Int
  locationId: uuid
  metaData: jsonb
  parentNodeId: uuid
  photoId: String
  startDate: date
  tenantId: String
  tiktokUsername: String
  updatedAt: timestamptz
  username: citext
  xUsername: String
}

"""aggregate sum on columns"""
type ProfileSumFields {
  level: Int
}

"""
order by sum() on columns of table "profile"
"""
input ProfileSumOrderBy {
  level: OrderBy
}

"""
update columns of table "profile"
"""
enum ProfileUpdateColumn {
  """column name"""
  anonymousId

  """column name"""
  bio

  """column name"""
  createdAt

  """column name"""
  displayNameOverride

  """column name"""
  facebookUsername

  """column name"""
  id

  """column name"""
  instagramUsername

  """column name"""
  isDeleted

  """column name"""
  kind

  """column name"""
  level

  """column name"""
  locationId

  """column name"""
  metaData

  """column name"""
  parentNodeId

  """column name"""
  photoId

  """column name"""
  startDate

  """column name"""
  tenantId

  """column name"""
  tiktokUsername

  """column name"""
  updatedAt

  """column name"""
  username

  """column name"""
  xUsername
}

input ProfileUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ProfileAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ProfileDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ProfileDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ProfileDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: ProfileIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ProfilePrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ProfileSetInput

  """filter the rows which have to be updated"""
  where: ProfileBoolExp!
}

"""aggregate varPop on columns"""
type ProfileVarPopFields {
  level: Float
}

"""
order by varPop() on columns of table "profile"
"""
input ProfileVarPopOrderBy {
  level: OrderBy
}

"""aggregate varSamp on columns"""
type ProfileVarSampFields {
  level: Float
}

"""
order by varSamp() on columns of table "profile"
"""
input ProfileVarSampOrderBy {
  level: OrderBy
}

"""aggregate variance on columns"""
type ProfileVarianceFields {
  level: Float
}

"""
order by variance() on columns of table "profile"
"""
input ProfileVarianceOrderBy {
  level: OrderBy
}

"""
columns and relationships of "question"
"""
type Question {
  afterDurationSecondsOverride: Int
  afterImageIdOrUrl: String
  afterText: String
  createdAt: timestamptz!
  description: String
  durationSecondsOverride: Int
  id: uuid!
  kind: QuestionKindEnum!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinctOn: [QuestionOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOptionOrderBy!]

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): [QuestionOption!]!

  """An aggregate relationship"""
  optionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOptionOrderBy!]

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): QuestionOptionAggregate!
  order: Int!

  """An object relationship"""
  questionSet: QuestionSet!
  questionSetId: uuid!
  responseValueKind: ValueKindEnum!

  """An array relationship"""
  responses(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): [QuestionResponse!]!

  """An aggregate relationship"""
  responsesAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): QuestionResponseAggregate!
  tenantId: String!
  title: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "question"
"""
type QuestionAggregate {
  aggregate: QuestionAggregateFields
  nodes: [Question!]!
}

input QuestionAggregateBoolExp {
  count: questionAggregateBoolExpCount
}

"""
aggregate fields of "question"
"""
type QuestionAggregateFields {
  avg: QuestionAvgFields
  count(columns: [QuestionSelectColumn!], distinct: Boolean): Int!
  max: QuestionMaxFields
  min: QuestionMinFields
  stddev: QuestionStddevFields
  stddevPop: QuestionStddevPopFields
  stddevSamp: QuestionStddevSampFields
  sum: QuestionSumFields
  varPop: QuestionVarPopFields
  varSamp: QuestionVarSampFields
  variance: QuestionVarianceFields
}

"""
order by aggregate values of table "question"
"""
input QuestionAggregateOrderBy {
  avg: QuestionAvgOrderBy
  count: OrderBy
  max: QuestionMaxOrderBy
  min: QuestionMinOrderBy
  stddev: QuestionStddevOrderBy
  stddevPop: QuestionStddevPopOrderBy
  stddevSamp: QuestionStddevSampOrderBy
  sum: QuestionSumOrderBy
  varPop: QuestionVarPopOrderBy
  varSamp: QuestionVarSampOrderBy
  variance: QuestionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "question"
"""
input QuestionArrRelInsertInput {
  data: [QuestionInsertInput!]!

  """upsert condition"""
  onConflict: QuestionOnConflict
}

"""aggregate avg on columns"""
type QuestionAvgFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by avg() on columns of table "question"
"""
input QuestionAvgOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "question". All fields are combined with a logical 'AND'.
"""
input QuestionBoolExp {
  _and: [QuestionBoolExp!]
  _not: QuestionBoolExp
  _or: [QuestionBoolExp!]
  afterDurationSecondsOverride: IntComparisonExp
  afterImageIdOrUrl: StringComparisonExp
  afterText: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  durationSecondsOverride: IntComparisonExp
  id: UuidComparisonExp
  kind: QuestionKindEnumComparisonExp
  options: QuestionOptionBoolExp
  optionsAggregate: QuestionOptionAggregateBoolExp
  order: IntComparisonExp
  questionSet: QuestionSetBoolExp
  questionSetId: UuidComparisonExp
  responseValueKind: ValueKindEnumComparisonExp
  responses: QuestionResponseBoolExp
  responsesAggregate: QuestionResponseAggregateBoolExp
  tenantId: StringComparisonExp
  title: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "question"
"""
enum QuestionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  question_pkey
}

"""
input type for incrementing numeric columns in table "question"
"""
input QuestionIncInput {
  afterDurationSecondsOverride: Int
  durationSecondsOverride: Int
  order: Int
}

"""
input type for inserting data into table "question"
"""
input QuestionInsertInput {
  afterDurationSecondsOverride: Int
  afterImageIdOrUrl: String
  afterText: String
  createdAt: timestamptz
  description: String
  durationSecondsOverride: Int
  id: uuid
  kind: QuestionKindEnum
  options: QuestionOptionArrRelInsertInput
  order: Int
  questionSet: QuestionSetObjRelInsertInput
  questionSetId: uuid
  responseValueKind: ValueKindEnum
  responses: QuestionResponseArrRelInsertInput
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
columns and relationships of "question_kind"
"""
type QuestionKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "question_kind". All fields are combined with a logical 'AND'.
"""
input QuestionKindBoolExp {
  _and: [QuestionKindBoolExp!]
  _not: QuestionKindBoolExp
  _or: [QuestionKindBoolExp!]
  id: StringComparisonExp
}

enum QuestionKindEnum {
  POLL
  QUIZ
  RAFFLE
  SURVEY
}

"""
Boolean expression to compare columns of type "QuestionKindEnum". All fields are combined with logical 'AND'.
"""
input QuestionKindEnumComparisonExp {
  _eq: QuestionKindEnum
  _in: [QuestionKindEnum!]
  _isNull: Boolean
  _neq: QuestionKindEnum
  _nin: [QuestionKindEnum!]
}

"""Ordering options when selecting data from "question_kind"."""
input QuestionKindOrderBy {
  id: OrderBy
}

"""
select columns of table "question_kind"
"""
enum QuestionKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "question_kind"
"""
input QuestionKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuestionKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuestionKindStreamCursorValueInput {
  id: String
}

"""aggregate max on columns"""
type QuestionMaxFields {
  afterDurationSecondsOverride: Int
  afterImageIdOrUrl: String
  afterText: String
  createdAt: timestamptz
  description: String
  durationSecondsOverride: Int
  id: uuid
  order: Int
  questionSetId: uuid
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "question"
"""
input QuestionMaxOrderBy {
  afterDurationSecondsOverride: OrderBy
  afterImageIdOrUrl: OrderBy
  afterText: OrderBy
  createdAt: OrderBy
  description: OrderBy
  durationSecondsOverride: OrderBy
  id: OrderBy
  order: OrderBy
  questionSetId: OrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type QuestionMinFields {
  afterDurationSecondsOverride: Int
  afterImageIdOrUrl: String
  afterText: String
  createdAt: timestamptz
  description: String
  durationSecondsOverride: Int
  id: uuid
  order: Int
  questionSetId: uuid
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "question"
"""
input QuestionMinOrderBy {
  afterDurationSecondsOverride: OrderBy
  afterImageIdOrUrl: OrderBy
  afterText: OrderBy
  createdAt: OrderBy
  description: OrderBy
  durationSecondsOverride: OrderBy
  id: OrderBy
  order: OrderBy
  questionSetId: OrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "question"
"""
type QuestionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [Question!]!
}

"""
input type for inserting object relation for remote table "question"
"""
input QuestionObjRelInsertInput {
  data: QuestionInsertInput!

  """upsert condition"""
  onConflict: QuestionOnConflict
}

"""
on_conflict condition type for table "question"
"""
input QuestionOnConflict {
  constraint: QuestionConstraint!
  updateColumns: [QuestionUpdateColumn!]! = []
  where: QuestionBoolExp
}

"""
columns and relationships of "question_option"
"""
type QuestionOption {
  createdAt: timestamptz!
  description: String
  id: uuid!
  isCorrect: Boolean
  isInput: Boolean!
  order: Int

  """An object relationship"""
  question: Question!
  questionId: uuid!

  """An array relationship"""
  responses(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): [QuestionResponse!]!

  """An aggregate relationship"""
  responsesAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): QuestionResponseAggregate!
  tenantId: String!
  title: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "question_option"
"""
type QuestionOptionAggregate {
  aggregate: QuestionOptionAggregateFields
  nodes: [QuestionOption!]!
}

input QuestionOptionAggregateBoolExp {
  bool_and: questionOptionAggregateBoolExpBool_and
  bool_or: questionOptionAggregateBoolExpBool_or
  count: questionOptionAggregateBoolExpCount
}

"""
aggregate fields of "question_option"
"""
type QuestionOptionAggregateFields {
  avg: QuestionOptionAvgFields
  count(columns: [QuestionOptionSelectColumn!], distinct: Boolean): Int!
  max: QuestionOptionMaxFields
  min: QuestionOptionMinFields
  stddev: QuestionOptionStddevFields
  stddevPop: QuestionOptionStddevPopFields
  stddevSamp: QuestionOptionStddevSampFields
  sum: QuestionOptionSumFields
  varPop: QuestionOptionVarPopFields
  varSamp: QuestionOptionVarSampFields
  variance: QuestionOptionVarianceFields
}

"""
order by aggregate values of table "question_option"
"""
input QuestionOptionAggregateOrderBy {
  avg: QuestionOptionAvgOrderBy
  count: OrderBy
  max: QuestionOptionMaxOrderBy
  min: QuestionOptionMinOrderBy
  stddev: QuestionOptionStddevOrderBy
  stddevPop: QuestionOptionStddevPopOrderBy
  stddevSamp: QuestionOptionStddevSampOrderBy
  sum: QuestionOptionSumOrderBy
  varPop: QuestionOptionVarPopOrderBy
  varSamp: QuestionOptionVarSampOrderBy
  variance: QuestionOptionVarianceOrderBy
}

"""
input type for inserting array relation for remote table "question_option"
"""
input QuestionOptionArrRelInsertInput {
  data: [QuestionOptionInsertInput!]!

  """upsert condition"""
  onConflict: QuestionOptionOnConflict
}

"""aggregate avg on columns"""
type QuestionOptionAvgFields {
  order: Float
}

"""
order by avg() on columns of table "question_option"
"""
input QuestionOptionAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "question_option". All fields are combined with a logical 'AND'.
"""
input QuestionOptionBoolExp {
  _and: [QuestionOptionBoolExp!]
  _not: QuestionOptionBoolExp
  _or: [QuestionOptionBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  isCorrect: BooleanComparisonExp
  isInput: BooleanComparisonExp
  order: IntComparisonExp
  question: QuestionBoolExp
  questionId: UuidComparisonExp
  responses: QuestionResponseBoolExp
  responsesAggregate: QuestionResponseAggregateBoolExp
  tenantId: StringComparisonExp
  title: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "question_option"
"""
enum QuestionOptionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  question_option_pkey
}

"""
input type for incrementing numeric columns in table "question_option"
"""
input QuestionOptionIncInput {
  order: Int
}

"""
input type for inserting data into table "question_option"
"""
input QuestionOptionInsertInput {
  createdAt: timestamptz
  description: String
  id: uuid
  isCorrect: Boolean
  isInput: Boolean
  order: Int
  question: QuestionObjRelInsertInput
  questionId: uuid
  responses: QuestionResponseArrRelInsertInput
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type QuestionOptionMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  order: Int
  questionId: uuid
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "question_option"
"""
input QuestionOptionMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  order: OrderBy
  questionId: OrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type QuestionOptionMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  order: Int
  questionId: uuid
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "question_option"
"""
input QuestionOptionMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  order: OrderBy
  questionId: OrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "question_option"
"""
type QuestionOptionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [QuestionOption!]!
}

"""
input type for inserting object relation for remote table "question_option"
"""
input QuestionOptionObjRelInsertInput {
  data: QuestionOptionInsertInput!

  """upsert condition"""
  onConflict: QuestionOptionOnConflict
}

"""
on_conflict condition type for table "question_option"
"""
input QuestionOptionOnConflict {
  constraint: QuestionOptionConstraint!
  updateColumns: [QuestionOptionUpdateColumn!]! = []
  where: QuestionOptionBoolExp
}

"""Ordering options when selecting data from "question_option"."""
input QuestionOptionOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  isCorrect: OrderBy
  isInput: OrderBy
  order: OrderBy
  question: QuestionOrderBy
  questionId: OrderBy
  responsesAggregate: QuestionResponseAggregateOrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: question_option"""
input QuestionOptionPkColumnsInput {
  id: uuid!
}

"""
select columns of table "question_option"
"""
enum QuestionOptionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  isCorrect

  """column name"""
  isInput

  """column name"""
  order

  """column name"""
  questionId

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt
}

"""
select "questionOptionAggregateBoolExpBool_andArgumentsColumns" columns of table "question_option"
"""
enum QuestionOptionSelectColumnQuestionOptionAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isCorrect

  """column name"""
  isInput
}

"""
select "questionOptionAggregateBoolExpBool_orArgumentsColumns" columns of table "question_option"
"""
enum QuestionOptionSelectColumnQuestionOptionAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isCorrect

  """column name"""
  isInput
}

"""
input type for updating data in table "question_option"
"""
input QuestionOptionSetInput {
  createdAt: timestamptz
  description: String
  id: uuid
  isCorrect: Boolean
  isInput: Boolean
  order: Int
  questionId: uuid
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type QuestionOptionStddevFields {
  order: Float
}

"""
order by stddev() on columns of table "question_option"
"""
input QuestionOptionStddevOrderBy {
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type QuestionOptionStddevPopFields {
  order: Float
}

"""
order by stddevPop() on columns of table "question_option"
"""
input QuestionOptionStddevPopOrderBy {
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type QuestionOptionStddevSampFields {
  order: Float
}

"""
order by stddevSamp() on columns of table "question_option"
"""
input QuestionOptionStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "question_option"
"""
input QuestionOptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuestionOptionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuestionOptionStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  isCorrect: Boolean
  isInput: Boolean
  order: Int
  questionId: uuid
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type QuestionOptionSumFields {
  order: Int
}

"""
order by sum() on columns of table "question_option"
"""
input QuestionOptionSumOrderBy {
  order: OrderBy
}

"""
update columns of table "question_option"
"""
enum QuestionOptionUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  isCorrect

  """column name"""
  isInput

  """column name"""
  order

  """column name"""
  questionId

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt
}

input QuestionOptionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuestionOptionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: QuestionOptionSetInput

  """filter the rows which have to be updated"""
  where: QuestionOptionBoolExp!
}

"""aggregate varPop on columns"""
type QuestionOptionVarPopFields {
  order: Float
}

"""
order by varPop() on columns of table "question_option"
"""
input QuestionOptionVarPopOrderBy {
  order: OrderBy
}

"""aggregate varSamp on columns"""
type QuestionOptionVarSampFields {
  order: Float
}

"""
order by varSamp() on columns of table "question_option"
"""
input QuestionOptionVarSampOrderBy {
  order: OrderBy
}

"""aggregate variance on columns"""
type QuestionOptionVarianceFields {
  order: Float
}

"""
order by variance() on columns of table "question_option"
"""
input QuestionOptionVarianceOrderBy {
  order: OrderBy
}

"""Ordering options when selecting data from "question"."""
input QuestionOrderBy {
  afterDurationSecondsOverride: OrderBy
  afterImageIdOrUrl: OrderBy
  afterText: OrderBy
  createdAt: OrderBy
  description: OrderBy
  durationSecondsOverride: OrderBy
  id: OrderBy
  kind: OrderBy
  optionsAggregate: QuestionOptionAggregateOrderBy
  order: OrderBy
  questionSet: QuestionSetOrderBy
  questionSetId: OrderBy
  responseValueKind: OrderBy
  responsesAggregate: QuestionResponseAggregateOrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: question"""
input QuestionPkColumnsInput {
  id: uuid!
}

"""
columns and relationships of "question_response"
"""
type QuestionResponse {
  createdAt: timestamptz!

  """An object relationship"""
  event: Event
  eventId: uuid
  eventLiveId: String
  id: uuid!

  """An object relationship"""
  option: QuestionOption
  optionId: uuid
  profileId: uuid!

  """An object relationship"""
  question: Question!
  questionId: uuid!
  questionSetId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
  value: String!
}

"""
aggregated selection of "question_response"
"""
type QuestionResponseAggregate {
  aggregate: QuestionResponseAggregateFields
  nodes: [QuestionResponse!]!
}

input QuestionResponseAggregateBoolExp {
  count: questionResponseAggregateBoolExpCount
}

"""
aggregate fields of "question_response"
"""
type QuestionResponseAggregateFields {
  count(columns: [QuestionResponseSelectColumn!], distinct: Boolean): Int!
  max: QuestionResponseMaxFields
  min: QuestionResponseMinFields
}

"""
order by aggregate values of table "question_response"
"""
input QuestionResponseAggregateOrderBy {
  count: OrderBy
  max: QuestionResponseMaxOrderBy
  min: QuestionResponseMinOrderBy
}

"""
input type for inserting array relation for remote table "question_response"
"""
input QuestionResponseArrRelInsertInput {
  data: [QuestionResponseInsertInput!]!

  """upsert condition"""
  onConflict: QuestionResponseOnConflict
}

"""
Boolean expression to filter rows from the table "question_response". All fields are combined with a logical 'AND'.
"""
input QuestionResponseBoolExp {
  _and: [QuestionResponseBoolExp!]
  _not: QuestionResponseBoolExp
  _or: [QuestionResponseBoolExp!]
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: UuidComparisonExp
  eventLiveId: StringComparisonExp
  id: UuidComparisonExp
  option: QuestionOptionBoolExp
  optionId: UuidComparisonExp
  profileId: UuidComparisonExp
  question: QuestionBoolExp
  questionId: UuidComparisonExp
  questionSetId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
unique or primary key constraints on table "question_response"
"""
enum QuestionResponseConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  question_response_pkey

  """
  unique or primary key constraint on columns "option_id", "question_id", "event_live_id", "profile_id", "tenant_id"
  """
  question_response_tenant_id_question_id_profile_id_option_id_ev
}

"""
input type for inserting data into table "question_response"
"""
input QuestionResponseInsertInput {
  createdAt: timestamptz
  event: EventObjRelInsertInput
  eventId: uuid
  eventLiveId: String
  id: uuid
  option: QuestionOptionObjRelInsertInput
  optionId: uuid
  profileId: uuid
  question: QuestionObjRelInsertInput
  questionId: uuid
  questionSetId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""aggregate max on columns"""
type QuestionResponseMaxFields {
  createdAt: timestamptz
  eventId: uuid
  eventLiveId: String
  id: uuid
  optionId: uuid
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""
order by max() on columns of table "question_response"
"""
input QuestionResponseMaxOrderBy {
  createdAt: OrderBy
  eventId: OrderBy
  eventLiveId: OrderBy
  id: OrderBy
  optionId: OrderBy
  profileId: OrderBy
  questionId: OrderBy
  questionSetId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""aggregate min on columns"""
type QuestionResponseMinFields {
  createdAt: timestamptz
  eventId: uuid
  eventLiveId: String
  id: uuid
  optionId: uuid
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""
order by min() on columns of table "question_response"
"""
input QuestionResponseMinOrderBy {
  createdAt: OrderBy
  eventId: OrderBy
  eventLiveId: OrderBy
  id: OrderBy
  optionId: OrderBy
  profileId: OrderBy
  questionId: OrderBy
  questionSetId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""
response of any mutation on the table "question_response"
"""
type QuestionResponseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [QuestionResponse!]!
}

"""
on_conflict condition type for table "question_response"
"""
input QuestionResponseOnConflict {
  constraint: QuestionResponseConstraint!
  updateColumns: [QuestionResponseUpdateColumn!]! = []
  where: QuestionResponseBoolExp
}

"""Ordering options when selecting data from "question_response"."""
input QuestionResponseOrderBy {
  createdAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  eventLiveId: OrderBy
  id: OrderBy
  option: QuestionOptionOrderBy
  optionId: OrderBy
  profileId: OrderBy
  question: QuestionOrderBy
  questionId: OrderBy
  questionSetId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""primary key columns input for table: question_response"""
input QuestionResponsePkColumnsInput {
  id: uuid!
}

"""
select columns of table "question_response"
"""
enum QuestionResponseSelectColumn {
  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  eventLiveId

  """column name"""
  id

  """column name"""
  optionId

  """column name"""
  profileId

  """column name"""
  questionId

  """column name"""
  questionSetId

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  value
}

"""
input type for updating data in table "question_response"
"""
input QuestionResponseSetInput {
  createdAt: timestamptz
  eventId: uuid
  eventLiveId: String
  id: uuid
  optionId: uuid
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""
Streaming cursor of the table "question_response"
"""
input QuestionResponseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuestionResponseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuestionResponseStreamCursorValueInput {
  createdAt: timestamptz
  eventId: uuid
  eventLiveId: String
  id: uuid
  optionId: uuid
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  tenantId: String
  updatedAt: timestamptz
  value: String
}

"""
update columns of table "question_response"
"""
enum QuestionResponseUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  eventId

  """column name"""
  eventLiveId

  """column name"""
  id

  """column name"""
  optionId

  """column name"""
  profileId

  """column name"""
  questionId

  """column name"""
  questionSetId

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  value
}

input QuestionResponseUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: QuestionResponseSetInput

  """filter the rows which have to be updated"""
  where: QuestionResponseBoolExp!
}

"""
select columns of table "question"
"""
enum QuestionSelectColumn {
  """column name"""
  afterDurationSecondsOverride

  """column name"""
  afterImageIdOrUrl

  """column name"""
  afterText

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  durationSecondsOverride

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  order

  """column name"""
  questionSetId

  """column name"""
  responseValueKind

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt
}

"""
columns and relationships of "question_set"
"""
type QuestionSet {
  afterQuestionDurationSeconds: Int
  createdAt: timestamptz!
  description: String
  id: uuid!
  profileId: uuid!
  questionDurationSeconds: Int
  questionKind: QuestionKindEnum!

  """An array relationship"""
  questions(
    """distinct select on columns"""
    distinctOn: [QuestionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOrderBy!]

    """filter the rows returned"""
    where: QuestionBoolExp
  ): [Question!]!

  """An aggregate relationship"""
  questionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOrderBy!]

    """filter the rows returned"""
    where: QuestionBoolExp
  ): QuestionAggregate!
  tenantId: String!
  title: String!
  updatedAt: timestamptz!
  visibilityKind: VisibilityKindEnum!
}

"""
aggregated selection of "question_set"
"""
type QuestionSetAggregate {
  aggregate: QuestionSetAggregateFields
  nodes: [QuestionSet!]!
}

"""
aggregate fields of "question_set"
"""
type QuestionSetAggregateFields {
  avg: QuestionSetAvgFields
  count(columns: [QuestionSetSelectColumn!], distinct: Boolean): Int!
  max: QuestionSetMaxFields
  min: QuestionSetMinFields
  stddev: QuestionSetStddevFields
  stddevPop: QuestionSetStddevPopFields
  stddevSamp: QuestionSetStddevSampFields
  sum: QuestionSetSumFields
  varPop: QuestionSetVarPopFields
  varSamp: QuestionSetVarSampFields
  variance: QuestionSetVarianceFields
}

"""aggregate avg on columns"""
type QuestionSetAvgFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""
Boolean expression to filter rows from the table "question_set". All fields are combined with a logical 'AND'.
"""
input QuestionSetBoolExp {
  _and: [QuestionSetBoolExp!]
  _not: QuestionSetBoolExp
  _or: [QuestionSetBoolExp!]
  afterQuestionDurationSeconds: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  profileId: UuidComparisonExp
  questionDurationSeconds: IntComparisonExp
  questionKind: QuestionKindEnumComparisonExp
  questions: QuestionBoolExp
  questionsAggregate: QuestionAggregateBoolExp
  tenantId: StringComparisonExp
  title: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibilityKind: VisibilityKindEnumComparisonExp
}

"""
unique or primary key constraints on table "question_set"
"""
enum QuestionSetConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  question_set_pkey
}

"""
input type for incrementing numeric columns in table "question_set"
"""
input QuestionSetIncInput {
  afterQuestionDurationSeconds: Int
  questionDurationSeconds: Int
}

"""
input type for updating data in table "question"
"""
input QuestionSetInput {
  afterDurationSecondsOverride: Int
  afterImageIdOrUrl: String
  afterText: String
  createdAt: timestamptz
  description: String
  durationSecondsOverride: Int
  id: uuid
  kind: QuestionKindEnum
  order: Int
  questionSetId: uuid
  responseValueKind: ValueKindEnum
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
input type for inserting data into table "question_set"
"""
input QuestionSetInsertInput {
  afterQuestionDurationSeconds: Int
  createdAt: timestamptz
  description: String
  id: uuid
  profileId: uuid
  questionDurationSeconds: Int
  questionKind: QuestionKindEnum
  questions: QuestionArrRelInsertInput
  tenantId: String
  title: String
  updatedAt: timestamptz
  visibilityKind: VisibilityKindEnum
}

"""aggregate max on columns"""
type QuestionSetMaxFields {
  afterQuestionDurationSeconds: Int
  createdAt: timestamptz
  description: String
  id: uuid
  profileId: uuid
  questionDurationSeconds: Int
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type QuestionSetMinFields {
  afterQuestionDurationSeconds: Int
  createdAt: timestamptz
  description: String
  id: uuid
  profileId: uuid
  questionDurationSeconds: Int
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "question_set"
"""
type QuestionSetMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [QuestionSet!]!
}

"""
input type for inserting object relation for remote table "question_set"
"""
input QuestionSetObjRelInsertInput {
  data: QuestionSetInsertInput!

  """upsert condition"""
  onConflict: QuestionSetOnConflict
}

"""
on_conflict condition type for table "question_set"
"""
input QuestionSetOnConflict {
  constraint: QuestionSetConstraint!
  updateColumns: [QuestionSetUpdateColumn!]! = []
  where: QuestionSetBoolExp
}

"""Ordering options when selecting data from "question_set"."""
input QuestionSetOrderBy {
  afterQuestionDurationSeconds: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  profileId: OrderBy
  questionDurationSeconds: OrderBy
  questionKind: OrderBy
  questionsAggregate: QuestionAggregateOrderBy
  tenantId: OrderBy
  title: OrderBy
  updatedAt: OrderBy
  visibilityKind: OrderBy
}

"""primary key columns input for table: question_set"""
input QuestionSetPkColumnsInput {
  id: uuid!
}

"""
select columns of table "question_set"
"""
enum QuestionSetSelectColumn {
  """column name"""
  afterQuestionDurationSeconds

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  questionDurationSeconds

  """column name"""
  questionKind

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt

  """column name"""
  visibilityKind
}

"""
input type for updating data in table "question_set"
"""
input QuestionSetSetInput {
  afterQuestionDurationSeconds: Int
  createdAt: timestamptz
  description: String
  id: uuid
  profileId: uuid
  questionDurationSeconds: Int
  questionKind: QuestionKindEnum
  tenantId: String
  title: String
  updatedAt: timestamptz
  visibilityKind: VisibilityKindEnum
}

"""aggregate stddev on columns"""
type QuestionSetStddevFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""aggregate stddevPop on columns"""
type QuestionSetStddevPopFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""aggregate stddevSamp on columns"""
type QuestionSetStddevSampFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""
Streaming cursor of the table "question_set"
"""
input QuestionSetStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuestionSetStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuestionSetStreamCursorValueInput {
  afterQuestionDurationSeconds: Int
  createdAt: timestamptz
  description: String
  id: uuid
  profileId: uuid
  questionDurationSeconds: Int
  questionKind: QuestionKindEnum
  tenantId: String
  title: String
  updatedAt: timestamptz
  visibilityKind: VisibilityKindEnum
}

"""aggregate sum on columns"""
type QuestionSetSumFields {
  afterQuestionDurationSeconds: Int
  questionDurationSeconds: Int
}

"""
update columns of table "question_set"
"""
enum QuestionSetUpdateColumn {
  """column name"""
  afterQuestionDurationSeconds

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  profileId

  """column name"""
  questionDurationSeconds

  """column name"""
  questionKind

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt

  """column name"""
  visibilityKind
}

input QuestionSetUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuestionSetIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: QuestionSetSetInput

  """filter the rows which have to be updated"""
  where: QuestionSetBoolExp!
}

"""aggregate varPop on columns"""
type QuestionSetVarPopFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""aggregate varSamp on columns"""
type QuestionSetVarSampFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""aggregate variance on columns"""
type QuestionSetVarianceFields {
  afterQuestionDurationSeconds: Float
  questionDurationSeconds: Float
}

"""aggregate stddev on columns"""
type QuestionStddevFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by stddev() on columns of table "question"
"""
input QuestionStddevOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""aggregate stddevPop on columns"""
type QuestionStddevPopFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by stddevPop() on columns of table "question"
"""
input QuestionStddevPopOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""aggregate stddevSamp on columns"""
type QuestionStddevSampFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by stddevSamp() on columns of table "question"
"""
input QuestionStddevSampOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""
Streaming cursor of the table "question"
"""
input QuestionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuestionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuestionStreamCursorValueInput {
  afterDurationSecondsOverride: Int
  afterImageIdOrUrl: String
  afterText: String
  createdAt: timestamptz
  description: String
  durationSecondsOverride: Int
  id: uuid
  kind: QuestionKindEnum
  order: Int
  questionSetId: uuid
  responseValueKind: ValueKindEnum
  tenantId: String
  title: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type QuestionSumFields {
  afterDurationSecondsOverride: Int
  durationSecondsOverride: Int
  order: Int
}

"""
order by sum() on columns of table "question"
"""
input QuestionSumOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""
update columns of table "question"
"""
enum QuestionUpdateColumn {
  """column name"""
  afterDurationSecondsOverride

  """column name"""
  afterImageIdOrUrl

  """column name"""
  afterText

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  durationSecondsOverride

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  order

  """column name"""
  questionSetId

  """column name"""
  responseValueKind

  """column name"""
  tenantId

  """column name"""
  title

  """column name"""
  updatedAt
}

input QuestionUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuestionIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: QuestionSetInput

  """filter the rows which have to be updated"""
  where: QuestionBoolExp!
}

"""aggregate varPop on columns"""
type QuestionVarPopFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by varPop() on columns of table "question"
"""
input QuestionVarPopOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""aggregate varSamp on columns"""
type QuestionVarSampFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by varSamp() on columns of table "question"
"""
input QuestionVarSampOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

"""aggregate variance on columns"""
type QuestionVarianceFields {
  afterDurationSecondsOverride: Float
  durationSecondsOverride: Float
  order: Float
}

"""
order by variance() on columns of table "question"
"""
input QuestionVarianceOrderBy {
  afterDurationSecondsOverride: OrderBy
  durationSecondsOverride: OrderBy
  order: OrderBy
}

input ShopCheckoutItem {
  metadata: jsonb
  priceId: uuid
  quantity: Int!
  sku: String!
}

input ShopCheckoutStartInput {
  cartId: String
  items: [ShopCheckoutItem!]
  metadata: jsonb
}

type ShopCheckoutStartOutput {
  data: jsonb!
  kind: String!
}

input ShopClaimPromotionInput {
  data: jsonb!
}

type ShopClaimPromotionOutput {
  data: jsonb!
}

"""
columns and relationships of "shop_order"
"""
type ShopOrder {
  createdAt: timestamptz!
  externalId: String
  id: uuid!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [ShopOrderItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderItemOrderBy!]

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): [ShopOrderItem!]!

  """An aggregate relationship"""
  itemsAggregate(
    """distinct select on columns"""
    distinctOn: [ShopOrderItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderItemOrderBy!]

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): ShopOrderItemAggregate!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  status: String

  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "shop_order"
"""
type ShopOrderAggregate {
  aggregate: ShopOrderAggregateFields
  nodes: [ShopOrder!]!
}

input ShopOrderAggregateBoolExp {
  count: shopOrderAggregateBoolExpCount
}

"""
aggregate fields of "shop_order"
"""
type ShopOrderAggregateFields {
  count(columns: [ShopOrderSelectColumn!], distinct: Boolean): Int!
  max: ShopOrderMaxFields
  min: ShopOrderMinFields
}

"""
order by aggregate values of table "shop_order"
"""
input ShopOrderAggregateOrderBy {
  count: OrderBy
  max: ShopOrderMaxOrderBy
  min: ShopOrderMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ShopOrderAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "shop_order"
"""
input ShopOrderArrRelInsertInput {
  data: [ShopOrderInsertInput!]!

  """upsert condition"""
  onConflict: ShopOrderOnConflict
}

"""
Boolean expression to filter rows from the table "shop_order". All fields are combined with a logical 'AND'.
"""
input ShopOrderBoolExp {
  _and: [ShopOrderBoolExp!]
  _not: ShopOrderBoolExp
  _or: [ShopOrderBoolExp!]
  createdAt: TimestamptzComparisonExp
  externalId: StringComparisonExp
  id: UuidComparisonExp
  items: ShopOrderItemBoolExp
  itemsAggregate: ShopOrderItemAggregateBoolExp
  metadata: JsonbComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  status: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "shop_order"
"""
enum ShopOrderConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  shop_order_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ShopOrderDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ShopOrderDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ShopOrderDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "shop_order"
"""
input ShopOrderInsertInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  items: ShopOrderItemArrRelInsertInput
  metadata: jsonb
  profile: ProfileObjRelInsertInput
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "shop_order_item"
"""
type ShopOrderItem {
  createdAt: timestamptz!
  externalId: String
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  order: ShopOrder!
  orderId: uuid!

  """An object relationship"""
  price: ShopProductPrice!
  priceId: uuid!
  quantity: Int!

  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "shop_order_item"
"""
type ShopOrderItemAggregate {
  aggregate: ShopOrderItemAggregateFields
  nodes: [ShopOrderItem!]!
}

input ShopOrderItemAggregateBoolExp {
  count: shopOrderItemAggregateBoolExpCount
}

"""
aggregate fields of "shop_order_item"
"""
type ShopOrderItemAggregateFields {
  avg: ShopOrderItemAvgFields
  count(columns: [ShopOrderItemSelectColumn!], distinct: Boolean): Int!
  max: ShopOrderItemMaxFields
  min: ShopOrderItemMinFields
  stddev: ShopOrderItemStddevFields
  stddevPop: ShopOrderItemStddevPopFields
  stddevSamp: ShopOrderItemStddevSampFields
  sum: ShopOrderItemSumFields
  varPop: ShopOrderItemVarPopFields
  varSamp: ShopOrderItemVarSampFields
  variance: ShopOrderItemVarianceFields
}

"""
order by aggregate values of table "shop_order_item"
"""
input ShopOrderItemAggregateOrderBy {
  avg: ShopOrderItemAvgOrderBy
  count: OrderBy
  max: ShopOrderItemMaxOrderBy
  min: ShopOrderItemMinOrderBy
  stddev: ShopOrderItemStddevOrderBy
  stddevPop: ShopOrderItemStddevPopOrderBy
  stddevSamp: ShopOrderItemStddevSampOrderBy
  sum: ShopOrderItemSumOrderBy
  varPop: ShopOrderItemVarPopOrderBy
  varSamp: ShopOrderItemVarSampOrderBy
  variance: ShopOrderItemVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ShopOrderItemAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "shop_order_item"
"""
input ShopOrderItemArrRelInsertInput {
  data: [ShopOrderItemInsertInput!]!

  """upsert condition"""
  onConflict: ShopOrderItemOnConflict
}

"""aggregate avg on columns"""
type ShopOrderItemAvgFields {
  quantity: Float
}

"""
order by avg() on columns of table "shop_order_item"
"""
input ShopOrderItemAvgOrderBy {
  quantity: OrderBy
}

"""
Boolean expression to filter rows from the table "shop_order_item". All fields are combined with a logical 'AND'.
"""
input ShopOrderItemBoolExp {
  _and: [ShopOrderItemBoolExp!]
  _not: ShopOrderItemBoolExp
  _or: [ShopOrderItemBoolExp!]
  createdAt: TimestamptzComparisonExp
  externalId: StringComparisonExp
  id: UuidComparisonExp
  metadata: JsonbComparisonExp
  order: ShopOrderBoolExp
  orderId: UuidComparisonExp
  price: ShopProductPriceBoolExp
  priceId: UuidComparisonExp
  quantity: IntComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "shop_order_item"
"""
enum ShopOrderItemConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  shop_order_item_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ShopOrderItemDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ShopOrderItemDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ShopOrderItemDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "shop_order_item"
"""
input ShopOrderItemIncInput {
  quantity: Int
}

"""
input type for inserting data into table "shop_order_item"
"""
input ShopOrderItemInsertInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  order: ShopOrderObjRelInsertInput
  orderId: uuid
  price: ShopProductPriceObjRelInsertInput
  priceId: uuid
  quantity: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ShopOrderItemMaxFields {
  createdAt: timestamptz
  externalId: String
  id: uuid
  orderId: uuid
  priceId: uuid
  quantity: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "shop_order_item"
"""
input ShopOrderItemMaxOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  orderId: OrderBy
  priceId: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ShopOrderItemMinFields {
  createdAt: timestamptz
  externalId: String
  id: uuid
  orderId: uuid
  priceId: uuid
  quantity: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "shop_order_item"
"""
input ShopOrderItemMinOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  orderId: OrderBy
  priceId: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "shop_order_item"
"""
type ShopOrderItemMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ShopOrderItem!]!
}

"""
on_conflict condition type for table "shop_order_item"
"""
input ShopOrderItemOnConflict {
  constraint: ShopOrderItemConstraint!
  updateColumns: [ShopOrderItemUpdateColumn!]! = []
  where: ShopOrderItemBoolExp
}

"""Ordering options when selecting data from "shop_order_item"."""
input ShopOrderItemOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  metadata: OrderBy
  order: ShopOrderOrderBy
  orderId: OrderBy
  price: ShopProductPriceOrderBy
  priceId: OrderBy
  quantity: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: shop_order_item"""
input ShopOrderItemPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ShopOrderItemPrependInput {
  metadata: jsonb
}

"""
select columns of table "shop_order_item"
"""
enum ShopOrderItemSelectColumn {
  """column name"""
  createdAt

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orderId

  """column name"""
  priceId

  """column name"""
  quantity

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "shop_order_item"
"""
input ShopOrderItemSetInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  orderId: uuid
  priceId: uuid
  quantity: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ShopOrderItemStddevFields {
  quantity: Float
}

"""
order by stddev() on columns of table "shop_order_item"
"""
input ShopOrderItemStddevOrderBy {
  quantity: OrderBy
}

"""aggregate stddevPop on columns"""
type ShopOrderItemStddevPopFields {
  quantity: Float
}

"""
order by stddevPop() on columns of table "shop_order_item"
"""
input ShopOrderItemStddevPopOrderBy {
  quantity: OrderBy
}

"""aggregate stddevSamp on columns"""
type ShopOrderItemStddevSampFields {
  quantity: Float
}

"""
order by stddevSamp() on columns of table "shop_order_item"
"""
input ShopOrderItemStddevSampOrderBy {
  quantity: OrderBy
}

"""
Streaming cursor of the table "shop_order_item"
"""
input ShopOrderItemStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopOrderItemStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopOrderItemStreamCursorValueInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  orderId: uuid
  priceId: uuid
  quantity: Int
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ShopOrderItemSumFields {
  quantity: Int
}

"""
order by sum() on columns of table "shop_order_item"
"""
input ShopOrderItemSumOrderBy {
  quantity: OrderBy
}

"""
update columns of table "shop_order_item"
"""
enum ShopOrderItemUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  orderId

  """column name"""
  priceId

  """column name"""
  quantity

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ShopOrderItemUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ShopOrderItemAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ShopOrderItemDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ShopOrderItemDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ShopOrderItemDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: ShopOrderItemIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ShopOrderItemPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ShopOrderItemSetInput

  """filter the rows which have to be updated"""
  where: ShopOrderItemBoolExp!
}

"""aggregate varPop on columns"""
type ShopOrderItemVarPopFields {
  quantity: Float
}

"""
order by varPop() on columns of table "shop_order_item"
"""
input ShopOrderItemVarPopOrderBy {
  quantity: OrderBy
}

"""aggregate varSamp on columns"""
type ShopOrderItemVarSampFields {
  quantity: Float
}

"""
order by varSamp() on columns of table "shop_order_item"
"""
input ShopOrderItemVarSampOrderBy {
  quantity: OrderBy
}

"""aggregate variance on columns"""
type ShopOrderItemVarianceFields {
  quantity: Float
}

"""
order by variance() on columns of table "shop_order_item"
"""
input ShopOrderItemVarianceOrderBy {
  quantity: OrderBy
}

"""aggregate max on columns"""
type ShopOrderMaxFields {
  createdAt: timestamptz
  externalId: String
  id: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "shop_order"
"""
input ShopOrderMaxOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  profileId: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ShopOrderMinFields {
  createdAt: timestamptz
  externalId: String
  id: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "shop_order"
"""
input ShopOrderMinOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  profileId: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "shop_order"
"""
type ShopOrderMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ShopOrder!]!
}

"""
input type for inserting object relation for remote table "shop_order"
"""
input ShopOrderObjRelInsertInput {
  data: ShopOrderInsertInput!

  """upsert condition"""
  onConflict: ShopOrderOnConflict
}

"""
on_conflict condition type for table "shop_order"
"""
input ShopOrderOnConflict {
  constraint: ShopOrderConstraint!
  updateColumns: [ShopOrderUpdateColumn!]! = []
  where: ShopOrderBoolExp
}

"""Ordering options when selecting data from "shop_order"."""
input ShopOrderOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  itemsAggregate: ShopOrderItemAggregateOrderBy
  metadata: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  status: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: shop_order"""
input ShopOrderPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ShopOrderPrependInput {
  metadata: jsonb
}

"""
select columns of table "shop_order"
"""
enum ShopOrderSelectColumn {
  """column name"""
  createdAt

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "shop_order"
"""
input ShopOrderSetInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "shop_order"
"""
input ShopOrderStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopOrderStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopOrderStreamCursorValueInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "shop_order"
"""
enum ShopOrderUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  profileId

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ShopOrderUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ShopOrderAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ShopOrderDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ShopOrderDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ShopOrderDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ShopOrderPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ShopOrderSetInput

  """filter the rows which have to be updated"""
  where: ShopOrderBoolExp!
}

"""
columns and relationships of "shop_product"
"""
type ShopProduct {
  createdAt: timestamptz!

  """An object relationship"""
  defaultPrice: ShopProductPrice
  description: String
  externalId: String
  id: uuid!
  kind: ShopProductKindEnum!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!
  price: Int

  """An array relationship"""
  prices(
    """distinct select on columns"""
    distinctOn: [ShopProductPriceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductPriceOrderBy!]

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): [ShopProductPrice!]!

  """An aggregate relationship"""
  pricesAggregate(
    """distinct select on columns"""
    distinctOn: [ShopProductPriceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductPriceOrderBy!]

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): ShopProductPriceAggregate!
  sku: String!
  tenantId: String!
  trialPeriodDays: Int
  updatedAt: timestamptz!
}

"""
aggregated selection of "shop_product"
"""
type ShopProductAggregate {
  aggregate: ShopProductAggregateFields
  nodes: [ShopProduct!]!
}

"""
aggregate fields of "shop_product"
"""
type ShopProductAggregateFields {
  avg: ShopProductAvgFields
  count(columns: [ShopProductSelectColumn!], distinct: Boolean): Int!
  max: ShopProductMaxFields
  min: ShopProductMinFields
  stddev: ShopProductStddevFields
  stddevPop: ShopProductStddevPopFields
  stddevSamp: ShopProductStddevSampFields
  sum: ShopProductSumFields
  varPop: ShopProductVarPopFields
  varSamp: ShopProductVarSampFields
  variance: ShopProductVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ShopProductAppendInput {
  metadata: jsonb
}

"""aggregate avg on columns"""
type ShopProductAvgFields {
  price: Float
  trialPeriodDays: Float
}

"""
Boolean expression to filter rows from the table "shop_product". All fields are combined with a logical 'AND'.
"""
input ShopProductBoolExp {
  _and: [ShopProductBoolExp!]
  _not: ShopProductBoolExp
  _or: [ShopProductBoolExp!]
  createdAt: TimestamptzComparisonExp
  defaultPrice: ShopProductPriceBoolExp
  description: StringComparisonExp
  externalId: StringComparisonExp
  id: UuidComparisonExp
  kind: ShopProductKindEnumComparisonExp
  metadata: JsonbComparisonExp
  name: StringComparisonExp
  price: IntComparisonExp
  prices: ShopProductPriceBoolExp
  pricesAggregate: ShopProductPriceAggregateBoolExp
  sku: StringComparisonExp
  tenantId: StringComparisonExp
  trialPeriodDays: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "shop_product"
"""
enum ShopProductConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  shop_product_pkey

  """
  unique or primary key constraint on columns "sku", "tenant_id"
  """
  shop_product_sku_tenant_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ShopProductDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ShopProductDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ShopProductDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "shop_product"
"""
input ShopProductIncInput {
  price: Int
  trialPeriodDays: Int
}

"""
input type for inserting data into table "shop_product"
"""
input ShopProductInsertInput {
  createdAt: timestamptz
  defaultPrice: ShopProductPriceObjRelInsertInput
  description: String
  externalId: String
  id: uuid
  kind: ShopProductKindEnum
  metadata: jsonb
  name: String
  price: Int
  prices: ShopProductPriceArrRelInsertInput
  sku: String
  tenantId: String
  trialPeriodDays: Int
  updatedAt: timestamptz
}

"""
columns and relationships of "shop_product_kind"
"""
type ShopProductKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "shop_product_kind". All fields are combined with a logical 'AND'.
"""
input ShopProductKindBoolExp {
  _and: [ShopProductKindBoolExp!]
  _not: ShopProductKindBoolExp
  _or: [ShopProductKindBoolExp!]
  id: StringComparisonExp
}

enum ShopProductKindEnum {
  DIGITAL
  EVENT_TICKET
  PHYSICAL
  SUBSCRIPTION
}

"""
Boolean expression to compare columns of type "ShopProductKindEnum". All fields are combined with logical 'AND'.
"""
input ShopProductKindEnumComparisonExp {
  _eq: ShopProductKindEnum
  _in: [ShopProductKindEnum!]
  _isNull: Boolean
  _neq: ShopProductKindEnum
  _nin: [ShopProductKindEnum!]
}

"""Ordering options when selecting data from "shop_product_kind"."""
input ShopProductKindOrderBy {
  id: OrderBy
}

"""
select columns of table "shop_product_kind"
"""
enum ShopProductKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "shop_product_kind"
"""
input ShopProductKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopProductKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopProductKindStreamCursorValueInput {
  id: String
}

"""aggregate max on columns"""
type ShopProductMaxFields {
  createdAt: timestamptz
  description: String
  externalId: String
  id: uuid
  name: String
  price: Int
  sku: String
  tenantId: String
  trialPeriodDays: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ShopProductMinFields {
  createdAt: timestamptz
  description: String
  externalId: String
  id: uuid
  name: String
  price: Int
  sku: String
  tenantId: String
  trialPeriodDays: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "shop_product"
"""
type ShopProductMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ShopProduct!]!
}

"""
input type for inserting object relation for remote table "shop_product"
"""
input ShopProductObjRelInsertInput {
  data: ShopProductInsertInput!

  """upsert condition"""
  onConflict: ShopProductOnConflict
}

"""
on_conflict condition type for table "shop_product"
"""
input ShopProductOnConflict {
  constraint: ShopProductConstraint!
  updateColumns: [ShopProductUpdateColumn!]! = []
  where: ShopProductBoolExp
}

"""Ordering options when selecting data from "shop_product"."""
input ShopProductOrderBy {
  createdAt: OrderBy
  defaultPrice: ShopProductPriceOrderBy
  description: OrderBy
  externalId: OrderBy
  id: OrderBy
  kind: OrderBy
  metadata: OrderBy
  name: OrderBy
  price: OrderBy
  pricesAggregate: ShopProductPriceAggregateOrderBy
  sku: OrderBy
  tenantId: OrderBy
  trialPeriodDays: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: shop_product"""
input ShopProductPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ShopProductPrependInput {
  metadata: jsonb
}

"""
columns and relationships of "shop_product_price"
"""
type ShopProductPrice {
  amount: Int!
  createdAt: timestamptz!
  defaultPriceProductId: uuid
  endsAt: timestamptz
  id: uuid!
  label: String

  """An object relationship"""
  product: ShopProduct!
  productId: uuid!
  startsAt: timestamptz
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "shop_product_price"
"""
type ShopProductPriceAggregate {
  aggregate: ShopProductPriceAggregateFields
  nodes: [ShopProductPrice!]!
}

input ShopProductPriceAggregateBoolExp {
  count: shopProductPriceAggregateBoolExpCount
}

"""
aggregate fields of "shop_product_price"
"""
type ShopProductPriceAggregateFields {
  avg: ShopProductPriceAvgFields
  count(columns: [ShopProductPriceSelectColumn!], distinct: Boolean): Int!
  max: ShopProductPriceMaxFields
  min: ShopProductPriceMinFields
  stddev: ShopProductPriceStddevFields
  stddevPop: ShopProductPriceStddevPopFields
  stddevSamp: ShopProductPriceStddevSampFields
  sum: ShopProductPriceSumFields
  varPop: ShopProductPriceVarPopFields
  varSamp: ShopProductPriceVarSampFields
  variance: ShopProductPriceVarianceFields
}

"""
order by aggregate values of table "shop_product_price"
"""
input ShopProductPriceAggregateOrderBy {
  avg: ShopProductPriceAvgOrderBy
  count: OrderBy
  max: ShopProductPriceMaxOrderBy
  min: ShopProductPriceMinOrderBy
  stddev: ShopProductPriceStddevOrderBy
  stddevPop: ShopProductPriceStddevPopOrderBy
  stddevSamp: ShopProductPriceStddevSampOrderBy
  sum: ShopProductPriceSumOrderBy
  varPop: ShopProductPriceVarPopOrderBy
  varSamp: ShopProductPriceVarSampOrderBy
  variance: ShopProductPriceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "shop_product_price"
"""
input ShopProductPriceArrRelInsertInput {
  data: [ShopProductPriceInsertInput!]!

  """upsert condition"""
  onConflict: ShopProductPriceOnConflict
}

"""aggregate avg on columns"""
type ShopProductPriceAvgFields {
  amount: Float
}

"""
order by avg() on columns of table "shop_product_price"
"""
input ShopProductPriceAvgOrderBy {
  amount: OrderBy
}

"""
Boolean expression to filter rows from the table "shop_product_price". All fields are combined with a logical 'AND'.
"""
input ShopProductPriceBoolExp {
  _and: [ShopProductPriceBoolExp!]
  _not: ShopProductPriceBoolExp
  _or: [ShopProductPriceBoolExp!]
  amount: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  defaultPriceProductId: UuidComparisonExp
  endsAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  label: StringComparisonExp
  product: ShopProductBoolExp
  productId: UuidComparisonExp
  startsAt: TimestamptzComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "shop_product_price"
"""
enum ShopProductPriceConstraint {
  """
  unique or primary key constraint on columns "default_price_product_id"
  """
  shop_product_price_default_price_product_id_key

  """
  unique or primary key constraint on columns "id"
  """
  shop_product_price_pkey
}

"""
input type for incrementing numeric columns in table "shop_product_price"
"""
input ShopProductPriceIncInput {
  amount: Int
}

"""
input type for inserting data into table "shop_product_price"
"""
input ShopProductPriceInsertInput {
  amount: Int
  createdAt: timestamptz
  defaultPriceProductId: uuid
  endsAt: timestamptz
  id: uuid
  label: String
  product: ShopProductObjRelInsertInput
  productId: uuid
  startsAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ShopProductPriceMaxFields {
  amount: Int
  createdAt: timestamptz
  defaultPriceProductId: uuid
  endsAt: timestamptz
  id: uuid
  label: String
  productId: uuid
  startsAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "shop_product_price"
"""
input ShopProductPriceMaxOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  defaultPriceProductId: OrderBy
  endsAt: OrderBy
  id: OrderBy
  label: OrderBy
  productId: OrderBy
  startsAt: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ShopProductPriceMinFields {
  amount: Int
  createdAt: timestamptz
  defaultPriceProductId: uuid
  endsAt: timestamptz
  id: uuid
  label: String
  productId: uuid
  startsAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "shop_product_price"
"""
input ShopProductPriceMinOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  defaultPriceProductId: OrderBy
  endsAt: OrderBy
  id: OrderBy
  label: OrderBy
  productId: OrderBy
  startsAt: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "shop_product_price"
"""
type ShopProductPriceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ShopProductPrice!]!
}

"""
input type for inserting object relation for remote table "shop_product_price"
"""
input ShopProductPriceObjRelInsertInput {
  data: ShopProductPriceInsertInput!

  """upsert condition"""
  onConflict: ShopProductPriceOnConflict
}

"""
on_conflict condition type for table "shop_product_price"
"""
input ShopProductPriceOnConflict {
  constraint: ShopProductPriceConstraint!
  updateColumns: [ShopProductPriceUpdateColumn!]! = []
  where: ShopProductPriceBoolExp
}

"""Ordering options when selecting data from "shop_product_price"."""
input ShopProductPriceOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  defaultPriceProductId: OrderBy
  endsAt: OrderBy
  id: OrderBy
  label: OrderBy
  product: ShopProductOrderBy
  productId: OrderBy
  startsAt: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: shop_product_price"""
input ShopProductPricePkColumnsInput {
  id: uuid!
}

"""
select columns of table "shop_product_price"
"""
enum ShopProductPriceSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  defaultPriceProductId

  """column name"""
  endsAt

  """column name"""
  id

  """column name"""
  label

  """column name"""
  productId

  """column name"""
  startsAt

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "shop_product_price"
"""
input ShopProductPriceSetInput {
  amount: Int
  createdAt: timestamptz
  defaultPriceProductId: uuid
  endsAt: timestamptz
  id: uuid
  label: String
  productId: uuid
  startsAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ShopProductPriceStddevFields {
  amount: Float
}

"""
order by stddev() on columns of table "shop_product_price"
"""
input ShopProductPriceStddevOrderBy {
  amount: OrderBy
}

"""aggregate stddevPop on columns"""
type ShopProductPriceStddevPopFields {
  amount: Float
}

"""
order by stddevPop() on columns of table "shop_product_price"
"""
input ShopProductPriceStddevPopOrderBy {
  amount: OrderBy
}

"""aggregate stddevSamp on columns"""
type ShopProductPriceStddevSampFields {
  amount: Float
}

"""
order by stddevSamp() on columns of table "shop_product_price"
"""
input ShopProductPriceStddevSampOrderBy {
  amount: OrderBy
}

"""
Streaming cursor of the table "shop_product_price"
"""
input ShopProductPriceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopProductPriceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopProductPriceStreamCursorValueInput {
  amount: Int
  createdAt: timestamptz
  defaultPriceProductId: uuid
  endsAt: timestamptz
  id: uuid
  label: String
  productId: uuid
  startsAt: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ShopProductPriceSumFields {
  amount: Int
}

"""
order by sum() on columns of table "shop_product_price"
"""
input ShopProductPriceSumOrderBy {
  amount: OrderBy
}

"""
update columns of table "shop_product_price"
"""
enum ShopProductPriceUpdateColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  defaultPriceProductId

  """column name"""
  endsAt

  """column name"""
  id

  """column name"""
  label

  """column name"""
  productId

  """column name"""
  startsAt

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ShopProductPriceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ShopProductPriceIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: ShopProductPriceSetInput

  """filter the rows which have to be updated"""
  where: ShopProductPriceBoolExp!
}

"""aggregate varPop on columns"""
type ShopProductPriceVarPopFields {
  amount: Float
}

"""
order by varPop() on columns of table "shop_product_price"
"""
input ShopProductPriceVarPopOrderBy {
  amount: OrderBy
}

"""aggregate varSamp on columns"""
type ShopProductPriceVarSampFields {
  amount: Float
}

"""
order by varSamp() on columns of table "shop_product_price"
"""
input ShopProductPriceVarSampOrderBy {
  amount: OrderBy
}

"""aggregate variance on columns"""
type ShopProductPriceVarianceFields {
  amount: Float
}

"""
order by variance() on columns of table "shop_product_price"
"""
input ShopProductPriceVarianceOrderBy {
  amount: OrderBy
}

"""
select columns of table "shop_product"
"""
enum ShopProductSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  price

  """column name"""
  sku

  """column name"""
  tenantId

  """column name"""
  trialPeriodDays

  """column name"""
  updatedAt
}

"""
input type for updating data in table "shop_product"
"""
input ShopProductSetInput {
  createdAt: timestamptz
  description: String
  externalId: String
  id: uuid
  kind: ShopProductKindEnum
  metadata: jsonb
  name: String
  price: Int
  sku: String
  tenantId: String
  trialPeriodDays: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ShopProductStddevFields {
  price: Float
  trialPeriodDays: Float
}

"""aggregate stddevPop on columns"""
type ShopProductStddevPopFields {
  price: Float
  trialPeriodDays: Float
}

"""aggregate stddevSamp on columns"""
type ShopProductStddevSampFields {
  price: Float
  trialPeriodDays: Float
}

"""
Streaming cursor of the table "shop_product"
"""
input ShopProductStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopProductStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopProductStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  externalId: String
  id: uuid
  kind: ShopProductKindEnum
  metadata: jsonb
  name: String
  price: Int
  sku: String
  tenantId: String
  trialPeriodDays: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ShopProductSumFields {
  price: Int
  trialPeriodDays: Int
}

"""
update columns of table "shop_product"
"""
enum ShopProductUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  kind

  """column name"""
  metadata

  """column name"""
  name

  """column name"""
  price

  """column name"""
  sku

  """column name"""
  tenantId

  """column name"""
  trialPeriodDays

  """column name"""
  updatedAt
}

input ShopProductUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ShopProductAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ShopProductDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ShopProductDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ShopProductDeleteKeyInput

  """increments the numeric columns with given value of the filtered values"""
  _inc: ShopProductIncInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ShopProductPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ShopProductSetInput

  """filter the rows which have to be updated"""
  where: ShopProductBoolExp!
}

"""aggregate varPop on columns"""
type ShopProductVarPopFields {
  price: Float
  trialPeriodDays: Float
}

"""aggregate varSamp on columns"""
type ShopProductVarSampFields {
  price: Float
  trialPeriodDays: Float
}

"""aggregate variance on columns"""
type ShopProductVarianceFields {
  price: Float
  trialPeriodDays: Float
}

enum ShopStripePortalKindEnum {
  ConnectAccount
  Customer
}

input ShopStripePortalSessionInput {
  kind: ShopStripePortalKindEnum
  returnUrl: String!
}

type ShopStripePortalSessionOutput {
  data: jsonb!
}

"""
columns and relationships of "shop_subscription"
"""
type ShopSubscription {
  createdAt: timestamptz!
  externalId: String
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!

  """An object relationship"""
  product: ShopProduct!
  productId: uuid!

  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  status: String!

  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "shop_subscription"
"""
type ShopSubscriptionAggregate {
  aggregate: ShopSubscriptionAggregateFields
  nodes: [ShopSubscription!]!
}

input ShopSubscriptionAggregateBoolExp {
  count: shopSubscriptionAggregateBoolExpCount
}

"""
aggregate fields of "shop_subscription"
"""
type ShopSubscriptionAggregateFields {
  count(columns: [ShopSubscriptionSelectColumn!], distinct: Boolean): Int!
  max: ShopSubscriptionMaxFields
  min: ShopSubscriptionMinFields
}

"""
order by aggregate values of table "shop_subscription"
"""
input ShopSubscriptionAggregateOrderBy {
  count: OrderBy
  max: ShopSubscriptionMaxOrderBy
  min: ShopSubscriptionMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ShopSubscriptionAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "shop_subscription"
"""
input ShopSubscriptionArrRelInsertInput {
  data: [ShopSubscriptionInsertInput!]!

  """upsert condition"""
  onConflict: ShopSubscriptionOnConflict
}

"""
Boolean expression to filter rows from the table "shop_subscription". All fields are combined with a logical 'AND'.
"""
input ShopSubscriptionBoolExp {
  _and: [ShopSubscriptionBoolExp!]
  _not: ShopSubscriptionBoolExp
  _or: [ShopSubscriptionBoolExp!]
  createdAt: TimestamptzComparisonExp
  externalId: StringComparisonExp
  id: UuidComparisonExp
  metadata: JsonbComparisonExp
  product: ShopProductBoolExp
  productId: UuidComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  status: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "shop_subscription"
"""
enum ShopSubscriptionConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  shop_subscription_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ShopSubscriptionDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ShopSubscriptionDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ShopSubscriptionDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "shop_subscription"
"""
input ShopSubscriptionInsertInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  product: ShopProductObjRelInsertInput
  productId: uuid
  profile: ProfileObjRelInsertInput
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ShopSubscriptionMaxFields {
  createdAt: timestamptz
  externalId: String
  id: uuid
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "shop_subscription"
"""
input ShopSubscriptionMaxOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  productId: OrderBy
  profileId: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ShopSubscriptionMinFields {
  createdAt: timestamptz
  externalId: String
  id: uuid
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "shop_subscription"
"""
input ShopSubscriptionMinOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  productId: OrderBy
  profileId: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "shop_subscription"
"""
type ShopSubscriptionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [ShopSubscription!]!
}

"""
on_conflict condition type for table "shop_subscription"
"""
input ShopSubscriptionOnConflict {
  constraint: ShopSubscriptionConstraint!
  updateColumns: [ShopSubscriptionUpdateColumn!]! = []
  where: ShopSubscriptionBoolExp
}

"""Ordering options when selecting data from "shop_subscription"."""
input ShopSubscriptionOrderBy {
  createdAt: OrderBy
  externalId: OrderBy
  id: OrderBy
  metadata: OrderBy
  product: ShopProductOrderBy
  productId: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  status: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: shop_subscription"""
input ShopSubscriptionPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ShopSubscriptionPrependInput {
  metadata: jsonb
}

"""
select columns of table "shop_subscription"
"""
enum ShopSubscriptionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  productId

  """column name"""
  profileId

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "shop_subscription"
"""
input ShopSubscriptionSetInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "shop_subscription"
"""
input ShopSubscriptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopSubscriptionStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopSubscriptionStreamCursorValueInput {
  createdAt: timestamptz
  externalId: String
  id: uuid
  metadata: jsonb
  productId: uuid
  profileId: uuid
  status: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "shop_subscription"
"""
enum ShopSubscriptionUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  externalId

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  productId

  """column name"""
  profileId

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input ShopSubscriptionUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ShopSubscriptionAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ShopSubscriptionDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ShopSubscriptionDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ShopSubscriptionDeleteKeyInput

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ShopSubscriptionPrependInput

  """sets the columns of the filtered rows to the given values"""
  _set: ShopSubscriptionSetInput

  """filter the rows which have to be updated"""
  where: ShopSubscriptionBoolExp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringArrayComparisonExp {
  """is the array contained in the given array value"""
  _containedIn: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _isNull: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type SuccessOutput {
  success: Boolean!
}

"""
columns and relationships of "tenant"
"""
type Tenant {
  """An array relationship"""
  apps(
    """distinct select on columns"""
    distinctOn: [TenantAppSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppOrderBy!]

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): [TenantApp!]!

  """An aggregate relationship"""
  appsAggregate(
    """distinct select on columns"""
    distinctOn: [TenantAppSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppOrderBy!]

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): TenantAppAggregate!
  createdAt: timestamptz
  domain: citext!

  """url friendly version of name"""
  id: String!
  name: String!
  profileId: uuid
  transactionalFromEmail: citext
  updatedAt: timestamptz
}

"""
columns and relationships of "tenant_app"
"""
type TenantApp {
  createdAt: timestamptz!
  id: String!
  name: String!

  """An array relationship"""
  releases(
    """distinct select on columns"""
    distinctOn: [TenantAppReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppReleaseOrderBy!]

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): [TenantAppRelease!]!

  """An aggregate relationship"""
  releasesAggregate(
    """distinct select on columns"""
    distinctOn: [TenantAppReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppReleaseOrderBy!]

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): TenantAppReleaseAggregate!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "tenant_app"
"""
type TenantAppAggregate {
  aggregate: TenantAppAggregateFields
  nodes: [TenantApp!]!
}

input TenantAppAggregateBoolExp {
  count: tenantAppAggregateBoolExpCount
}

"""
aggregate fields of "tenant_app"
"""
type TenantAppAggregateFields {
  count(columns: [TenantAppSelectColumn!], distinct: Boolean): Int!
  max: TenantAppMaxFields
  min: TenantAppMinFields
}

"""
order by aggregate values of table "tenant_app"
"""
input TenantAppAggregateOrderBy {
  count: OrderBy
  max: TenantAppMaxOrderBy
  min: TenantAppMinOrderBy
}

"""
Boolean expression to filter rows from the table "tenant_app". All fields are combined with a logical 'AND'.
"""
input TenantAppBoolExp {
  _and: [TenantAppBoolExp!]
  _not: TenantAppBoolExp
  _or: [TenantAppBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  name: StringComparisonExp
  releases: TenantAppReleaseBoolExp
  releasesAggregate: TenantAppReleaseAggregateBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "tenant_app"
"""
enum TenantAppConstraint {
  """
  unique or primary key constraint on columns "id", "tenant_id"
  """
  tenant_app_pkey
}

"""
input type for inserting data into table "tenant_app"
"""
input TenantAppInsertInput {
  createdAt: timestamptz
  id: String
  name: String
  releases: TenantAppReleaseArrRelInsertInput
  tenantId: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type TenantAppMaxFields {
  createdAt: timestamptz
  id: String
  name: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "tenant_app"
"""
input TenantAppMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type TenantAppMinFields {
  createdAt: timestamptz
  id: String
  name: String
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "tenant_app"
"""
input TenantAppMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "tenant_app"
"""
type TenantAppMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [TenantApp!]!
}

"""
input type for inserting object relation for remote table "tenant_app"
"""
input TenantAppObjRelInsertInput {
  data: TenantAppInsertInput!

  """upsert condition"""
  onConflict: TenantAppOnConflict
}

"""
on_conflict condition type for table "tenant_app"
"""
input TenantAppOnConflict {
  constraint: TenantAppConstraint!
  updateColumns: [TenantAppUpdateColumn!]! = []
  where: TenantAppBoolExp
}

"""Ordering options when selecting data from "tenant_app"."""
input TenantAppOrderBy {
  createdAt: OrderBy
  id: OrderBy
  name: OrderBy
  releasesAggregate: TenantAppReleaseAggregateOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: tenant_app"""
input TenantAppPkColumnsInput {
  id: String!
  tenantId: String!
}

"""
columns and relationships of "tenant_app_release"
"""
type TenantAppRelease {
  """An object relationship"""
  app: TenantApp!
  appId: String!
  buildNumber: Int!
  createdAt: timestamptz!
  id: uuid!
  minBuildNumberRequired: Int!
  releaseNotes: String
  requiresOnboarding: Boolean!
  status: String!
  tenantId: String!
  updatedAt: timestamptz!
  version: String!
}

"""
aggregated selection of "tenant_app_release"
"""
type TenantAppReleaseAggregate {
  aggregate: TenantAppReleaseAggregateFields
  nodes: [TenantAppRelease!]!
}

input TenantAppReleaseAggregateBoolExp {
  bool_and: tenantAppReleaseAggregateBoolExpBool_and
  bool_or: tenantAppReleaseAggregateBoolExpBool_or
  count: tenantAppReleaseAggregateBoolExpCount
}

"""
aggregate fields of "tenant_app_release"
"""
type TenantAppReleaseAggregateFields {
  avg: TenantAppReleaseAvgFields
  count(columns: [TenantAppReleaseSelectColumn!], distinct: Boolean): Int!
  max: TenantAppReleaseMaxFields
  min: TenantAppReleaseMinFields
  stddev: TenantAppReleaseStddevFields
  stddevPop: TenantAppReleaseStddevPopFields
  stddevSamp: TenantAppReleaseStddevSampFields
  sum: TenantAppReleaseSumFields
  varPop: TenantAppReleaseVarPopFields
  varSamp: TenantAppReleaseVarSampFields
  variance: TenantAppReleaseVarianceFields
}

"""
order by aggregate values of table "tenant_app_release"
"""
input TenantAppReleaseAggregateOrderBy {
  avg: TenantAppReleaseAvgOrderBy
  count: OrderBy
  max: TenantAppReleaseMaxOrderBy
  min: TenantAppReleaseMinOrderBy
  stddev: TenantAppReleaseStddevOrderBy
  stddevPop: TenantAppReleaseStddevPopOrderBy
  stddevSamp: TenantAppReleaseStddevSampOrderBy
  sum: TenantAppReleaseSumOrderBy
  varPop: TenantAppReleaseVarPopOrderBy
  varSamp: TenantAppReleaseVarSampOrderBy
  variance: TenantAppReleaseVarianceOrderBy
}

"""
input type for inserting array relation for remote table "tenant_app_release"
"""
input TenantAppReleaseArrRelInsertInput {
  data: [TenantAppReleaseInsertInput!]!

  """upsert condition"""
  onConflict: TenantAppReleaseOnConflict
}

"""aggregate avg on columns"""
type TenantAppReleaseAvgFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by avg() on columns of table "tenant_app_release"
"""
input TenantAppReleaseAvgOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""
Boolean expression to filter rows from the table "tenant_app_release". All fields are combined with a logical 'AND'.
"""
input TenantAppReleaseBoolExp {
  _and: [TenantAppReleaseBoolExp!]
  _not: TenantAppReleaseBoolExp
  _or: [TenantAppReleaseBoolExp!]
  app: TenantAppBoolExp
  appId: StringComparisonExp
  buildNumber: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  minBuildNumberRequired: IntComparisonExp
  releaseNotes: StringComparisonExp
  requiresOnboarding: BooleanComparisonExp
  status: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  version: StringComparisonExp
}

"""
unique or primary key constraints on table "tenant_app_release"
"""
enum TenantAppReleaseConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  tenant_app_release_pkey
}

"""
input type for incrementing numeric columns in table "tenant_app_release"
"""
input TenantAppReleaseIncInput {
  buildNumber: Int
  minBuildNumberRequired: Int
}

"""
input type for inserting data into table "tenant_app_release"
"""
input TenantAppReleaseInsertInput {
  app: TenantAppObjRelInsertInput
  appId: String
  buildNumber: Int
  createdAt: timestamptz
  id: uuid
  minBuildNumberRequired: Int
  releaseNotes: String
  requiresOnboarding: Boolean
  status: String
  tenantId: String
  updatedAt: timestamptz
  version: String
}

"""aggregate max on columns"""
type TenantAppReleaseMaxFields {
  appId: String
  buildNumber: Int
  createdAt: timestamptz
  id: uuid
  minBuildNumberRequired: Int
  releaseNotes: String
  status: String
  tenantId: String
  updatedAt: timestamptz
  version: String
}

"""
order by max() on columns of table "tenant_app_release"
"""
input TenantAppReleaseMaxOrderBy {
  appId: OrderBy
  buildNumber: OrderBy
  createdAt: OrderBy
  id: OrderBy
  minBuildNumberRequired: OrderBy
  releaseNotes: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  version: OrderBy
}

"""aggregate min on columns"""
type TenantAppReleaseMinFields {
  appId: String
  buildNumber: Int
  createdAt: timestamptz
  id: uuid
  minBuildNumberRequired: Int
  releaseNotes: String
  status: String
  tenantId: String
  updatedAt: timestamptz
  version: String
}

"""
order by min() on columns of table "tenant_app_release"
"""
input TenantAppReleaseMinOrderBy {
  appId: OrderBy
  buildNumber: OrderBy
  createdAt: OrderBy
  id: OrderBy
  minBuildNumberRequired: OrderBy
  releaseNotes: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  version: OrderBy
}

"""
response of any mutation on the table "tenant_app_release"
"""
type TenantAppReleaseMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!

  """data from the rows affected by the mutation"""
  returning: [TenantAppRelease!]!
}

"""
on_conflict condition type for table "tenant_app_release"
"""
input TenantAppReleaseOnConflict {
  constraint: TenantAppReleaseConstraint!
  updateColumns: [TenantAppReleaseUpdateColumn!]! = []
  where: TenantAppReleaseBoolExp
}

"""Ordering options when selecting data from "tenant_app_release"."""
input TenantAppReleaseOrderBy {
  app: TenantAppOrderBy
  appId: OrderBy
  buildNumber: OrderBy
  createdAt: OrderBy
  id: OrderBy
  minBuildNumberRequired: OrderBy
  releaseNotes: OrderBy
  requiresOnboarding: OrderBy
  status: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  version: OrderBy
}

"""primary key columns input for table: tenant_app_release"""
input TenantAppReleasePkColumnsInput {
  id: uuid!
}

"""
select columns of table "tenant_app_release"
"""
enum TenantAppReleaseSelectColumn {
  """column name"""
  appId

  """column name"""
  buildNumber

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  minBuildNumberRequired

  """column name"""
  releaseNotes

  """column name"""
  requiresOnboarding

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  version
}

"""
select "tenantAppReleaseAggregateBoolExpBool_andArgumentsColumns" columns of table "tenant_app_release"
"""
enum TenantAppReleaseSelectColumnTenantAppReleaseAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  requiresOnboarding
}

"""
select "tenantAppReleaseAggregateBoolExpBool_orArgumentsColumns" columns of table "tenant_app_release"
"""
enum TenantAppReleaseSelectColumnTenantAppReleaseAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  requiresOnboarding
}

"""
input type for updating data in table "tenant_app_release"
"""
input TenantAppReleaseSetInput {
  appId: String
  buildNumber: Int
  createdAt: timestamptz
  id: uuid
  minBuildNumberRequired: Int
  releaseNotes: String
  requiresOnboarding: Boolean
  status: String
  tenantId: String
  updatedAt: timestamptz
  version: String
}

"""aggregate stddev on columns"""
type TenantAppReleaseStddevFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by stddev() on columns of table "tenant_app_release"
"""
input TenantAppReleaseStddevOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""aggregate stddevPop on columns"""
type TenantAppReleaseStddevPopFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by stddevPop() on columns of table "tenant_app_release"
"""
input TenantAppReleaseStddevPopOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""aggregate stddevSamp on columns"""
type TenantAppReleaseStddevSampFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by stddevSamp() on columns of table "tenant_app_release"
"""
input TenantAppReleaseStddevSampOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""
Streaming cursor of the table "tenant_app_release"
"""
input TenantAppReleaseStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TenantAppReleaseStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TenantAppReleaseStreamCursorValueInput {
  appId: String
  buildNumber: Int
  createdAt: timestamptz
  id: uuid
  minBuildNumberRequired: Int
  releaseNotes: String
  requiresOnboarding: Boolean
  status: String
  tenantId: String
  updatedAt: timestamptz
  version: String
}

"""aggregate sum on columns"""
type TenantAppReleaseSumFields {
  buildNumber: Int
  minBuildNumberRequired: Int
}

"""
order by sum() on columns of table "tenant_app_release"
"""
input TenantAppReleaseSumOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""
update columns of table "tenant_app_release"
"""
enum TenantAppReleaseUpdateColumn {
  """column name"""
  appId

  """column name"""
  buildNumber

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  minBuildNumberRequired

  """column name"""
  releaseNotes

  """column name"""
  requiresOnboarding

  """column name"""
  status

  """column name"""
  tenantId

  """column name"""
  updatedAt

  """column name"""
  version
}

input TenantAppReleaseUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TenantAppReleaseIncInput

  """sets the columns of the filtered rows to the given values"""
  _set: TenantAppReleaseSetInput

  """filter the rows which have to be updated"""
  where: TenantAppReleaseBoolExp!
}

"""aggregate varPop on columns"""
type TenantAppReleaseVarPopFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by varPop() on columns of table "tenant_app_release"
"""
input TenantAppReleaseVarPopOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""aggregate varSamp on columns"""
type TenantAppReleaseVarSampFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by varSamp() on columns of table "tenant_app_release"
"""
input TenantAppReleaseVarSampOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""aggregate variance on columns"""
type TenantAppReleaseVarianceFields {
  buildNumber: Float
  minBuildNumberRequired: Float
}

"""
order by variance() on columns of table "tenant_app_release"
"""
input TenantAppReleaseVarianceOrderBy {
  buildNumber: OrderBy
  minBuildNumberRequired: OrderBy
}

"""
select columns of table "tenant_app"
"""
enum TenantAppSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

"""
input type for updating data in table "tenant_app"
"""
input TenantAppSetInput {
  createdAt: timestamptz
  id: String
  name: String
  tenantId: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "tenant_app"
"""
input TenantAppStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TenantAppStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TenantAppStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  name: String
  tenantId: String
  updatedAt: timestamptz
}

"""
update columns of table "tenant_app"
"""
enum TenantAppUpdateColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  name

  """column name"""
  tenantId

  """column name"""
  updatedAt
}

input TenantAppUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: TenantAppSetInput

  """filter the rows which have to be updated"""
  where: TenantAppBoolExp!
}

"""
Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'.
"""
input TenantBoolExp {
  _and: [TenantBoolExp!]
  _not: TenantBoolExp
  _or: [TenantBoolExp!]
  apps: TenantAppBoolExp
  appsAggregate: TenantAppAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  domain: CitextComparisonExp
  id: StringComparisonExp
  name: StringComparisonExp
  profileId: UuidComparisonExp
  transactionalFromEmail: CitextComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""Ordering options when selecting data from "tenant"."""
input TenantOrderBy {
  appsAggregate: TenantAppAggregateOrderBy
  createdAt: OrderBy
  domain: OrderBy
  id: OrderBy
  name: OrderBy
  profileId: OrderBy
  transactionalFromEmail: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "tenant"
"""
enum TenantSelectColumn {
  """column name"""
  createdAt

  """column name"""
  domain

  """column name"""
  id

  """column name"""
  name

  """column name"""
  profileId

  """column name"""
  transactionalFromEmail

  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "tenant"
"""
input TenantStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TenantStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TenantStreamCursorValueInput {
  createdAt: timestamptz
  domain: citext

  """url friendly version of name"""
  id: String
  name: String
  profileId: uuid
  transactionalFromEmail: citext
  updatedAt: timestamptz
}

"""
Boolean expression to compare columns of type "time". All fields are combined with logical 'AND'.
"""
input TimeComparisonExp {
  _eq: time
  _gt: time
  _gte: time
  _in: [time!]
  _isNull: Boolean
  _lt: time
  _lte: time
  _neq: time
  _nin: [time!]
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
Boolean expression to compare columns of type "timetz". All fields are combined with logical 'AND'.
"""
input TimetzComparisonExp {
  _eq: timetz
  _gt: timetz
  _gte: timetz
  _in: [timetz!]
  _isNull: Boolean
  _lt: timetz
  _lte: timetz
  _neq: timetz
  _nin: [timetz!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "value_kind"
"""
type ValueKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "value_kind". All fields are combined with a logical 'AND'.
"""
input ValueKindBoolExp {
  _and: [ValueKindBoolExp!]
  _not: ValueKindBoolExp
  _or: [ValueKindBoolExp!]
  id: StringComparisonExp
}

enum ValueKindEnum {
  BOOLEAN
  DATE
  FILE
  IMAGE
  JSON
  LINK
  NUMBER
  RICH_TEXT
  SELECT
  TEXT
  TOGGLE
  YAML
}

"""
Boolean expression to compare columns of type "ValueKindEnum". All fields are combined with logical 'AND'.
"""
input ValueKindEnumComparisonExp {
  _eq: ValueKindEnum
  _in: [ValueKindEnum!]
  _isNull: Boolean
  _neq: ValueKindEnum
  _nin: [ValueKindEnum!]
}

"""Ordering options when selecting data from "value_kind"."""
input ValueKindOrderBy {
  id: OrderBy
}

"""
select columns of table "value_kind"
"""
enum ValueKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "value_kind"
"""
input ValueKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ValueKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ValueKindStreamCursorValueInput {
  id: String
}

"""
columns and relationships of "visibility_kind"
"""
type VisibilityKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "visibility_kind". All fields are combined with a logical 'AND'.
"""
input VisibilityKindBoolExp {
  _and: [VisibilityKindBoolExp!]
  _not: VisibilityKindBoolExp
  _or: [VisibilityKindBoolExp!]
  id: StringComparisonExp
}

enum VisibilityKindEnum {
  PRIVATE_SELF
  PRIVATE_TENANT_CUSTOM
  PRIVATE_USERS
  PUBLIC
}

"""
Boolean expression to compare columns of type "VisibilityKindEnum". All fields are combined with logical 'AND'.
"""
input VisibilityKindEnumComparisonExp {
  _eq: VisibilityKindEnum
  _in: [VisibilityKindEnum!]
  _isNull: Boolean
  _neq: VisibilityKindEnum
  _nin: [VisibilityKindEnum!]
}

"""Ordering options when selecting data from "visibility_kind"."""
input VisibilityKindOrderBy {
  id: OrderBy
}

"""
select columns of table "visibility_kind"
"""
enum VisibilityKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "visibility_kind"
"""
input VisibilityKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: VisibilityKindStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input VisibilityKindStreamCursorValueInput {
  id: String
}

input authAccountAggregateBoolExpCount {
  arguments: [AuthAccountSelectColumn!]
  distinct: Boolean
  filter: AuthAccountBoolExp
  predicate: IntComparisonExp!
}

input authSessionAggregateBoolExpCount {
  arguments: [AuthSessionSelectColumn!]
  distinct: Boolean
  filter: AuthSessionBoolExp
  predicate: IntComparisonExp!
}

input categoryAggregateBoolExpCount {
  arguments: [CategorySelectColumn!]
  distinct: Boolean
  filter: CategoryBoolExp
  predicate: IntComparisonExp!
}

scalar citext

input contactOptInAggregateBoolExpBool_and {
  arguments: ContactOptInSelectColumnContactOptInAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ContactOptInBoolExp
  predicate: BooleanComparisonExp!
}

input contactOptInAggregateBoolExpBool_or {
  arguments: ContactOptInSelectColumnContactOptInAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ContactOptInBoolExp
  predicate: BooleanComparisonExp!
}

input contactOptInAggregateBoolExpCount {
  arguments: [ContactOptInSelectColumn!]
  distinct: Boolean
  filter: ContactOptInBoolExp
  predicate: IntComparisonExp!
}

input courseExerciseCategoryAggregateBoolExpCount {
  arguments: [CourseExerciseCategorySelectColumn!]
  distinct: Boolean
  filter: CourseExerciseCategoryBoolExp
  predicate: IntComparisonExp!
}

input courseExerciseEntryAggregateBoolExpCount {
  arguments: [CourseExerciseEntrySelectColumn!]
  distinct: Boolean
  filter: CourseExerciseEntryBoolExp
  predicate: IntComparisonExp!
}

input courseExerciseMediaItemAggregateBoolExpCount {
  arguments: [CourseExerciseMediaItemSelectColumn!]
  distinct: Boolean
  filter: CourseExerciseMediaItemBoolExp
  predicate: IntComparisonExp!
}

input courseLessonAggregateBoolExpCount {
  arguments: [CourseLessonSelectColumn!]
  distinct: Boolean
  filter: CourseLessonBoolExp
  predicate: IntComparisonExp!
}

input courseLessonSectionAggregateBoolExpCount {
  arguments: [CourseLessonSectionSelectColumn!]
  distinct: Boolean
  filter: CourseLessonSectionBoolExp
  predicate: IntComparisonExp!
}

input courseLessonSectionExerciseAggregateBoolExpCount {
  arguments: [CourseLessonSectionExerciseSelectColumn!]
  distinct: Boolean
  filter: CourseLessonSectionExerciseBoolExp
  predicate: IntComparisonExp!
}

input courseLessonSectionExerciseSubAggregateBoolExpCount {
  arguments: [CourseLessonSectionExerciseSubSelectColumn!]
  distinct: Boolean
  filter: CourseLessonSectionExerciseSubBoolExp
  predicate: IntComparisonExp!
}

scalar date

input documentBlockAggregateBoolExpCount {
  arguments: [DocumentBlockSelectColumn!]
  distinct: Boolean
  filter: DocumentBlockBoolExp
  predicate: IntComparisonExp!
}

input eventTicketOptionAggregateBoolExpCount {
  arguments: [EventTicketOptionSelectColumn!]
  distinct: Boolean
  filter: EventTicketOptionBoolExp
  predicate: IntComparisonExp!
}

input gameRafflePrizeAggregateBoolExpCount {
  arguments: [GameRafflePrizeSelectColumn!]
  distinct: Boolean
  filter: GameRafflePrizeBoolExp
  predicate: IntComparisonExp!
}

input gameRaffleTicketAggregateBoolExpBool_and {
  arguments: GameRaffleTicketSelectColumnGameRaffleTicketAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: GameRaffleTicketBoolExp
  predicate: BooleanComparisonExp!
}

input gameRaffleTicketAggregateBoolExpBool_or {
  arguments: GameRaffleTicketSelectColumnGameRaffleTicketAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: GameRaffleTicketBoolExp
  predicate: BooleanComparisonExp!
}

input gameRaffleTicketAggregateBoolExpCount {
  arguments: [GameRaffleTicketSelectColumn!]
  distinct: Boolean
  filter: GameRaffleTicketBoolExp
  predicate: IntComparisonExp!
}

input gameRaffleTicketOptionAggregateBoolExpBool_and {
  arguments: GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: GameRaffleTicketOptionBoolExp
  predicate: BooleanComparisonExp!
}

input gameRaffleTicketOptionAggregateBoolExpBool_or {
  arguments: GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: GameRaffleTicketOptionBoolExp
  predicate: BooleanComparisonExp!
}

input gameRaffleTicketOptionAggregateBoolExpCount {
  arguments: [GameRaffleTicketOptionSelectColumn!]
  distinct: Boolean
  filter: GameRaffleTicketOptionBoolExp
  predicate: IntComparisonExp!
}

scalar jsonb

input logAggregateBoolExpCount {
  arguments: [LogSelectColumn!]
  distinct: Boolean
  filter: LogBoolExp
  predicate: IntComparisonExp!
}

input mediaItemTagAggregateBoolExpCount {
  arguments: [MediaItemTagSelectColumn!]
  distinct: Boolean
  filter: MediaItemTagBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  aiRequest(args: AiRequestInput!): AiRequestOutput
  authAnonymousSignIn(args: AuthAnonymousInput!): AuthOutput
  authEmailSendVerification(args: AuthEmailInput!): AuthOutput
  authEmailUpdate(args: AuthEmailInput!): AuthOutput
  authEmailVerify(args: AuthEmailTicketInput!): AuthOutput
  authMagicLinkSendEmail(args: AuthEmailInput!): AuthOutput
  authMagicLinkSignIn(args: AuthEmailTicketInput!): AuthOutput
  authMagicLinkSignUpAndSend(args: AuthEmailSignupInput!): AuthOutput
  authPasswordReset(args: AuthResetPasswordInput!): AuthOutput
  authPasswordSendResetEmail(args: AuthEmailInput!): AuthOutput
  authPasswordSignIn(args: AuthEmailPasswordInput!): AuthOutput
  authPasswordSignUpAndSendVerification(args: AuthEmailPasswordSignUpInput!): AuthOutput
  authSmsSendCode(args: AuthSmsInput!): AuthOutput
  authSmsSignIn(args: AuthSmsCodeInput!): AuthOutput
  authSmsSignUpAndSend(args: AuthSmsSignUpInput!): AuthOutput
  authSmsUpdate(args: AuthSmsInput!): AuthOutput
  authSmsVerify(args: AuthSmsCodeInput!): AuthOutput

  """
  delete data from the table: "auth_account"
  """
  deleteAuthAccount(
    """filter the rows which have to be deleted"""
    where: AuthAccountBoolExp!
  ): AuthAccountMutationResponse

  """
  delete single row from the table: "auth_account"
  """
  deleteAuthAccountByPk(id: uuid!): AuthAccount

  """
  delete data from the table: "auth_provider"
  """
  deleteAuthProvider(
    """filter the rows which have to be deleted"""
    where: AuthProviderBoolExp!
  ): AuthProviderMutationResponse

  """
  delete single row from the table: "auth_provider"
  """
  deleteAuthProviderByPk(id: String!, tenantId: String!): AuthProvider

  """
  delete data from the table: "auth_session"
  """
  deleteAuthSession(
    """filter the rows which have to be deleted"""
    where: AuthSessionBoolExp!
  ): AuthSessionMutationResponse

  """
  delete single row from the table: "auth_session"
  """
  deleteAuthSessionByPk(id: uuid!): AuthSession

  """
  delete data from the table: "auth_user"
  """
  deleteAuthUser(
    """filter the rows which have to be deleted"""
    where: AuthUserBoolExp!
  ): AuthUserMutationResponse

  """
  delete single row from the table: "auth_user"
  """
  deleteAuthUserByPk(id: uuid!): AuthUser

  """
  delete data from the table: "category"
  """
  deleteCategory(
    """filter the rows which have to be deleted"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  delete single row from the table: "category"
  """
  deleteCategoryByPk(id: String!, tenantId: String!): Category

  """
  delete data from the table: "category_kind"
  """
  deleteCategoryKind(
    """filter the rows which have to be deleted"""
    where: CategoryKindBoolExp!
  ): CategoryKindMutationResponse

  """
  delete single row from the table: "category_kind"
  """
  deleteCategoryKindByPk(id: String!, tenantId: String!): CategoryKind

  """
  delete data from the table: "contact_opt_in"
  """
  deleteContactOptIn(
    """filter the rows which have to be deleted"""
    where: ContactOptInBoolExp!
  ): ContactOptInMutationResponse

  """
  delete single row from the table: "contact_opt_in"
  """
  deleteContactOptInByPk(id: uuid!): ContactOptIn

  """
  delete data from the table: "course"
  """
  deleteCourse(
    """filter the rows which have to be deleted"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  delete single row from the table: "course"
  """
  deleteCourseByPk(id: uuid!): Course

  """
  delete data from the table: "course_exercise"
  """
  deleteCourseExercise(
    """filter the rows which have to be deleted"""
    where: CourseExerciseBoolExp!
  ): CourseExerciseMutationResponse

  """
  delete single row from the table: "course_exercise"
  """
  deleteCourseExerciseByPk(id: uuid!): CourseExercise

  """
  delete data from the table: "course_exercise_category"
  """
  deleteCourseExerciseCategory(
    """filter the rows which have to be deleted"""
    where: CourseExerciseCategoryBoolExp!
  ): CourseExerciseCategoryMutationResponse

  """
  delete single row from the table: "course_exercise_category"
  """
  deleteCourseExerciseCategoryByPk(categoryId: String!, courseExerciseId: uuid!, tenantId: String!): CourseExerciseCategory

  """
  delete data from the table: "course_exercise_entry"
  """
  deleteCourseExerciseEntry(
    """filter the rows which have to be deleted"""
    where: CourseExerciseEntryBoolExp!
  ): CourseExerciseEntryMutationResponse

  """
  delete single row from the table: "course_exercise_entry"
  """
  deleteCourseExerciseEntryByPk(id: uuid!): CourseExerciseEntry

  """
  delete data from the table: "course_exercise_kind"
  """
  deleteCourseExerciseKind(
    """filter the rows which have to be deleted"""
    where: CourseExerciseKindBoolExp!
  ): CourseExerciseKindMutationResponse

  """
  delete single row from the table: "course_exercise_kind"
  """
  deleteCourseExerciseKindByPk(id: String!, tenantId: String!): CourseExerciseKind

  """
  delete data from the table: "course_exercise_media_item"
  """
  deleteCourseExerciseMediaItem(
    """filter the rows which have to be deleted"""
    where: CourseExerciseMediaItemBoolExp!
  ): CourseExerciseMediaItemMutationResponse

  """
  delete single row from the table: "course_exercise_media_item"
  """
  deleteCourseExerciseMediaItemByPk(courseExerciseId: uuid!, mediaItemId: String!): CourseExerciseMediaItem

  """
  delete data from the table: "course_lesson"
  """
  deleteCourseLesson(
    """filter the rows which have to be deleted"""
    where: CourseLessonBoolExp!
  ): CourseLessonMutationResponse

  """
  delete single row from the table: "course_lesson"
  """
  deleteCourseLessonByPk(id: uuid!): CourseLesson

  """
  delete data from the table: "course_lesson_entry"
  """
  deleteCourseLessonEntry(
    """filter the rows which have to be deleted"""
    where: CourseLessonEntryBoolExp!
  ): CourseLessonEntryMutationResponse

  """
  delete single row from the table: "course_lesson_entry"
  """
  deleteCourseLessonEntryByPk(id: uuid!): CourseLessonEntry

  """
  delete data from the table: "course_lesson_section"
  """
  deleteCourseLessonSection(
    """filter the rows which have to be deleted"""
    where: CourseLessonSectionBoolExp!
  ): CourseLessonSectionMutationResponse

  """
  delete single row from the table: "course_lesson_section"
  """
  deleteCourseLessonSectionByPk(id: uuid!): CourseLessonSection

  """
  delete data from the table: "course_lesson_section_exercise"
  """
  deleteCourseLessonSectionExercise(
    """filter the rows which have to be deleted"""
    where: CourseLessonSectionExerciseBoolExp!
  ): CourseLessonSectionExerciseMutationResponse

  """
  delete single row from the table: "course_lesson_section_exercise"
  """
  deleteCourseLessonSectionExerciseByPk(exerciseId: uuid!, lessonSectionId: uuid!): CourseLessonSectionExercise

  """
  delete data from the table: "course_lesson_section_exercise_sub"
  """
  deleteCourseLessonSectionExerciseSub(
    """filter the rows which have to be deleted"""
    where: CourseLessonSectionExerciseSubBoolExp!
  ): CourseLessonSectionExerciseSubMutationResponse

  """
  delete single row from the table: "course_lesson_section_exercise_sub"
  """
  deleteCourseLessonSectionExerciseSubByPk(id: uuid!): CourseLessonSectionExerciseSub

  """
  delete data from the table: "document"
  """
  deleteDocument(
    """filter the rows which have to be deleted"""
    where: DocumentBoolExp!
  ): DocumentMutationResponse

  """
  delete data from the table: "document_block"
  """
  deleteDocumentBlock(
    """filter the rows which have to be deleted"""
    where: DocumentBlockBoolExp!
  ): DocumentBlockMutationResponse

  """
  delete single row from the table: "document_block"
  """
  deleteDocumentBlockByPk(id: uuid!): DocumentBlock

  """
  delete single row from the table: "document"
  """
  deleteDocumentByPk(id: uuid!): Document

  """
  delete data from the table: "event"
  """
  deleteEvent(
    """filter the rows which have to be deleted"""
    where: EventBoolExp!
  ): EventMutationResponse

  """
  delete data from the table: "event_attendee"
  """
  deleteEventAttendee(
    """filter the rows which have to be deleted"""
    where: EventAttendeeBoolExp!
  ): EventAttendeeMutationResponse

  """
  delete single row from the table: "event_attendee"
  """
  deleteEventAttendeeByPk(id: uuid!): EventAttendee

  """
  delete data from the table: "event_availability"
  """
  deleteEventAvailability(
    """filter the rows which have to be deleted"""
    where: EventAvailabilityBoolExp!
  ): EventAvailabilityMutationResponse

  """
  delete single row from the table: "event_availability"
  """
  deleteEventAvailabilityByPk(id: uuid!): EventAvailability

  """
  delete data from the table: "event_availability_override"
  """
  deleteEventAvailabilityOverride(
    """filter the rows which have to be deleted"""
    where: EventAvailabilityOverrideBoolExp!
  ): EventAvailabilityOverrideMutationResponse

  """
  delete single row from the table: "event_availability_override"
  """
  deleteEventAvailabilityOverrideByPk(id: uuid!): EventAvailabilityOverride

  """
  delete single row from the table: "event"
  """
  deleteEventByPk(id: uuid!): Event

  """
  delete data from the table: "event_kind"
  """
  deleteEventKind(
    """filter the rows which have to be deleted"""
    where: EventKindBoolExp!
  ): EventKindMutationResponse

  """
  delete single row from the table: "event_kind"
  """
  deleteEventKindByPk(id: String!, tenantId: String!): EventKind

  """
  delete data from the table: "event_live"
  """
  deleteEventLive(
    """filter the rows which have to be deleted"""
    where: EventLiveBoolExp!
  ): EventLiveMutationResponse

  """
  delete single row from the table: "event_live"
  """
  deleteEventLiveByPk(id: String!): EventLive

  """
  delete data from the table: "event_recurrence"
  """
  deleteEventRecurrence(
    """filter the rows which have to be deleted"""
    where: EventRecurrenceBoolExp!
  ): EventRecurrenceMutationResponse

  """
  delete single row from the table: "event_recurrence"
  """
  deleteEventRecurrenceByPk(id: uuid!): EventRecurrence

  """
  delete data from the table: "event_template"
  """
  deleteEventTemplate(
    """filter the rows which have to be deleted"""
    where: EventTemplateBoolExp!
  ): EventTemplateMutationResponse

  """
  delete single row from the table: "event_template"
  """
  deleteEventTemplateByPk(id: uuid!): EventTemplate

  """
  delete data from the table: "event_template_tag"
  """
  deleteEventTemplateTag(
    """filter the rows which have to be deleted"""
    where: EventTemplateTagBoolExp!
  ): EventTemplateTagMutationResponse

  """
  delete single row from the table: "event_template_tag"
  """
  deleteEventTemplateTagByPk(eventTemplateId: uuid!, tag: String!): EventTemplateTag

  """
  delete data from the table: "event_ticket_option"
  """
  deleteEventTicketOption(
    """filter the rows which have to be deleted"""
    where: EventTicketOptionBoolExp!
  ): EventTicketOptionMutationResponse

  """
  delete single row from the table: "event_ticket_option"
  """
  deleteEventTicketOptionByPk(eventId: uuid!, productId: uuid!, tenantId: String!): EventTicketOption

  """
  delete data from the table: "game_raffle"
  """
  deleteGameRaffle(
    """filter the rows which have to be deleted"""
    where: GameRaffleBoolExp!
  ): GameRaffleMutationResponse

  """
  delete single row from the table: "game_raffle"
  """
  deleteGameRaffleByPk(id: uuid!): GameRaffle

  """
  delete data from the table: "game_raffle_prize"
  """
  deleteGameRafflePrize(
    """filter the rows which have to be deleted"""
    where: GameRafflePrizeBoolExp!
  ): GameRafflePrizeMutationResponse

  """
  delete single row from the table: "game_raffle_prize"
  """
  deleteGameRafflePrizeByPk(id: uuid!): GameRafflePrize

  """
  delete data from the table: "game_raffle_ticket"
  """
  deleteGameRaffleTicket(
    """filter the rows which have to be deleted"""
    where: GameRaffleTicketBoolExp!
  ): GameRaffleTicketMutationResponse

  """
  delete single row from the table: "game_raffle_ticket"
  """
  deleteGameRaffleTicketByPk(id: uuid!): GameRaffleTicket

  """
  delete data from the table: "game_raffle_ticket_option"
  """
  deleteGameRaffleTicketOption(
    """filter the rows which have to be deleted"""
    where: GameRaffleTicketOptionBoolExp!
  ): GameRaffleTicketOptionMutationResponse

  """
  delete single row from the table: "game_raffle_ticket_option"
  """
  deleteGameRaffleTicketOptionByPk(id: uuid!): GameRaffleTicketOption

  """
  delete data from the table: "geo_location"
  """
  deleteGeoLocation(
    """filter the rows which have to be deleted"""
    where: GeoLocationBoolExp!
  ): GeoLocationMutationResponse

  """
  delete single row from the table: "geo_location"
  """
  deleteGeoLocationByPk(id: uuid!): GeoLocation

  """
  delete data from the table: "log"
  """
  deleteLog(
    """filter the rows which have to be deleted"""
    where: LogBoolExp!
  ): LogMutationResponse

  """
  delete data from the table: "log_activity"
  """
  deleteLogActivity(
    """filter the rows which have to be deleted"""
    where: LogActivityBoolExp!
  ): LogActivityMutationResponse

  """
  delete single row from the table: "log_activity"
  """
  deleteLogActivityByPk(id: uuid!): LogActivity

  """
  delete data from the table: "log_audit"
  """
  deleteLogAudit(
    """filter the rows which have to be deleted"""
    where: LogAuditBoolExp!
  ): LogAuditMutationResponse

  """
  delete single row from the table: "log_audit"
  """
  deleteLogAuditByPk(id: uuid!): LogAudit

  """
  delete single row from the table: "log"
  """
  deleteLogByPk(id: uuid!): Log

  """
  delete data from the table: "media_item"
  """
  deleteMediaItem(
    """filter the rows which have to be deleted"""
    where: MediaItemBoolExp!
  ): MediaItemMutationResponse

  """
  delete single row from the table: "media_item"
  """
  deleteMediaItemByPk(id: String!): MediaItem

  """
  delete data from the table: "media_item_tag"
  """
  deleteMediaItemTag(
    """filter the rows which have to be deleted"""
    where: MediaItemTagBoolExp!
  ): MediaItemTagMutationResponse

  """
  delete single row from the table: "media_item_tag"
  """
  deleteMediaItemTagByPk(mediaItemId: String!, tag: String!): MediaItemTag

  """
  delete data from the table: "notification"
  """
  deleteNotification(
    """filter the rows which have to be deleted"""
    where: NotificationBoolExp!
  ): NotificationMutationResponse

  """
  delete single row from the table: "notification"
  """
  deleteNotificationByPk(id: uuid!): Notification

  """
  delete data from the table: "nutrition_day"
  """
  deleteNutritionDay(
    """filter the rows which have to be deleted"""
    where: NutritionDayBoolExp!
  ): NutritionDayMutationResponse

  """
  delete single row from the table: "nutrition_day"
  """
  deleteNutritionDayByPk(id: uuid!): NutritionDay

  """
  delete data from the table: "nutrition_food"
  """
  deleteNutritionFood(
    """filter the rows which have to be deleted"""
    where: NutritionFoodBoolExp!
  ): NutritionFoodMutationResponse

  """
  delete single row from the table: "nutrition_food"
  """
  deleteNutritionFoodByPk(id: uuid!): NutritionFood

  """
  delete data from the table: "nutrition_meal"
  """
  deleteNutritionMeal(
    """filter the rows which have to be deleted"""
    where: NutritionMealBoolExp!
  ): NutritionMealMutationResponse

  """
  delete single row from the table: "nutrition_meal"
  """
  deleteNutritionMealByPk(id: uuid!): NutritionMeal

  """
  delete data from the table: "nutrition_meal_food"
  """
  deleteNutritionMealFood(
    """filter the rows which have to be deleted"""
    where: NutritionMealFoodBoolExp!
  ): NutritionMealFoodMutationResponse

  """
  delete single row from the table: "nutrition_meal_food"
  """
  deleteNutritionMealFoodByPk(foodId: uuid!, mealId: uuid!): NutritionMealFood

  """
  delete data from the table: "nutrition_plan"
  """
  deleteNutritionPlan(
    """filter the rows which have to be deleted"""
    where: NutritionPlanBoolExp!
  ): NutritionPlanMutationResponse

  """
  delete single row from the table: "nutrition_plan"
  """
  deleteNutritionPlanByPk(id: uuid!): NutritionPlan

  """
  delete data from the table: "post"
  """
  deletePost(
    """filter the rows which have to be deleted"""
    where: PostBoolExp!
  ): PostMutationResponse

  """
  delete single row from the table: "post"
  """
  deletePostByPk(id: uuid!): Post

  """
  delete data from the table: "post_comment"
  """
  deletePostComment(
    """filter the rows which have to be deleted"""
    where: PostCommentBoolExp!
  ): PostCommentMutationResponse

  """
  delete single row from the table: "post_comment"
  """
  deletePostCommentByPk(id: uuid!): PostComment

  """
  delete data from the table: "post_comment_reaction"
  """
  deletePostCommentReaction(
    """filter the rows which have to be deleted"""
    where: PostCommentReactionBoolExp!
  ): PostCommentReactionMutationResponse

  """
  delete single row from the table: "post_comment_reaction"
  """
  deletePostCommentReactionByPk(commentId: uuid!, profileId: uuid!): PostCommentReaction

  """
  delete data from the table: "post_kind"
  """
  deletePostKind(
    """filter the rows which have to be deleted"""
    where: PostKindBoolExp!
  ): PostKindMutationResponse

  """
  delete single row from the table: "post_kind"
  """
  deletePostKindByPk(id: String!, tenantId: String!): PostKind

  """
  delete data from the table: "post_media_item"
  """
  deletePostMediaItem(
    """filter the rows which have to be deleted"""
    where: PostMediaItemBoolExp!
  ): PostMediaItemMutationResponse

  """
  delete single row from the table: "post_media_item"
  """
  deletePostMediaItemByPk(id: uuid!): PostMediaItem

  """
  delete data from the table: "post_reaction"
  """
  deletePostReaction(
    """filter the rows which have to be deleted"""
    where: PostReactionBoolExp!
  ): PostReactionMutationResponse

  """
  delete single row from the table: "post_reaction"
  """
  deletePostReactionByPk(kind: String!, postId: uuid!, profileId: uuid!): PostReaction

  """
  delete data from the table: "post_reaction_kind"
  """
  deletePostReactionKind(
    """filter the rows which have to be deleted"""
    where: PostReactionKindBoolExp!
  ): PostReactionKindMutationResponse

  """
  delete single row from the table: "post_reaction_kind"
  """
  deletePostReactionKindByPk(id: String!, tenantId: String!): PostReactionKind

  """
  delete data from the table: "post_tag"
  """
  deletePostTag(
    """filter the rows which have to be deleted"""
    where: PostTagBoolExp!
  ): PostTagMutationResponse

  """
  delete single row from the table: "post_tag"
  """
  deletePostTagByPk(postId: uuid!, tag: String!): PostTag

  """
  delete data from the table: "profile"
  """
  deleteProfile(
    """filter the rows which have to be deleted"""
    where: ProfileBoolExp!
  ): ProfileMutationResponse

  """
  delete data from the table: "profile_attribute"
  """
  deleteProfileAttribute(
    """filter the rows which have to be deleted"""
    where: ProfileAttributeBoolExp!
  ): ProfileAttributeMutationResponse

  """
  delete single row from the table: "profile_attribute"
  """
  deleteProfileAttributeByPk(id: String!, profileId: uuid!): ProfileAttribute

  """
  delete data from the table: "profile_attribute_kind"
  """
  deleteProfileAttributeKind(
    """filter the rows which have to be deleted"""
    where: ProfileAttributeKindBoolExp!
  ): ProfileAttributeKindMutationResponse

  """
  delete single row from the table: "profile_attribute_kind"
  """
  deleteProfileAttributeKindByPk(id: String!, tenantId: String!): ProfileAttributeKind

  """
  delete data from the table: "profile_attribute_option"
  """
  deleteProfileAttributeOption(
    """filter the rows which have to be deleted"""
    where: ProfileAttributeOptionBoolExp!
  ): ProfileAttributeOptionMutationResponse

  """
  delete single row from the table: "profile_attribute_option"
  """
  deleteProfileAttributeOptionByPk(id: String!, tenantId: String!): ProfileAttributeOption

  """
  delete single row from the table: "profile"
  """
  deleteProfileByPk(id: uuid!): Profile

  """
  delete data from the table: "profile_device"
  """
  deleteProfileDevice(
    """filter the rows which have to be deleted"""
    where: ProfileDeviceBoolExp!
  ): ProfileDeviceMutationResponse

  """
  delete single row from the table: "profile_device"
  """
  deleteProfileDeviceByPk(
    """unique push token"""
    id: String!
  ): ProfileDevice

  """
  delete data from the table: "profile_follower"
  """
  deleteProfileFollower(
    """filter the rows which have to be deleted"""
    where: ProfileFollowerBoolExp!
  ): ProfileFollowerMutationResponse

  """
  delete single row from the table: "profile_follower"
  """
  deleteProfileFollowerByPk(followedProfileId: uuid!, followerId: uuid!): ProfileFollower

  """
  delete data from the table: "profile_health_configuration"
  """
  deleteProfileHealthConfiguration(
    """filter the rows which have to be deleted"""
    where: ProfileHealthConfigurationBoolExp!
  ): ProfileHealthConfigurationMutationResponse

  """
  delete single row from the table: "profile_health_configuration"
  """
  deleteProfileHealthConfigurationByPk(id: uuid!): ProfileHealthConfiguration

  """
  delete data from the table: "profile_identity"
  """
  deleteProfileIdentity(
    """filter the rows which have to be deleted"""
    where: ProfileIdentityBoolExp!
  ): ProfileIdentityMutationResponse

  """
  delete single row from the table: "profile_identity"
  """
  deleteProfileIdentityByPk(id: uuid!): ProfileIdentity

  """
  delete data from the table: "profile_kind"
  """
  deleteProfileKind(
    """filter the rows which have to be deleted"""
    where: ProfileKindBoolExp!
  ): ProfileKindMutationResponse

  """
  delete single row from the table: "profile_kind"
  """
  deleteProfileKindByPk(
    """anonymous_user, user, service_provider, artist, community, etc."""
    id: String!
    tenantId: String!
  ): ProfileKind

  """
  delete data from the table: "profile_manager"
  """
  deleteProfileManager(
    """filter the rows which have to be deleted"""
    where: ProfileManagerBoolExp!
  ): ProfileManagerMutationResponse

  """
  delete single row from the table: "profile_manager"
  """
  deleteProfileManagerByPk(managedProfileId: uuid!, managerId: uuid!): ProfileManager

  """
  delete data from the table: "profile_manager_kind"
  """
  deleteProfileManagerKind(
    """filter the rows which have to be deleted"""
    where: ProfileManagerKindBoolExp!
  ): ProfileManagerKindMutationResponse

  """
  delete single row from the table: "profile_manager_kind"
  """
  deleteProfileManagerKindByPk(
    """owner, manager, etc."""
    id: String!
    tenantId: String!
  ): ProfileManagerKind

  """
  delete data from the table: "profile_stat"
  """
  deleteProfileStat(
    """filter the rows which have to be deleted"""
    where: ProfileStatBoolExp!
  ): ProfileStatMutationResponse

  """
  delete single row from the table: "profile_stat"
  """
  deleteProfileStatByPk(id: uuid!): ProfileStat

  """
  delete data from the table: "profile_stat_kind"
  """
  deleteProfileStatKind(
    """filter the rows which have to be deleted"""
    where: ProfileStatKindBoolExp!
  ): ProfileStatKindMutationResponse

  """
  delete single row from the table: "profile_stat_kind"
  """
  deleteProfileStatKindByPk(id: String!, tenantId: String!): ProfileStatKind

  """
  delete data from the table: "question"
  """
  deleteQuestion(
    """filter the rows which have to be deleted"""
    where: QuestionBoolExp!
  ): QuestionMutationResponse

  """
  delete single row from the table: "question"
  """
  deleteQuestionByPk(id: uuid!): Question

  """
  delete data from the table: "question_option"
  """
  deleteQuestionOption(
    """filter the rows which have to be deleted"""
    where: QuestionOptionBoolExp!
  ): QuestionOptionMutationResponse

  """
  delete single row from the table: "question_option"
  """
  deleteQuestionOptionByPk(id: uuid!): QuestionOption

  """
  delete data from the table: "question_response"
  """
  deleteQuestionResponse(
    """filter the rows which have to be deleted"""
    where: QuestionResponseBoolExp!
  ): QuestionResponseMutationResponse

  """
  delete single row from the table: "question_response"
  """
  deleteQuestionResponseByPk(id: uuid!): QuestionResponse

  """
  delete data from the table: "question_set"
  """
  deleteQuestionSet(
    """filter the rows which have to be deleted"""
    where: QuestionSetBoolExp!
  ): QuestionSetMutationResponse

  """
  delete single row from the table: "question_set"
  """
  deleteQuestionSetByPk(id: uuid!): QuestionSet

  """
  delete data from the table: "shop_order"
  """
  deleteShopOrder(
    """filter the rows which have to be deleted"""
    where: ShopOrderBoolExp!
  ): ShopOrderMutationResponse

  """
  delete single row from the table: "shop_order"
  """
  deleteShopOrderByPk(id: uuid!): ShopOrder

  """
  delete data from the table: "shop_order_item"
  """
  deleteShopOrderItem(
    """filter the rows which have to be deleted"""
    where: ShopOrderItemBoolExp!
  ): ShopOrderItemMutationResponse

  """
  delete single row from the table: "shop_order_item"
  """
  deleteShopOrderItemByPk(id: uuid!): ShopOrderItem

  """
  delete data from the table: "shop_product"
  """
  deleteShopProduct(
    """filter the rows which have to be deleted"""
    where: ShopProductBoolExp!
  ): ShopProductMutationResponse

  """
  delete single row from the table: "shop_product"
  """
  deleteShopProductByPk(id: uuid!): ShopProduct

  """
  delete data from the table: "shop_product_price"
  """
  deleteShopProductPrice(
    """filter the rows which have to be deleted"""
    where: ShopProductPriceBoolExp!
  ): ShopProductPriceMutationResponse

  """
  delete single row from the table: "shop_product_price"
  """
  deleteShopProductPriceByPk(id: uuid!): ShopProductPrice

  """
  delete data from the table: "shop_subscription"
  """
  deleteShopSubscription(
    """filter the rows which have to be deleted"""
    where: ShopSubscriptionBoolExp!
  ): ShopSubscriptionMutationResponse

  """
  delete single row from the table: "shop_subscription"
  """
  deleteShopSubscriptionByPk(id: uuid!): ShopSubscription

  """
  delete data from the table: "tenant_app"
  """
  deleteTenantApp(
    """filter the rows which have to be deleted"""
    where: TenantAppBoolExp!
  ): TenantAppMutationResponse

  """
  delete single row from the table: "tenant_app"
  """
  deleteTenantAppByPk(id: String!, tenantId: String!): TenantApp

  """
  delete data from the table: "tenant_app_release"
  """
  deleteTenantAppRelease(
    """filter the rows which have to be deleted"""
    where: TenantAppReleaseBoolExp!
  ): TenantAppReleaseMutationResponse

  """
  delete single row from the table: "tenant_app_release"
  """
  deleteTenantAppReleaseByPk(id: uuid!): TenantAppRelease
  geoEnsureLocation(args: GeoEnsureLocationInput!): GeoEnsureLocationOutput

  """
  insert data into the table: "auth_account"
  """
  insertAuthAccount(
    """the rows to be inserted"""
    objects: [AuthAccountInsertInput!]!

    """upsert condition"""
    onConflict: AuthAccountOnConflict
  ): AuthAccountMutationResponse

  """
  insert a single row into the table: "auth_account"
  """
  insertAuthAccountOne(
    """the row to be inserted"""
    object: AuthAccountInsertInput!

    """upsert condition"""
    onConflict: AuthAccountOnConflict
  ): AuthAccount

  """
  insert data into the table: "auth_provider"
  """
  insertAuthProvider(
    """the rows to be inserted"""
    objects: [AuthProviderInsertInput!]!

    """upsert condition"""
    onConflict: AuthProviderOnConflict
  ): AuthProviderMutationResponse

  """
  insert a single row into the table: "auth_provider"
  """
  insertAuthProviderOne(
    """the row to be inserted"""
    object: AuthProviderInsertInput!

    """upsert condition"""
    onConflict: AuthProviderOnConflict
  ): AuthProvider

  """
  insert data into the table: "auth_session"
  """
  insertAuthSession(
    """the rows to be inserted"""
    objects: [AuthSessionInsertInput!]!

    """upsert condition"""
    onConflict: AuthSessionOnConflict
  ): AuthSessionMutationResponse

  """
  insert a single row into the table: "auth_session"
  """
  insertAuthSessionOne(
    """the row to be inserted"""
    object: AuthSessionInsertInput!

    """upsert condition"""
    onConflict: AuthSessionOnConflict
  ): AuthSession

  """
  insert data into the table: "auth_user"
  """
  insertAuthUser(
    """the rows to be inserted"""
    objects: [AuthUserInsertInput!]!

    """upsert condition"""
    onConflict: AuthUserOnConflict
  ): AuthUserMutationResponse

  """
  insert a single row into the table: "auth_user"
  """
  insertAuthUserOne(
    """the row to be inserted"""
    object: AuthUserInsertInput!

    """upsert condition"""
    onConflict: AuthUserOnConflict
  ): AuthUser

  """
  insert data into the table: "category"
  """
  insertCategory(
    """the rows to be inserted"""
    objects: [CategoryInsertInput!]!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): CategoryMutationResponse

  """
  insert data into the table: "category_kind"
  """
  insertCategoryKind(
    """the rows to be inserted"""
    objects: [CategoryKindInsertInput!]!

    """upsert condition"""
    onConflict: CategoryKindOnConflict
  ): CategoryKindMutationResponse

  """
  insert a single row into the table: "category_kind"
  """
  insertCategoryKindOne(
    """the row to be inserted"""
    object: CategoryKindInsertInput!

    """upsert condition"""
    onConflict: CategoryKindOnConflict
  ): CategoryKind

  """
  insert a single row into the table: "category"
  """
  insertCategoryOne(
    """the row to be inserted"""
    object: CategoryInsertInput!

    """upsert condition"""
    onConflict: CategoryOnConflict
  ): Category

  """
  insert data into the table: "contact_opt_in"
  """
  insertContactOptIn(
    """the rows to be inserted"""
    objects: [ContactOptInInsertInput!]!

    """upsert condition"""
    onConflict: ContactOptInOnConflict
  ): ContactOptInMutationResponse

  """
  insert a single row into the table: "contact_opt_in"
  """
  insertContactOptInOne(
    """the row to be inserted"""
    object: ContactOptInInsertInput!

    """upsert condition"""
    onConflict: ContactOptInOnConflict
  ): ContactOptIn

  """
  insert data into the table: "course"
  """
  insertCourse(
    """the rows to be inserted"""
    objects: [CourseInsertInput!]!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): CourseMutationResponse

  """
  insert data into the table: "course_exercise"
  """
  insertCourseExercise(
    """the rows to be inserted"""
    objects: [CourseExerciseInsertInput!]!

    """upsert condition"""
    onConflict: CourseExerciseOnConflict
  ): CourseExerciseMutationResponse

  """
  insert data into the table: "course_exercise_category"
  """
  insertCourseExerciseCategory(
    """the rows to be inserted"""
    objects: [CourseExerciseCategoryInsertInput!]!

    """upsert condition"""
    onConflict: CourseExerciseCategoryOnConflict
  ): CourseExerciseCategoryMutationResponse

  """
  insert a single row into the table: "course_exercise_category"
  """
  insertCourseExerciseCategoryOne(
    """the row to be inserted"""
    object: CourseExerciseCategoryInsertInput!

    """upsert condition"""
    onConflict: CourseExerciseCategoryOnConflict
  ): CourseExerciseCategory

  """
  insert data into the table: "course_exercise_entry"
  """
  insertCourseExerciseEntry(
    """the rows to be inserted"""
    objects: [CourseExerciseEntryInsertInput!]!

    """upsert condition"""
    onConflict: CourseExerciseEntryOnConflict
  ): CourseExerciseEntryMutationResponse

  """
  insert a single row into the table: "course_exercise_entry"
  """
  insertCourseExerciseEntryOne(
    """the row to be inserted"""
    object: CourseExerciseEntryInsertInput!

    """upsert condition"""
    onConflict: CourseExerciseEntryOnConflict
  ): CourseExerciseEntry

  """
  insert data into the table: "course_exercise_kind"
  """
  insertCourseExerciseKind(
    """the rows to be inserted"""
    objects: [CourseExerciseKindInsertInput!]!

    """upsert condition"""
    onConflict: CourseExerciseKindOnConflict
  ): CourseExerciseKindMutationResponse

  """
  insert a single row into the table: "course_exercise_kind"
  """
  insertCourseExerciseKindOne(
    """the row to be inserted"""
    object: CourseExerciseKindInsertInput!

    """upsert condition"""
    onConflict: CourseExerciseKindOnConflict
  ): CourseExerciseKind

  """
  insert data into the table: "course_exercise_media_item"
  """
  insertCourseExerciseMediaItem(
    """the rows to be inserted"""
    objects: [CourseExerciseMediaItemInsertInput!]!

    """upsert condition"""
    onConflict: CourseExerciseMediaItemOnConflict
  ): CourseExerciseMediaItemMutationResponse

  """
  insert a single row into the table: "course_exercise_media_item"
  """
  insertCourseExerciseMediaItemOne(
    """the row to be inserted"""
    object: CourseExerciseMediaItemInsertInput!

    """upsert condition"""
    onConflict: CourseExerciseMediaItemOnConflict
  ): CourseExerciseMediaItem

  """
  insert a single row into the table: "course_exercise"
  """
  insertCourseExerciseOne(
    """the row to be inserted"""
    object: CourseExerciseInsertInput!

    """upsert condition"""
    onConflict: CourseExerciseOnConflict
  ): CourseExercise

  """
  insert data into the table: "course_lesson"
  """
  insertCourseLesson(
    """the rows to be inserted"""
    objects: [CourseLessonInsertInput!]!

    """upsert condition"""
    onConflict: CourseLessonOnConflict
  ): CourseLessonMutationResponse

  """
  insert data into the table: "course_lesson_entry"
  """
  insertCourseLessonEntry(
    """the rows to be inserted"""
    objects: [CourseLessonEntryInsertInput!]!

    """upsert condition"""
    onConflict: CourseLessonEntryOnConflict
  ): CourseLessonEntryMutationResponse

  """
  insert a single row into the table: "course_lesson_entry"
  """
  insertCourseLessonEntryOne(
    """the row to be inserted"""
    object: CourseLessonEntryInsertInput!

    """upsert condition"""
    onConflict: CourseLessonEntryOnConflict
  ): CourseLessonEntry

  """
  insert a single row into the table: "course_lesson"
  """
  insertCourseLessonOne(
    """the row to be inserted"""
    object: CourseLessonInsertInput!

    """upsert condition"""
    onConflict: CourseLessonOnConflict
  ): CourseLesson

  """
  insert data into the table: "course_lesson_section"
  """
  insertCourseLessonSection(
    """the rows to be inserted"""
    objects: [CourseLessonSectionInsertInput!]!

    """upsert condition"""
    onConflict: CourseLessonSectionOnConflict
  ): CourseLessonSectionMutationResponse

  """
  insert data into the table: "course_lesson_section_exercise"
  """
  insertCourseLessonSectionExercise(
    """the rows to be inserted"""
    objects: [CourseLessonSectionExerciseInsertInput!]!

    """upsert condition"""
    onConflict: CourseLessonSectionExerciseOnConflict
  ): CourseLessonSectionExerciseMutationResponse

  """
  insert a single row into the table: "course_lesson_section_exercise"
  """
  insertCourseLessonSectionExerciseOne(
    """the row to be inserted"""
    object: CourseLessonSectionExerciseInsertInput!

    """upsert condition"""
    onConflict: CourseLessonSectionExerciseOnConflict
  ): CourseLessonSectionExercise

  """
  insert data into the table: "course_lesson_section_exercise_sub"
  """
  insertCourseLessonSectionExerciseSub(
    """the rows to be inserted"""
    objects: [CourseLessonSectionExerciseSubInsertInput!]!

    """upsert condition"""
    onConflict: CourseLessonSectionExerciseSubOnConflict
  ): CourseLessonSectionExerciseSubMutationResponse

  """
  insert a single row into the table: "course_lesson_section_exercise_sub"
  """
  insertCourseLessonSectionExerciseSubOne(
    """the row to be inserted"""
    object: CourseLessonSectionExerciseSubInsertInput!

    """upsert condition"""
    onConflict: CourseLessonSectionExerciseSubOnConflict
  ): CourseLessonSectionExerciseSub

  """
  insert a single row into the table: "course_lesson_section"
  """
  insertCourseLessonSectionOne(
    """the row to be inserted"""
    object: CourseLessonSectionInsertInput!

    """upsert condition"""
    onConflict: CourseLessonSectionOnConflict
  ): CourseLessonSection

  """
  insert a single row into the table: "course"
  """
  insertCourseOne(
    """the row to be inserted"""
    object: CourseInsertInput!

    """upsert condition"""
    onConflict: CourseOnConflict
  ): Course

  """
  insert data into the table: "document"
  """
  insertDocument(
    """the rows to be inserted"""
    objects: [DocumentInsertInput!]!

    """upsert condition"""
    onConflict: DocumentOnConflict
  ): DocumentMutationResponse

  """
  insert data into the table: "document_block"
  """
  insertDocumentBlock(
    """the rows to be inserted"""
    objects: [DocumentBlockInsertInput!]!

    """upsert condition"""
    onConflict: DocumentBlockOnConflict
  ): DocumentBlockMutationResponse

  """
  insert a single row into the table: "document_block"
  """
  insertDocumentBlockOne(
    """the row to be inserted"""
    object: DocumentBlockInsertInput!

    """upsert condition"""
    onConflict: DocumentBlockOnConflict
  ): DocumentBlock

  """
  insert a single row into the table: "document"
  """
  insertDocumentOne(
    """the row to be inserted"""
    object: DocumentInsertInput!

    """upsert condition"""
    onConflict: DocumentOnConflict
  ): Document

  """
  insert data into the table: "event"
  """
  insertEvent(
    """the rows to be inserted"""
    objects: [EventInsertInput!]!

    """upsert condition"""
    onConflict: EventOnConflict
  ): EventMutationResponse

  """
  insert data into the table: "event_attendee"
  """
  insertEventAttendee(
    """the rows to be inserted"""
    objects: [EventAttendeeInsertInput!]!

    """upsert condition"""
    onConflict: EventAttendeeOnConflict
  ): EventAttendeeMutationResponse

  """
  insert a single row into the table: "event_attendee"
  """
  insertEventAttendeeOne(
    """the row to be inserted"""
    object: EventAttendeeInsertInput!

    """upsert condition"""
    onConflict: EventAttendeeOnConflict
  ): EventAttendee

  """
  insert data into the table: "event_availability"
  """
  insertEventAvailability(
    """the rows to be inserted"""
    objects: [EventAvailabilityInsertInput!]!

    """upsert condition"""
    onConflict: EventAvailabilityOnConflict
  ): EventAvailabilityMutationResponse

  """
  insert a single row into the table: "event_availability"
  """
  insertEventAvailabilityOne(
    """the row to be inserted"""
    object: EventAvailabilityInsertInput!

    """upsert condition"""
    onConflict: EventAvailabilityOnConflict
  ): EventAvailability

  """
  insert data into the table: "event_availability_override"
  """
  insertEventAvailabilityOverride(
    """the rows to be inserted"""
    objects: [EventAvailabilityOverrideInsertInput!]!

    """upsert condition"""
    onConflict: EventAvailabilityOverrideOnConflict
  ): EventAvailabilityOverrideMutationResponse

  """
  insert a single row into the table: "event_availability_override"
  """
  insertEventAvailabilityOverrideOne(
    """the row to be inserted"""
    object: EventAvailabilityOverrideInsertInput!

    """upsert condition"""
    onConflict: EventAvailabilityOverrideOnConflict
  ): EventAvailabilityOverride

  """
  insert data into the table: "event_kind"
  """
  insertEventKind(
    """the rows to be inserted"""
    objects: [EventKindInsertInput!]!

    """upsert condition"""
    onConflict: EventKindOnConflict
  ): EventKindMutationResponse

  """
  insert a single row into the table: "event_kind"
  """
  insertEventKindOne(
    """the row to be inserted"""
    object: EventKindInsertInput!

    """upsert condition"""
    onConflict: EventKindOnConflict
  ): EventKind

  """
  insert data into the table: "event_live"
  """
  insertEventLive(
    """the rows to be inserted"""
    objects: [EventLiveInsertInput!]!

    """upsert condition"""
    onConflict: EventLiveOnConflict
  ): EventLiveMutationResponse

  """
  insert a single row into the table: "event_live"
  """
  insertEventLiveOne(
    """the row to be inserted"""
    object: EventLiveInsertInput!

    """upsert condition"""
    onConflict: EventLiveOnConflict
  ): EventLive

  """
  insert a single row into the table: "event"
  """
  insertEventOne(
    """the row to be inserted"""
    object: EventInsertInput!

    """upsert condition"""
    onConflict: EventOnConflict
  ): Event

  """
  insert data into the table: "event_recurrence"
  """
  insertEventRecurrence(
    """the rows to be inserted"""
    objects: [EventRecurrenceInsertInput!]!

    """upsert condition"""
    onConflict: EventRecurrenceOnConflict
  ): EventRecurrenceMutationResponse

  """
  insert a single row into the table: "event_recurrence"
  """
  insertEventRecurrenceOne(
    """the row to be inserted"""
    object: EventRecurrenceInsertInput!

    """upsert condition"""
    onConflict: EventRecurrenceOnConflict
  ): EventRecurrence

  """
  insert data into the table: "event_template"
  """
  insertEventTemplate(
    """the rows to be inserted"""
    objects: [EventTemplateInsertInput!]!

    """upsert condition"""
    onConflict: EventTemplateOnConflict
  ): EventTemplateMutationResponse

  """
  insert a single row into the table: "event_template"
  """
  insertEventTemplateOne(
    """the row to be inserted"""
    object: EventTemplateInsertInput!

    """upsert condition"""
    onConflict: EventTemplateOnConflict
  ): EventTemplate

  """
  insert data into the table: "event_template_tag"
  """
  insertEventTemplateTag(
    """the rows to be inserted"""
    objects: [EventTemplateTagInsertInput!]!

    """upsert condition"""
    onConflict: EventTemplateTagOnConflict
  ): EventTemplateTagMutationResponse

  """
  insert a single row into the table: "event_template_tag"
  """
  insertEventTemplateTagOne(
    """the row to be inserted"""
    object: EventTemplateTagInsertInput!

    """upsert condition"""
    onConflict: EventTemplateTagOnConflict
  ): EventTemplateTag

  """
  insert data into the table: "event_ticket_option"
  """
  insertEventTicketOption(
    """the rows to be inserted"""
    objects: [EventTicketOptionInsertInput!]!

    """upsert condition"""
    onConflict: EventTicketOptionOnConflict
  ): EventTicketOptionMutationResponse

  """
  insert a single row into the table: "event_ticket_option"
  """
  insertEventTicketOptionOne(
    """the row to be inserted"""
    object: EventTicketOptionInsertInput!

    """upsert condition"""
    onConflict: EventTicketOptionOnConflict
  ): EventTicketOption

  """
  insert data into the table: "game_raffle"
  """
  insertGameRaffle(
    """the rows to be inserted"""
    objects: [GameRaffleInsertInput!]!

    """upsert condition"""
    onConflict: GameRaffleOnConflict
  ): GameRaffleMutationResponse

  """
  insert a single row into the table: "game_raffle"
  """
  insertGameRaffleOne(
    """the row to be inserted"""
    object: GameRaffleInsertInput!

    """upsert condition"""
    onConflict: GameRaffleOnConflict
  ): GameRaffle

  """
  insert data into the table: "game_raffle_prize"
  """
  insertGameRafflePrize(
    """the rows to be inserted"""
    objects: [GameRafflePrizeInsertInput!]!

    """upsert condition"""
    onConflict: GameRafflePrizeOnConflict
  ): GameRafflePrizeMutationResponse

  """
  insert a single row into the table: "game_raffle_prize"
  """
  insertGameRafflePrizeOne(
    """the row to be inserted"""
    object: GameRafflePrizeInsertInput!

    """upsert condition"""
    onConflict: GameRafflePrizeOnConflict
  ): GameRafflePrize

  """
  insert data into the table: "game_raffle_ticket"
  """
  insertGameRaffleTicket(
    """the rows to be inserted"""
    objects: [GameRaffleTicketInsertInput!]!

    """upsert condition"""
    onConflict: GameRaffleTicketOnConflict
  ): GameRaffleTicketMutationResponse

  """
  insert a single row into the table: "game_raffle_ticket"
  """
  insertGameRaffleTicketOne(
    """the row to be inserted"""
    object: GameRaffleTicketInsertInput!

    """upsert condition"""
    onConflict: GameRaffleTicketOnConflict
  ): GameRaffleTicket

  """
  insert data into the table: "game_raffle_ticket_option"
  """
  insertGameRaffleTicketOption(
    """the rows to be inserted"""
    objects: [GameRaffleTicketOptionInsertInput!]!

    """upsert condition"""
    onConflict: GameRaffleTicketOptionOnConflict
  ): GameRaffleTicketOptionMutationResponse

  """
  insert a single row into the table: "game_raffle_ticket_option"
  """
  insertGameRaffleTicketOptionOne(
    """the row to be inserted"""
    object: GameRaffleTicketOptionInsertInput!

    """upsert condition"""
    onConflict: GameRaffleTicketOptionOnConflict
  ): GameRaffleTicketOption

  """
  insert data into the table: "geo_location"
  """
  insertGeoLocation(
    """the rows to be inserted"""
    objects: [GeoLocationInsertInput!]!

    """upsert condition"""
    onConflict: GeoLocationOnConflict
  ): GeoLocationMutationResponse

  """
  insert a single row into the table: "geo_location"
  """
  insertGeoLocationOne(
    """the row to be inserted"""
    object: GeoLocationInsertInput!

    """upsert condition"""
    onConflict: GeoLocationOnConflict
  ): GeoLocation

  """
  insert data into the table: "log"
  """
  insertLog(
    """the rows to be inserted"""
    objects: [LogInsertInput!]!

    """upsert condition"""
    onConflict: LogOnConflict
  ): LogMutationResponse

  """
  insert data into the table: "log_activity"
  """
  insertLogActivity(
    """the rows to be inserted"""
    objects: [LogActivityInsertInput!]!

    """upsert condition"""
    onConflict: LogActivityOnConflict
  ): LogActivityMutationResponse

  """
  insert a single row into the table: "log_activity"
  """
  insertLogActivityOne(
    """the row to be inserted"""
    object: LogActivityInsertInput!

    """upsert condition"""
    onConflict: LogActivityOnConflict
  ): LogActivity

  """
  insert data into the table: "log_audit"
  """
  insertLogAudit(
    """the rows to be inserted"""
    objects: [LogAuditInsertInput!]!

    """upsert condition"""
    onConflict: LogAuditOnConflict
  ): LogAuditMutationResponse

  """
  insert a single row into the table: "log_audit"
  """
  insertLogAuditOne(
    """the row to be inserted"""
    object: LogAuditInsertInput!

    """upsert condition"""
    onConflict: LogAuditOnConflict
  ): LogAudit

  """
  insert a single row into the table: "log"
  """
  insertLogOne(
    """the row to be inserted"""
    object: LogInsertInput!

    """upsert condition"""
    onConflict: LogOnConflict
  ): Log

  """
  insert data into the table: "media_item"
  """
  insertMediaItem(
    """the rows to be inserted"""
    objects: [MediaItemInsertInput!]!

    """upsert condition"""
    onConflict: MediaItemOnConflict
  ): MediaItemMutationResponse

  """
  insert a single row into the table: "media_item"
  """
  insertMediaItemOne(
    """the row to be inserted"""
    object: MediaItemInsertInput!

    """upsert condition"""
    onConflict: MediaItemOnConflict
  ): MediaItem

  """
  insert data into the table: "media_item_tag"
  """
  insertMediaItemTag(
    """the rows to be inserted"""
    objects: [MediaItemTagInsertInput!]!

    """upsert condition"""
    onConflict: MediaItemTagOnConflict
  ): MediaItemTagMutationResponse

  """
  insert a single row into the table: "media_item_tag"
  """
  insertMediaItemTagOne(
    """the row to be inserted"""
    object: MediaItemTagInsertInput!

    """upsert condition"""
    onConflict: MediaItemTagOnConflict
  ): MediaItemTag

  """
  insert data into the table: "notification"
  """
  insertNotification(
    """the rows to be inserted"""
    objects: [NotificationInsertInput!]!

    """upsert condition"""
    onConflict: NotificationOnConflict
  ): NotificationMutationResponse

  """
  insert a single row into the table: "notification"
  """
  insertNotificationOne(
    """the row to be inserted"""
    object: NotificationInsertInput!

    """upsert condition"""
    onConflict: NotificationOnConflict
  ): Notification

  """
  insert data into the table: "nutrition_day"
  """
  insertNutritionDay(
    """the rows to be inserted"""
    objects: [NutritionDayInsertInput!]!

    """upsert condition"""
    onConflict: NutritionDayOnConflict
  ): NutritionDayMutationResponse

  """
  insert a single row into the table: "nutrition_day"
  """
  insertNutritionDayOne(
    """the row to be inserted"""
    object: NutritionDayInsertInput!

    """upsert condition"""
    onConflict: NutritionDayOnConflict
  ): NutritionDay

  """
  insert data into the table: "nutrition_food"
  """
  insertNutritionFood(
    """the rows to be inserted"""
    objects: [NutritionFoodInsertInput!]!

    """upsert condition"""
    onConflict: NutritionFoodOnConflict
  ): NutritionFoodMutationResponse

  """
  insert a single row into the table: "nutrition_food"
  """
  insertNutritionFoodOne(
    """the row to be inserted"""
    object: NutritionFoodInsertInput!

    """upsert condition"""
    onConflict: NutritionFoodOnConflict
  ): NutritionFood

  """
  insert data into the table: "nutrition_meal"
  """
  insertNutritionMeal(
    """the rows to be inserted"""
    objects: [NutritionMealInsertInput!]!

    """upsert condition"""
    onConflict: NutritionMealOnConflict
  ): NutritionMealMutationResponse

  """
  insert data into the table: "nutrition_meal_food"
  """
  insertNutritionMealFood(
    """the rows to be inserted"""
    objects: [NutritionMealFoodInsertInput!]!

    """upsert condition"""
    onConflict: NutritionMealFoodOnConflict
  ): NutritionMealFoodMutationResponse

  """
  insert a single row into the table: "nutrition_meal_food"
  """
  insertNutritionMealFoodOne(
    """the row to be inserted"""
    object: NutritionMealFoodInsertInput!

    """upsert condition"""
    onConflict: NutritionMealFoodOnConflict
  ): NutritionMealFood

  """
  insert a single row into the table: "nutrition_meal"
  """
  insertNutritionMealOne(
    """the row to be inserted"""
    object: NutritionMealInsertInput!

    """upsert condition"""
    onConflict: NutritionMealOnConflict
  ): NutritionMeal

  """
  insert data into the table: "nutrition_plan"
  """
  insertNutritionPlan(
    """the rows to be inserted"""
    objects: [NutritionPlanInsertInput!]!

    """upsert condition"""
    onConflict: NutritionPlanOnConflict
  ): NutritionPlanMutationResponse

  """
  insert a single row into the table: "nutrition_plan"
  """
  insertNutritionPlanOne(
    """the row to be inserted"""
    object: NutritionPlanInsertInput!

    """upsert condition"""
    onConflict: NutritionPlanOnConflict
  ): NutritionPlan

  """
  insert data into the table: "post"
  """
  insertPost(
    """the rows to be inserted"""
    objects: [PostInsertInput!]!

    """upsert condition"""
    onConflict: PostOnConflict
  ): PostMutationResponse

  """
  insert data into the table: "post_comment"
  """
  insertPostComment(
    """the rows to be inserted"""
    objects: [PostCommentInsertInput!]!

    """upsert condition"""
    onConflict: PostCommentOnConflict
  ): PostCommentMutationResponse

  """
  insert a single row into the table: "post_comment"
  """
  insertPostCommentOne(
    """the row to be inserted"""
    object: PostCommentInsertInput!

    """upsert condition"""
    onConflict: PostCommentOnConflict
  ): PostComment

  """
  insert data into the table: "post_comment_reaction"
  """
  insertPostCommentReaction(
    """the rows to be inserted"""
    objects: [PostCommentReactionInsertInput!]!

    """upsert condition"""
    onConflict: PostCommentReactionOnConflict
  ): PostCommentReactionMutationResponse

  """
  insert a single row into the table: "post_comment_reaction"
  """
  insertPostCommentReactionOne(
    """the row to be inserted"""
    object: PostCommentReactionInsertInput!

    """upsert condition"""
    onConflict: PostCommentReactionOnConflict
  ): PostCommentReaction

  """
  insert data into the table: "post_kind"
  """
  insertPostKind(
    """the rows to be inserted"""
    objects: [PostKindInsertInput!]!

    """upsert condition"""
    onConflict: PostKindOnConflict
  ): PostKindMutationResponse

  """
  insert a single row into the table: "post_kind"
  """
  insertPostKindOne(
    """the row to be inserted"""
    object: PostKindInsertInput!

    """upsert condition"""
    onConflict: PostKindOnConflict
  ): PostKind

  """
  insert data into the table: "post_media_item"
  """
  insertPostMediaItem(
    """the rows to be inserted"""
    objects: [PostMediaItemInsertInput!]!

    """upsert condition"""
    onConflict: PostMediaItemOnConflict
  ): PostMediaItemMutationResponse

  """
  insert a single row into the table: "post_media_item"
  """
  insertPostMediaItemOne(
    """the row to be inserted"""
    object: PostMediaItemInsertInput!

    """upsert condition"""
    onConflict: PostMediaItemOnConflict
  ): PostMediaItem

  """
  insert a single row into the table: "post"
  """
  insertPostOne(
    """the row to be inserted"""
    object: PostInsertInput!

    """upsert condition"""
    onConflict: PostOnConflict
  ): Post

  """
  insert data into the table: "post_reaction"
  """
  insertPostReaction(
    """the rows to be inserted"""
    objects: [PostReactionInsertInput!]!

    """upsert condition"""
    onConflict: PostReactionOnConflict
  ): PostReactionMutationResponse

  """
  insert data into the table: "post_reaction_kind"
  """
  insertPostReactionKind(
    """the rows to be inserted"""
    objects: [PostReactionKindInsertInput!]!

    """upsert condition"""
    onConflict: PostReactionKindOnConflict
  ): PostReactionKindMutationResponse

  """
  insert a single row into the table: "post_reaction_kind"
  """
  insertPostReactionKindOne(
    """the row to be inserted"""
    object: PostReactionKindInsertInput!

    """upsert condition"""
    onConflict: PostReactionKindOnConflict
  ): PostReactionKind

  """
  insert a single row into the table: "post_reaction"
  """
  insertPostReactionOne(
    """the row to be inserted"""
    object: PostReactionInsertInput!

    """upsert condition"""
    onConflict: PostReactionOnConflict
  ): PostReaction

  """
  insert data into the table: "post_tag"
  """
  insertPostTag(
    """the rows to be inserted"""
    objects: [PostTagInsertInput!]!

    """upsert condition"""
    onConflict: PostTagOnConflict
  ): PostTagMutationResponse

  """
  insert a single row into the table: "post_tag"
  """
  insertPostTagOne(
    """the row to be inserted"""
    object: PostTagInsertInput!

    """upsert condition"""
    onConflict: PostTagOnConflict
  ): PostTag

  """
  insert data into the table: "profile"
  """
  insertProfile(
    """the rows to be inserted"""
    objects: [ProfileInsertInput!]!

    """upsert condition"""
    onConflict: ProfileOnConflict
  ): ProfileMutationResponse

  """
  insert data into the table: "profile_attribute"
  """
  insertProfileAttribute(
    """the rows to be inserted"""
    objects: [ProfileAttributeInsertInput!]!

    """upsert condition"""
    onConflict: ProfileAttributeOnConflict
  ): ProfileAttributeMutationResponse

  """
  insert data into the table: "profile_attribute_kind"
  """
  insertProfileAttributeKind(
    """the rows to be inserted"""
    objects: [ProfileAttributeKindInsertInput!]!

    """upsert condition"""
    onConflict: ProfileAttributeKindOnConflict
  ): ProfileAttributeKindMutationResponse

  """
  insert a single row into the table: "profile_attribute_kind"
  """
  insertProfileAttributeKindOne(
    """the row to be inserted"""
    object: ProfileAttributeKindInsertInput!

    """upsert condition"""
    onConflict: ProfileAttributeKindOnConflict
  ): ProfileAttributeKind

  """
  insert a single row into the table: "profile_attribute"
  """
  insertProfileAttributeOne(
    """the row to be inserted"""
    object: ProfileAttributeInsertInput!

    """upsert condition"""
    onConflict: ProfileAttributeOnConflict
  ): ProfileAttribute

  """
  insert data into the table: "profile_attribute_option"
  """
  insertProfileAttributeOption(
    """the rows to be inserted"""
    objects: [ProfileAttributeOptionInsertInput!]!

    """upsert condition"""
    onConflict: ProfileAttributeOptionOnConflict
  ): ProfileAttributeOptionMutationResponse

  """
  insert a single row into the table: "profile_attribute_option"
  """
  insertProfileAttributeOptionOne(
    """the row to be inserted"""
    object: ProfileAttributeOptionInsertInput!

    """upsert condition"""
    onConflict: ProfileAttributeOptionOnConflict
  ): ProfileAttributeOption

  """
  insert data into the table: "profile_device"
  """
  insertProfileDevice(
    """the rows to be inserted"""
    objects: [ProfileDeviceInsertInput!]!

    """upsert condition"""
    onConflict: ProfileDeviceOnConflict
  ): ProfileDeviceMutationResponse

  """
  insert a single row into the table: "profile_device"
  """
  insertProfileDeviceOne(
    """the row to be inserted"""
    object: ProfileDeviceInsertInput!

    """upsert condition"""
    onConflict: ProfileDeviceOnConflict
  ): ProfileDevice

  """
  insert data into the table: "profile_follower"
  """
  insertProfileFollower(
    """the rows to be inserted"""
    objects: [ProfileFollowerInsertInput!]!

    """upsert condition"""
    onConflict: ProfileFollowerOnConflict
  ): ProfileFollowerMutationResponse

  """
  insert a single row into the table: "profile_follower"
  """
  insertProfileFollowerOne(
    """the row to be inserted"""
    object: ProfileFollowerInsertInput!

    """upsert condition"""
    onConflict: ProfileFollowerOnConflict
  ): ProfileFollower

  """
  insert data into the table: "profile_health_configuration"
  """
  insertProfileHealthConfiguration(
    """the rows to be inserted"""
    objects: [ProfileHealthConfigurationInsertInput!]!

    """upsert condition"""
    onConflict: ProfileHealthConfigurationOnConflict
  ): ProfileHealthConfigurationMutationResponse

  """
  insert a single row into the table: "profile_health_configuration"
  """
  insertProfileHealthConfigurationOne(
    """the row to be inserted"""
    object: ProfileHealthConfigurationInsertInput!

    """upsert condition"""
    onConflict: ProfileHealthConfigurationOnConflict
  ): ProfileHealthConfiguration

  """
  insert data into the table: "profile_identity"
  """
  insertProfileIdentity(
    """the rows to be inserted"""
    objects: [ProfileIdentityInsertInput!]!

    """upsert condition"""
    onConflict: ProfileIdentityOnConflict
  ): ProfileIdentityMutationResponse

  """
  insert a single row into the table: "profile_identity"
  """
  insertProfileIdentityOne(
    """the row to be inserted"""
    object: ProfileIdentityInsertInput!

    """upsert condition"""
    onConflict: ProfileIdentityOnConflict
  ): ProfileIdentity

  """
  insert data into the table: "profile_kind"
  """
  insertProfileKind(
    """the rows to be inserted"""
    objects: [ProfileKindInsertInput!]!

    """upsert condition"""
    onConflict: ProfileKindOnConflict
  ): ProfileKindMutationResponse

  """
  insert a single row into the table: "profile_kind"
  """
  insertProfileKindOne(
    """the row to be inserted"""
    object: ProfileKindInsertInput!

    """upsert condition"""
    onConflict: ProfileKindOnConflict
  ): ProfileKind

  """
  insert data into the table: "profile_manager"
  """
  insertProfileManager(
    """the rows to be inserted"""
    objects: [ProfileManagerInsertInput!]!

    """upsert condition"""
    onConflict: ProfileManagerOnConflict
  ): ProfileManagerMutationResponse

  """
  insert data into the table: "profile_manager_kind"
  """
  insertProfileManagerKind(
    """the rows to be inserted"""
    objects: [ProfileManagerKindInsertInput!]!

    """upsert condition"""
    onConflict: ProfileManagerKindOnConflict
  ): ProfileManagerKindMutationResponse

  """
  insert a single row into the table: "profile_manager_kind"
  """
  insertProfileManagerKindOne(
    """the row to be inserted"""
    object: ProfileManagerKindInsertInput!

    """upsert condition"""
    onConflict: ProfileManagerKindOnConflict
  ): ProfileManagerKind

  """
  insert a single row into the table: "profile_manager"
  """
  insertProfileManagerOne(
    """the row to be inserted"""
    object: ProfileManagerInsertInput!

    """upsert condition"""
    onConflict: ProfileManagerOnConflict
  ): ProfileManager

  """
  insert a single row into the table: "profile"
  """
  insertProfileOne(
    """the row to be inserted"""
    object: ProfileInsertInput!

    """upsert condition"""
    onConflict: ProfileOnConflict
  ): Profile

  """
  insert data into the table: "profile_stat"
  """
  insertProfileStat(
    """the rows to be inserted"""
    objects: [ProfileStatInsertInput!]!

    """upsert condition"""
    onConflict: ProfileStatOnConflict
  ): ProfileStatMutationResponse

  """
  insert data into the table: "profile_stat_kind"
  """
  insertProfileStatKind(
    """the rows to be inserted"""
    objects: [ProfileStatKindInsertInput!]!

    """upsert condition"""
    onConflict: ProfileStatKindOnConflict
  ): ProfileStatKindMutationResponse

  """
  insert a single row into the table: "profile_stat_kind"
  """
  insertProfileStatKindOne(
    """the row to be inserted"""
    object: ProfileStatKindInsertInput!

    """upsert condition"""
    onConflict: ProfileStatKindOnConflict
  ): ProfileStatKind

  """
  insert a single row into the table: "profile_stat"
  """
  insertProfileStatOne(
    """the row to be inserted"""
    object: ProfileStatInsertInput!

    """upsert condition"""
    onConflict: ProfileStatOnConflict
  ): ProfileStat

  """
  insert data into the table: "question"
  """
  insertQuestion(
    """the rows to be inserted"""
    objects: [QuestionInsertInput!]!

    """upsert condition"""
    onConflict: QuestionOnConflict
  ): QuestionMutationResponse

  """
  insert a single row into the table: "question"
  """
  insertQuestionOne(
    """the row to be inserted"""
    object: QuestionInsertInput!

    """upsert condition"""
    onConflict: QuestionOnConflict
  ): Question

  """
  insert data into the table: "question_option"
  """
  insertQuestionOption(
    """the rows to be inserted"""
    objects: [QuestionOptionInsertInput!]!

    """upsert condition"""
    onConflict: QuestionOptionOnConflict
  ): QuestionOptionMutationResponse

  """
  insert a single row into the table: "question_option"
  """
  insertQuestionOptionOne(
    """the row to be inserted"""
    object: QuestionOptionInsertInput!

    """upsert condition"""
    onConflict: QuestionOptionOnConflict
  ): QuestionOption

  """
  insert data into the table: "question_response"
  """
  insertQuestionResponse(
    """the rows to be inserted"""
    objects: [QuestionResponseInsertInput!]!

    """upsert condition"""
    onConflict: QuestionResponseOnConflict
  ): QuestionResponseMutationResponse

  """
  insert a single row into the table: "question_response"
  """
  insertQuestionResponseOne(
    """the row to be inserted"""
    object: QuestionResponseInsertInput!

    """upsert condition"""
    onConflict: QuestionResponseOnConflict
  ): QuestionResponse

  """
  insert data into the table: "question_set"
  """
  insertQuestionSet(
    """the rows to be inserted"""
    objects: [QuestionSetInsertInput!]!

    """upsert condition"""
    onConflict: QuestionSetOnConflict
  ): QuestionSetMutationResponse

  """
  insert a single row into the table: "question_set"
  """
  insertQuestionSetOne(
    """the row to be inserted"""
    object: QuestionSetInsertInput!

    """upsert condition"""
    onConflict: QuestionSetOnConflict
  ): QuestionSet

  """
  insert data into the table: "shop_order"
  """
  insertShopOrder(
    """the rows to be inserted"""
    objects: [ShopOrderInsertInput!]!

    """upsert condition"""
    onConflict: ShopOrderOnConflict
  ): ShopOrderMutationResponse

  """
  insert data into the table: "shop_order_item"
  """
  insertShopOrderItem(
    """the rows to be inserted"""
    objects: [ShopOrderItemInsertInput!]!

    """upsert condition"""
    onConflict: ShopOrderItemOnConflict
  ): ShopOrderItemMutationResponse

  """
  insert a single row into the table: "shop_order_item"
  """
  insertShopOrderItemOne(
    """the row to be inserted"""
    object: ShopOrderItemInsertInput!

    """upsert condition"""
    onConflict: ShopOrderItemOnConflict
  ): ShopOrderItem

  """
  insert a single row into the table: "shop_order"
  """
  insertShopOrderOne(
    """the row to be inserted"""
    object: ShopOrderInsertInput!

    """upsert condition"""
    onConflict: ShopOrderOnConflict
  ): ShopOrder

  """
  insert data into the table: "shop_product"
  """
  insertShopProduct(
    """the rows to be inserted"""
    objects: [ShopProductInsertInput!]!

    """upsert condition"""
    onConflict: ShopProductOnConflict
  ): ShopProductMutationResponse

  """
  insert a single row into the table: "shop_product"
  """
  insertShopProductOne(
    """the row to be inserted"""
    object: ShopProductInsertInput!

    """upsert condition"""
    onConflict: ShopProductOnConflict
  ): ShopProduct

  """
  insert data into the table: "shop_product_price"
  """
  insertShopProductPrice(
    """the rows to be inserted"""
    objects: [ShopProductPriceInsertInput!]!

    """upsert condition"""
    onConflict: ShopProductPriceOnConflict
  ): ShopProductPriceMutationResponse

  """
  insert a single row into the table: "shop_product_price"
  """
  insertShopProductPriceOne(
    """the row to be inserted"""
    object: ShopProductPriceInsertInput!

    """upsert condition"""
    onConflict: ShopProductPriceOnConflict
  ): ShopProductPrice

  """
  insert data into the table: "shop_subscription"
  """
  insertShopSubscription(
    """the rows to be inserted"""
    objects: [ShopSubscriptionInsertInput!]!

    """upsert condition"""
    onConflict: ShopSubscriptionOnConflict
  ): ShopSubscriptionMutationResponse

  """
  insert a single row into the table: "shop_subscription"
  """
  insertShopSubscriptionOne(
    """the row to be inserted"""
    object: ShopSubscriptionInsertInput!

    """upsert condition"""
    onConflict: ShopSubscriptionOnConflict
  ): ShopSubscription

  """
  insert data into the table: "tenant_app"
  """
  insertTenantApp(
    """the rows to be inserted"""
    objects: [TenantAppInsertInput!]!

    """upsert condition"""
    onConflict: TenantAppOnConflict
  ): TenantAppMutationResponse

  """
  insert a single row into the table: "tenant_app"
  """
  insertTenantAppOne(
    """the row to be inserted"""
    object: TenantAppInsertInput!

    """upsert condition"""
    onConflict: TenantAppOnConflict
  ): TenantApp

  """
  insert data into the table: "tenant_app_release"
  """
  insertTenantAppRelease(
    """the rows to be inserted"""
    objects: [TenantAppReleaseInsertInput!]!

    """upsert condition"""
    onConflict: TenantAppReleaseOnConflict
  ): TenantAppReleaseMutationResponse

  """
  insert a single row into the table: "tenant_app_release"
  """
  insertTenantAppReleaseOne(
    """the row to be inserted"""
    object: TenantAppReleaseInsertInput!

    """upsert condition"""
    onConflict: TenantAppReleaseOnConflict
  ): TenantAppRelease
  profileCompleteOnboarding: ProfileCompleteOnboardingOutput
  profileCreateTestProfile(args: CreateTestProfileInput!): CreateTestProfileOutput
  profileSetParentNode(args: ProfileSetParentNodeInput!): ProfileSetParentNodeOutput
  shopCheckoutStart(args: ShopCheckoutStartInput!): ShopCheckoutStartOutput
  shopClaimPromotion(args: ShopClaimPromotionInput!): ShopClaimPromotionOutput
  submitContactForm(args: ContactFormInput!): SuccessOutput
  submitFeedback(args: FeedbackInput!): FeedbackOutput

  """
  update data of the table: "auth_account"
  """
  updateAuthAccount(
    """sets the columns of the filtered rows to the given values"""
    _set: AuthAccountSetInput

    """filter the rows which have to be updated"""
    where: AuthAccountBoolExp!
  ): AuthAccountMutationResponse

  """
  update single row of the table: "auth_account"
  """
  updateAuthAccountByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AuthAccountSetInput
    pkColumns: AuthAccountPkColumnsInput!
  ): AuthAccount

  """
  update multiples rows of table: "auth_account"
  """
  updateAuthAccountMany(
    """updates to execute, in order"""
    updates: [AuthAccountUpdates!]!
  ): [AuthAccountMutationResponse]

  """
  update data of the table: "auth_provider"
  """
  updateAuthProvider(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuthProviderAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuthProviderDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuthProviderDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuthProviderDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuthProviderPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: AuthProviderSetInput

    """filter the rows which have to be updated"""
    where: AuthProviderBoolExp!
  ): AuthProviderMutationResponse

  """
  update single row of the table: "auth_provider"
  """
  updateAuthProviderByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuthProviderAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuthProviderDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuthProviderDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuthProviderDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuthProviderPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: AuthProviderSetInput
    pkColumns: AuthProviderPkColumnsInput!
  ): AuthProvider

  """
  update multiples rows of table: "auth_provider"
  """
  updateAuthProviderMany(
    """updates to execute, in order"""
    updates: [AuthProviderUpdates!]!
  ): [AuthProviderMutationResponse]

  """
  update data of the table: "auth_session"
  """
  updateAuthSession(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuthSessionAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuthSessionDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuthSessionDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuthSessionDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuthSessionPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: AuthSessionSetInput

    """filter the rows which have to be updated"""
    where: AuthSessionBoolExp!
  ): AuthSessionMutationResponse

  """
  update single row of the table: "auth_session"
  """
  updateAuthSessionByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuthSessionAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuthSessionDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuthSessionDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuthSessionDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuthSessionPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: AuthSessionSetInput
    pkColumns: AuthSessionPkColumnsInput!
  ): AuthSession

  """
  update multiples rows of table: "auth_session"
  """
  updateAuthSessionMany(
    """updates to execute, in order"""
    updates: [AuthSessionUpdates!]!
  ): [AuthSessionMutationResponse]

  """
  update data of the table: "auth_user"
  """
  updateAuthUser(
    """sets the columns of the filtered rows to the given values"""
    _set: AuthUserSetInput

    """filter the rows which have to be updated"""
    where: AuthUserBoolExp!
  ): AuthUserMutationResponse

  """
  update single row of the table: "auth_user"
  """
  updateAuthUserByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AuthUserSetInput
    pkColumns: AuthUserPkColumnsInput!
  ): AuthUser

  """
  update multiples rows of table: "auth_user"
  """
  updateAuthUserMany(
    """updates to execute, in order"""
    updates: [AuthUserUpdates!]!
  ): [AuthUserMutationResponse]

  """
  update data of the table: "category"
  """
  updateCategory(
    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput

    """filter the rows which have to be updated"""
    where: CategoryBoolExp!
  ): CategoryMutationResponse

  """
  update single row of the table: "category"
  """
  updateCategoryByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CategorySetInput
    pkColumns: CategoryPkColumnsInput!
  ): Category

  """
  update data of the table: "category_kind"
  """
  updateCategoryKind(
    """sets the columns of the filtered rows to the given values"""
    _set: CategoryKindSetInput

    """filter the rows which have to be updated"""
    where: CategoryKindBoolExp!
  ): CategoryKindMutationResponse

  """
  update single row of the table: "category_kind"
  """
  updateCategoryKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CategoryKindSetInput
    pkColumns: CategoryKindPkColumnsInput!
  ): CategoryKind

  """
  update multiples rows of table: "category_kind"
  """
  updateCategoryKindMany(
    """updates to execute, in order"""
    updates: [CategoryKindUpdates!]!
  ): [CategoryKindMutationResponse]

  """
  update multiples rows of table: "category"
  """
  updateCategoryMany(
    """updates to execute, in order"""
    updates: [CategoryUpdates!]!
  ): [CategoryMutationResponse]

  """
  update data of the table: "contact_opt_in"
  """
  updateContactOptIn(
    """sets the columns of the filtered rows to the given values"""
    _set: ContactOptInSetInput

    """filter the rows which have to be updated"""
    where: ContactOptInBoolExp!
  ): ContactOptInMutationResponse

  """
  update single row of the table: "contact_opt_in"
  """
  updateContactOptInByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ContactOptInSetInput
    pkColumns: ContactOptInPkColumnsInput!
  ): ContactOptIn

  """
  update multiples rows of table: "contact_opt_in"
  """
  updateContactOptInMany(
    """updates to execute, in order"""
    updates: [ContactOptInUpdates!]!
  ): [ContactOptInMutationResponse]

  """
  update data of the table: "course"
  """
  updateCourse(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput

    """filter the rows which have to be updated"""
    where: CourseBoolExp!
  ): CourseMutationResponse

  """
  update single row of the table: "course"
  """
  updateCourseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseSetInput
    pkColumns: CoursePkColumnsInput!
  ): Course

  """
  update data of the table: "course_exercise"
  """
  updateCourseExercise(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CourseExerciseAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: CourseExerciseDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: CourseExerciseDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: CourseExerciseDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CourseExercisePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseSetInput

    """filter the rows which have to be updated"""
    where: CourseExerciseBoolExp!
  ): CourseExerciseMutationResponse

  """
  update single row of the table: "course_exercise"
  """
  updateCourseExerciseByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CourseExerciseAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: CourseExerciseDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: CourseExerciseDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: CourseExerciseDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CourseExercisePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseSetInput
    pkColumns: CourseExercisePkColumnsInput!
  ): CourseExercise

  """
  update data of the table: "course_exercise_category"
  """
  updateCourseExerciseCategory(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseCategorySetInput

    """filter the rows which have to be updated"""
    where: CourseExerciseCategoryBoolExp!
  ): CourseExerciseCategoryMutationResponse

  """
  update single row of the table: "course_exercise_category"
  """
  updateCourseExerciseCategoryByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseCategorySetInput
    pkColumns: CourseExerciseCategoryPkColumnsInput!
  ): CourseExerciseCategory

  """
  update multiples rows of table: "course_exercise_category"
  """
  updateCourseExerciseCategoryMany(
    """updates to execute, in order"""
    updates: [CourseExerciseCategoryUpdates!]!
  ): [CourseExerciseCategoryMutationResponse]

  """
  update data of the table: "course_exercise_entry"
  """
  updateCourseExerciseEntry(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CourseExerciseEntryAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: CourseExerciseEntryDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: CourseExerciseEntryDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: CourseExerciseEntryDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseExerciseEntryIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CourseExerciseEntryPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseEntrySetInput

    """filter the rows which have to be updated"""
    where: CourseExerciseEntryBoolExp!
  ): CourseExerciseEntryMutationResponse

  """
  update single row of the table: "course_exercise_entry"
  """
  updateCourseExerciseEntryByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CourseExerciseEntryAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: CourseExerciseEntryDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: CourseExerciseEntryDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: CourseExerciseEntryDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseExerciseEntryIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CourseExerciseEntryPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseEntrySetInput
    pkColumns: CourseExerciseEntryPkColumnsInput!
  ): CourseExerciseEntry

  """
  update multiples rows of table: "course_exercise_entry"
  """
  updateCourseExerciseEntryMany(
    """updates to execute, in order"""
    updates: [CourseExerciseEntryUpdates!]!
  ): [CourseExerciseEntryMutationResponse]

  """
  update data of the table: "course_exercise_kind"
  """
  updateCourseExerciseKind(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseKindSetInput

    """filter the rows which have to be updated"""
    where: CourseExerciseKindBoolExp!
  ): CourseExerciseKindMutationResponse

  """
  update single row of the table: "course_exercise_kind"
  """
  updateCourseExerciseKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseKindSetInput
    pkColumns: CourseExerciseKindPkColumnsInput!
  ): CourseExerciseKind

  """
  update multiples rows of table: "course_exercise_kind"
  """
  updateCourseExerciseKindMany(
    """updates to execute, in order"""
    updates: [CourseExerciseKindUpdates!]!
  ): [CourseExerciseKindMutationResponse]

  """
  update multiples rows of table: "course_exercise"
  """
  updateCourseExerciseMany(
    """updates to execute, in order"""
    updates: [CourseExerciseUpdates!]!
  ): [CourseExerciseMutationResponse]

  """
  update data of the table: "course_exercise_media_item"
  """
  updateCourseExerciseMediaItem(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseExerciseMediaItemIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseMediaItemSetInput

    """filter the rows which have to be updated"""
    where: CourseExerciseMediaItemBoolExp!
  ): CourseExerciseMediaItemMutationResponse

  """
  update single row of the table: "course_exercise_media_item"
  """
  updateCourseExerciseMediaItemByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseExerciseMediaItemIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseExerciseMediaItemSetInput
    pkColumns: CourseExerciseMediaItemPkColumnsInput!
  ): CourseExerciseMediaItem

  """
  update multiples rows of table: "course_exercise_media_item"
  """
  updateCourseExerciseMediaItemMany(
    """updates to execute, in order"""
    updates: [CourseExerciseMediaItemUpdates!]!
  ): [CourseExerciseMediaItemMutationResponse]

  """
  update data of the table: "course_lesson"
  """
  updateCourseLesson(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSetInput

    """filter the rows which have to be updated"""
    where: CourseLessonBoolExp!
  ): CourseLessonMutationResponse

  """
  update single row of the table: "course_lesson"
  """
  updateCourseLessonByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSetInput
    pkColumns: CourseLessonPkColumnsInput!
  ): CourseLesson

  """
  update data of the table: "course_lesson_entry"
  """
  updateCourseLessonEntry(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CourseLessonEntryAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: CourseLessonEntryDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: CourseLessonEntryDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: CourseLessonEntryDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonEntryIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CourseLessonEntryPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonEntrySetInput

    """filter the rows which have to be updated"""
    where: CourseLessonEntryBoolExp!
  ): CourseLessonEntryMutationResponse

  """
  update single row of the table: "course_lesson_entry"
  """
  updateCourseLessonEntryByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: CourseLessonEntryAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: CourseLessonEntryDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: CourseLessonEntryDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: CourseLessonEntryDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonEntryIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: CourseLessonEntryPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonEntrySetInput
    pkColumns: CourseLessonEntryPkColumnsInput!
  ): CourseLessonEntry

  """
  update multiples rows of table: "course_lesson_entry"
  """
  updateCourseLessonEntryMany(
    """updates to execute, in order"""
    updates: [CourseLessonEntryUpdates!]!
  ): [CourseLessonEntryMutationResponse]

  """
  update multiples rows of table: "course_lesson"
  """
  updateCourseLessonMany(
    """updates to execute, in order"""
    updates: [CourseLessonUpdates!]!
  ): [CourseLessonMutationResponse]

  """
  update data of the table: "course_lesson_section"
  """
  updateCourseLessonSection(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonSectionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSectionSetInput

    """filter the rows which have to be updated"""
    where: CourseLessonSectionBoolExp!
  ): CourseLessonSectionMutationResponse

  """
  update single row of the table: "course_lesson_section"
  """
  updateCourseLessonSectionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonSectionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSectionSetInput
    pkColumns: CourseLessonSectionPkColumnsInput!
  ): CourseLessonSection

  """
  update data of the table: "course_lesson_section_exercise"
  """
  updateCourseLessonSectionExercise(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonSectionExerciseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSectionExerciseSetInput

    """filter the rows which have to be updated"""
    where: CourseLessonSectionExerciseBoolExp!
  ): CourseLessonSectionExerciseMutationResponse

  """
  update single row of the table: "course_lesson_section_exercise"
  """
  updateCourseLessonSectionExerciseByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: CourseLessonSectionExerciseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSectionExerciseSetInput
    pkColumns: CourseLessonSectionExercisePkColumnsInput!
  ): CourseLessonSectionExercise

  """
  update multiples rows of table: "course_lesson_section_exercise"
  """
  updateCourseLessonSectionExerciseMany(
    """updates to execute, in order"""
    updates: [CourseLessonSectionExerciseUpdates!]!
  ): [CourseLessonSectionExerciseMutationResponse]

  """
  update data of the table: "course_lesson_section_exercise_sub"
  """
  updateCourseLessonSectionExerciseSub(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSectionExerciseSubSetInput

    """filter the rows which have to be updated"""
    where: CourseLessonSectionExerciseSubBoolExp!
  ): CourseLessonSectionExerciseSubMutationResponse

  """
  update single row of the table: "course_lesson_section_exercise_sub"
  """
  updateCourseLessonSectionExerciseSubByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: CourseLessonSectionExerciseSubSetInput
    pkColumns: CourseLessonSectionExerciseSubPkColumnsInput!
  ): CourseLessonSectionExerciseSub

  """
  update multiples rows of table: "course_lesson_section_exercise_sub"
  """
  updateCourseLessonSectionExerciseSubMany(
    """updates to execute, in order"""
    updates: [CourseLessonSectionExerciseSubUpdates!]!
  ): [CourseLessonSectionExerciseSubMutationResponse]

  """
  update multiples rows of table: "course_lesson_section"
  """
  updateCourseLessonSectionMany(
    """updates to execute, in order"""
    updates: [CourseLessonSectionUpdates!]!
  ): [CourseLessonSectionMutationResponse]

  """
  update multiples rows of table: "course"
  """
  updateCourseMany(
    """updates to execute, in order"""
    updates: [CourseUpdates!]!
  ): [CourseMutationResponse]

  """
  update data of the table: "document"
  """
  updateDocument(
    """sets the columns of the filtered rows to the given values"""
    _set: DocumentSetInput

    """filter the rows which have to be updated"""
    where: DocumentBoolExp!
  ): DocumentMutationResponse

  """
  update data of the table: "document_block"
  """
  updateDocumentBlock(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: DocumentBlockAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: DocumentBlockDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: DocumentBlockDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: DocumentBlockDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: DocumentBlockPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: DocumentBlockSetInput

    """filter the rows which have to be updated"""
    where: DocumentBlockBoolExp!
  ): DocumentBlockMutationResponse

  """
  update single row of the table: "document_block"
  """
  updateDocumentBlockByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: DocumentBlockAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: DocumentBlockDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: DocumentBlockDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: DocumentBlockDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: DocumentBlockPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: DocumentBlockSetInput
    pkColumns: DocumentBlockPkColumnsInput!
  ): DocumentBlock

  """
  update multiples rows of table: "document_block"
  """
  updateDocumentBlockMany(
    """updates to execute, in order"""
    updates: [DocumentBlockUpdates!]!
  ): [DocumentBlockMutationResponse]

  """
  update single row of the table: "document"
  """
  updateDocumentByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: DocumentSetInput
    pkColumns: DocumentPkColumnsInput!
  ): Document

  """
  update multiples rows of table: "document"
  """
  updateDocumentMany(
    """updates to execute, in order"""
    updates: [DocumentUpdates!]!
  ): [DocumentMutationResponse]

  """
  update data of the table: "event"
  """
  updateEvent(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EventAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EventDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EventDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EventDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EventPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventSetInput

    """filter the rows which have to be updated"""
    where: EventBoolExp!
  ): EventMutationResponse

  """
  update data of the table: "event_attendee"
  """
  updateEventAttendee(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EventAttendeeAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EventAttendeeDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EventAttendeeDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EventAttendeeDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EventAttendeePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventAttendeeSetInput

    """filter the rows which have to be updated"""
    where: EventAttendeeBoolExp!
  ): EventAttendeeMutationResponse

  """
  update single row of the table: "event_attendee"
  """
  updateEventAttendeeByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EventAttendeeAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EventAttendeeDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EventAttendeeDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EventAttendeeDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EventAttendeePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventAttendeeSetInput
    pkColumns: EventAttendeePkColumnsInput!
  ): EventAttendee

  """
  update multiples rows of table: "event_attendee"
  """
  updateEventAttendeeMany(
    """updates to execute, in order"""
    updates: [EventAttendeeUpdates!]!
  ): [EventAttendeeMutationResponse]

  """
  update data of the table: "event_availability"
  """
  updateEventAvailability(
    """sets the columns of the filtered rows to the given values"""
    _set: EventAvailabilitySetInput

    """filter the rows which have to be updated"""
    where: EventAvailabilityBoolExp!
  ): EventAvailabilityMutationResponse

  """
  update single row of the table: "event_availability"
  """
  updateEventAvailabilityByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: EventAvailabilitySetInput
    pkColumns: EventAvailabilityPkColumnsInput!
  ): EventAvailability

  """
  update multiples rows of table: "event_availability"
  """
  updateEventAvailabilityMany(
    """updates to execute, in order"""
    updates: [EventAvailabilityUpdates!]!
  ): [EventAvailabilityMutationResponse]

  """
  update data of the table: "event_availability_override"
  """
  updateEventAvailabilityOverride(
    """sets the columns of the filtered rows to the given values"""
    _set: EventAvailabilityOverrideSetInput

    """filter the rows which have to be updated"""
    where: EventAvailabilityOverrideBoolExp!
  ): EventAvailabilityOverrideMutationResponse

  """
  update single row of the table: "event_availability_override"
  """
  updateEventAvailabilityOverrideByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: EventAvailabilityOverrideSetInput
    pkColumns: EventAvailabilityOverridePkColumnsInput!
  ): EventAvailabilityOverride

  """
  update multiples rows of table: "event_availability_override"
  """
  updateEventAvailabilityOverrideMany(
    """updates to execute, in order"""
    updates: [EventAvailabilityOverrideUpdates!]!
  ): [EventAvailabilityOverrideMutationResponse]

  """
  update single row of the table: "event"
  """
  updateEventByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EventAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EventDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EventDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EventDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EventPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventSetInput
    pkColumns: EventPkColumnsInput!
  ): Event

  """
  update data of the table: "event_kind"
  """
  updateEventKind(
    """sets the columns of the filtered rows to the given values"""
    _set: EventKindSetInput

    """filter the rows which have to be updated"""
    where: EventKindBoolExp!
  ): EventKindMutationResponse

  """
  update single row of the table: "event_kind"
  """
  updateEventKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: EventKindSetInput
    pkColumns: EventKindPkColumnsInput!
  ): EventKind

  """
  update multiples rows of table: "event_kind"
  """
  updateEventKindMany(
    """updates to execute, in order"""
    updates: [EventKindUpdates!]!
  ): [EventKindMutationResponse]

  """
  update data of the table: "event_live"
  """
  updateEventLive(
    """sets the columns of the filtered rows to the given values"""
    _set: EventLiveSetInput

    """filter the rows which have to be updated"""
    where: EventLiveBoolExp!
  ): EventLiveMutationResponse

  """
  update single row of the table: "event_live"
  """
  updateEventLiveByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: EventLiveSetInput
    pkColumns: EventLivePkColumnsInput!
  ): EventLive

  """
  update multiples rows of table: "event_live"
  """
  updateEventLiveMany(
    """updates to execute, in order"""
    updates: [EventLiveUpdates!]!
  ): [EventLiveMutationResponse]

  """
  update multiples rows of table: "event"
  """
  updateEventMany(
    """updates to execute, in order"""
    updates: [EventUpdates!]!
  ): [EventMutationResponse]

  """
  update data of the table: "event_recurrence"
  """
  updateEventRecurrence(
    """increments the numeric columns with given value of the filtered values"""
    _inc: EventRecurrenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventRecurrenceSetInput

    """filter the rows which have to be updated"""
    where: EventRecurrenceBoolExp!
  ): EventRecurrenceMutationResponse

  """
  update single row of the table: "event_recurrence"
  """
  updateEventRecurrenceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: EventRecurrenceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventRecurrenceSetInput
    pkColumns: EventRecurrencePkColumnsInput!
  ): EventRecurrence

  """
  update multiples rows of table: "event_recurrence"
  """
  updateEventRecurrenceMany(
    """updates to execute, in order"""
    updates: [EventRecurrenceUpdates!]!
  ): [EventRecurrenceMutationResponse]

  """
  update data of the table: "event_template"
  """
  updateEventTemplate(
    """sets the columns of the filtered rows to the given values"""
    _set: EventTemplateSetInput

    """filter the rows which have to be updated"""
    where: EventTemplateBoolExp!
  ): EventTemplateMutationResponse

  """
  update single row of the table: "event_template"
  """
  updateEventTemplateByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: EventTemplateSetInput
    pkColumns: EventTemplatePkColumnsInput!
  ): EventTemplate

  """
  update multiples rows of table: "event_template"
  """
  updateEventTemplateMany(
    """updates to execute, in order"""
    updates: [EventTemplateUpdates!]!
  ): [EventTemplateMutationResponse]

  """
  update data of the table: "event_template_tag"
  """
  updateEventTemplateTag(
    """sets the columns of the filtered rows to the given values"""
    _set: EventTemplateTagSetInput

    """filter the rows which have to be updated"""
    where: EventTemplateTagBoolExp!
  ): EventTemplateTagMutationResponse

  """
  update single row of the table: "event_template_tag"
  """
  updateEventTemplateTagByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: EventTemplateTagSetInput
    pkColumns: EventTemplateTagPkColumnsInput!
  ): EventTemplateTag

  """
  update multiples rows of table: "event_template_tag"
  """
  updateEventTemplateTagMany(
    """updates to execute, in order"""
    updates: [EventTemplateTagUpdates!]!
  ): [EventTemplateTagMutationResponse]

  """
  update data of the table: "event_ticket_option"
  """
  updateEventTicketOption(
    """increments the numeric columns with given value of the filtered values"""
    _inc: EventTicketOptionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventTicketOptionSetInput

    """filter the rows which have to be updated"""
    where: EventTicketOptionBoolExp!
  ): EventTicketOptionMutationResponse

  """
  update single row of the table: "event_ticket_option"
  """
  updateEventTicketOptionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: EventTicketOptionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: EventTicketOptionSetInput
    pkColumns: EventTicketOptionPkColumnsInput!
  ): EventTicketOption

  """
  update multiples rows of table: "event_ticket_option"
  """
  updateEventTicketOptionMany(
    """updates to execute, in order"""
    updates: [EventTicketOptionUpdates!]!
  ): [EventTicketOptionMutationResponse]

  """
  update data of the table: "game_raffle"
  """
  updateGameRaffle(
    """sets the columns of the filtered rows to the given values"""
    _set: GameRaffleSetInput

    """filter the rows which have to be updated"""
    where: GameRaffleBoolExp!
  ): GameRaffleMutationResponse

  """
  update single row of the table: "game_raffle"
  """
  updateGameRaffleByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: GameRaffleSetInput
    pkColumns: GameRafflePkColumnsInput!
  ): GameRaffle

  """
  update multiples rows of table: "game_raffle"
  """
  updateGameRaffleMany(
    """updates to execute, in order"""
    updates: [GameRaffleUpdates!]!
  ): [GameRaffleMutationResponse]

  """
  update data of the table: "game_raffle_prize"
  """
  updateGameRafflePrize(
    """sets the columns of the filtered rows to the given values"""
    _set: GameRafflePrizeSetInput

    """filter the rows which have to be updated"""
    where: GameRafflePrizeBoolExp!
  ): GameRafflePrizeMutationResponse

  """
  update single row of the table: "game_raffle_prize"
  """
  updateGameRafflePrizeByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: GameRafflePrizeSetInput
    pkColumns: GameRafflePrizePkColumnsInput!
  ): GameRafflePrize

  """
  update multiples rows of table: "game_raffle_prize"
  """
  updateGameRafflePrizeMany(
    """updates to execute, in order"""
    updates: [GameRafflePrizeUpdates!]!
  ): [GameRafflePrizeMutationResponse]

  """
  update data of the table: "game_raffle_ticket"
  """
  updateGameRaffleTicket(
    """sets the columns of the filtered rows to the given values"""
    _set: GameRaffleTicketSetInput

    """filter the rows which have to be updated"""
    where: GameRaffleTicketBoolExp!
  ): GameRaffleTicketMutationResponse

  """
  update single row of the table: "game_raffle_ticket"
  """
  updateGameRaffleTicketByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: GameRaffleTicketSetInput
    pkColumns: GameRaffleTicketPkColumnsInput!
  ): GameRaffleTicket

  """
  update multiples rows of table: "game_raffle_ticket"
  """
  updateGameRaffleTicketMany(
    """updates to execute, in order"""
    updates: [GameRaffleTicketUpdates!]!
  ): [GameRaffleTicketMutationResponse]

  """
  update data of the table: "game_raffle_ticket_option"
  """
  updateGameRaffleTicketOption(
    """increments the numeric columns with given value of the filtered values"""
    _inc: GameRaffleTicketOptionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: GameRaffleTicketOptionSetInput

    """filter the rows which have to be updated"""
    where: GameRaffleTicketOptionBoolExp!
  ): GameRaffleTicketOptionMutationResponse

  """
  update single row of the table: "game_raffle_ticket_option"
  """
  updateGameRaffleTicketOptionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: GameRaffleTicketOptionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: GameRaffleTicketOptionSetInput
    pkColumns: GameRaffleTicketOptionPkColumnsInput!
  ): GameRaffleTicketOption

  """
  update multiples rows of table: "game_raffle_ticket_option"
  """
  updateGameRaffleTicketOptionMany(
    """updates to execute, in order"""
    updates: [GameRaffleTicketOptionUpdates!]!
  ): [GameRaffleTicketOptionMutationResponse]

  """
  update data of the table: "geo_location"
  """
  updateGeoLocation(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: GeoLocationAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: GeoLocationDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: GeoLocationDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: GeoLocationDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: GeoLocationIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: GeoLocationPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: GeoLocationSetInput

    """filter the rows which have to be updated"""
    where: GeoLocationBoolExp!
  ): GeoLocationMutationResponse

  """
  update single row of the table: "geo_location"
  """
  updateGeoLocationByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: GeoLocationAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: GeoLocationDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: GeoLocationDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: GeoLocationDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: GeoLocationIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: GeoLocationPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: GeoLocationSetInput
    pkColumns: GeoLocationPkColumnsInput!
  ): GeoLocation

  """
  update multiples rows of table: "geo_location"
  """
  updateGeoLocationMany(
    """updates to execute, in order"""
    updates: [GeoLocationUpdates!]!
  ): [GeoLocationMutationResponse]

  """
  update data of the table: "log"
  """
  updateLog(
    """sets the columns of the filtered rows to the given values"""
    _set: LogSetInput

    """filter the rows which have to be updated"""
    where: LogBoolExp!
  ): LogMutationResponse

  """
  update data of the table: "log_activity"
  """
  updateLogActivity(
    """sets the columns of the filtered rows to the given values"""
    _set: LogActivitySetInput

    """filter the rows which have to be updated"""
    where: LogActivityBoolExp!
  ): LogActivityMutationResponse

  """
  update single row of the table: "log_activity"
  """
  updateLogActivityByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: LogActivitySetInput
    pkColumns: LogActivityPkColumnsInput!
  ): LogActivity

  """
  update multiples rows of table: "log_activity"
  """
  updateLogActivityMany(
    """updates to execute, in order"""
    updates: [LogActivityUpdates!]!
  ): [LogActivityMutationResponse]

  """
  update data of the table: "log_audit"
  """
  updateLogAudit(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: LogAuditAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LogAuditDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LogAuditDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LogAuditDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: LogAuditPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: LogAuditSetInput

    """filter the rows which have to be updated"""
    where: LogAuditBoolExp!
  ): LogAuditMutationResponse

  """
  update single row of the table: "log_audit"
  """
  updateLogAuditByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: LogAuditAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LogAuditDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LogAuditDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LogAuditDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: LogAuditPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: LogAuditSetInput
    pkColumns: LogAuditPkColumnsInput!
  ): LogAudit

  """
  update multiples rows of table: "log_audit"
  """
  updateLogAuditMany(
    """updates to execute, in order"""
    updates: [LogAuditUpdates!]!
  ): [LogAuditMutationResponse]

  """
  update single row of the table: "log"
  """
  updateLogByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: LogSetInput
    pkColumns: LogPkColumnsInput!
  ): Log

  """
  update multiples rows of table: "log"
  """
  updateLogMany(
    """updates to execute, in order"""
    updates: [LogUpdates!]!
  ): [LogMutationResponse]

  """
  update data of the table: "media_item"
  """
  updateMediaItem(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: MediaItemAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: MediaItemDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: MediaItemDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: MediaItemDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: MediaItemIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: MediaItemPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: MediaItemSetInput

    """filter the rows which have to be updated"""
    where: MediaItemBoolExp!
  ): MediaItemMutationResponse

  """
  update single row of the table: "media_item"
  """
  updateMediaItemByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: MediaItemAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: MediaItemDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: MediaItemDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: MediaItemDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: MediaItemIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: MediaItemPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: MediaItemSetInput
    pkColumns: MediaItemPkColumnsInput!
  ): MediaItem

  """
  update multiples rows of table: "media_item"
  """
  updateMediaItemMany(
    """updates to execute, in order"""
    updates: [MediaItemUpdates!]!
  ): [MediaItemMutationResponse]

  """
  update data of the table: "media_item_tag"
  """
  updateMediaItemTag(
    """sets the columns of the filtered rows to the given values"""
    _set: MediaItemTagSetInput

    """filter the rows which have to be updated"""
    where: MediaItemTagBoolExp!
  ): MediaItemTagMutationResponse

  """
  update single row of the table: "media_item_tag"
  """
  updateMediaItemTagByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: MediaItemTagSetInput
    pkColumns: MediaItemTagPkColumnsInput!
  ): MediaItemTag

  """
  update multiples rows of table: "media_item_tag"
  """
  updateMediaItemTagMany(
    """updates to execute, in order"""
    updates: [MediaItemTagUpdates!]!
  ): [MediaItemTagMutationResponse]

  """
  update data of the table: "notification"
  """
  updateNotification(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: NotificationAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: NotificationDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: NotificationDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: NotificationDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: NotificationPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: NotificationSetInput

    """filter the rows which have to be updated"""
    where: NotificationBoolExp!
  ): NotificationMutationResponse

  """
  update single row of the table: "notification"
  """
  updateNotificationByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: NotificationAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: NotificationDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: NotificationDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: NotificationDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: NotificationPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: NotificationSetInput
    pkColumns: NotificationPkColumnsInput!
  ): Notification

  """
  update multiples rows of table: "notification"
  """
  updateNotificationMany(
    """updates to execute, in order"""
    updates: [NotificationUpdates!]!
  ): [NotificationMutationResponse]

  """
  update data of the table: "nutrition_day"
  """
  updateNutritionDay(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NutritionDayIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: NutritionDaySetInput

    """filter the rows which have to be updated"""
    where: NutritionDayBoolExp!
  ): NutritionDayMutationResponse

  """
  update single row of the table: "nutrition_day"
  """
  updateNutritionDayByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NutritionDayIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: NutritionDaySetInput
    pkColumns: NutritionDayPkColumnsInput!
  ): NutritionDay

  """
  update multiples rows of table: "nutrition_day"
  """
  updateNutritionDayMany(
    """updates to execute, in order"""
    updates: [NutritionDayUpdates!]!
  ): [NutritionDayMutationResponse]

  """
  update data of the table: "nutrition_food"
  """
  updateNutritionFood(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NutritionFoodIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: NutritionFoodSetInput

    """filter the rows which have to be updated"""
    where: NutritionFoodBoolExp!
  ): NutritionFoodMutationResponse

  """
  update single row of the table: "nutrition_food"
  """
  updateNutritionFoodByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: NutritionFoodIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: NutritionFoodSetInput
    pkColumns: NutritionFoodPkColumnsInput!
  ): NutritionFood

  """
  update multiples rows of table: "nutrition_food"
  """
  updateNutritionFoodMany(
    """updates to execute, in order"""
    updates: [NutritionFoodUpdates!]!
  ): [NutritionFoodMutationResponse]

  """
  update data of the table: "nutrition_meal"
  """
  updateNutritionMeal(
    """sets the columns of the filtered rows to the given values"""
    _set: NutritionMealSetInput

    """filter the rows which have to be updated"""
    where: NutritionMealBoolExp!
  ): NutritionMealMutationResponse

  """
  update single row of the table: "nutrition_meal"
  """
  updateNutritionMealByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: NutritionMealSetInput
    pkColumns: NutritionMealPkColumnsInput!
  ): NutritionMeal

  """
  update data of the table: "nutrition_meal_food"
  """
  updateNutritionMealFood(
    """sets the columns of the filtered rows to the given values"""
    _set: NutritionMealFoodSetInput

    """filter the rows which have to be updated"""
    where: NutritionMealFoodBoolExp!
  ): NutritionMealFoodMutationResponse

  """
  update single row of the table: "nutrition_meal_food"
  """
  updateNutritionMealFoodByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: NutritionMealFoodSetInput
    pkColumns: NutritionMealFoodPkColumnsInput!
  ): NutritionMealFood

  """
  update multiples rows of table: "nutrition_meal_food"
  """
  updateNutritionMealFoodMany(
    """updates to execute, in order"""
    updates: [NutritionMealFoodUpdates!]!
  ): [NutritionMealFoodMutationResponse]

  """
  update multiples rows of table: "nutrition_meal"
  """
  updateNutritionMealMany(
    """updates to execute, in order"""
    updates: [NutritionMealUpdates!]!
  ): [NutritionMealMutationResponse]

  """
  update data of the table: "nutrition_plan"
  """
  updateNutritionPlan(
    """sets the columns of the filtered rows to the given values"""
    _set: NutritionPlanSetInput

    """filter the rows which have to be updated"""
    where: NutritionPlanBoolExp!
  ): NutritionPlanMutationResponse

  """
  update single row of the table: "nutrition_plan"
  """
  updateNutritionPlanByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: NutritionPlanSetInput
    pkColumns: NutritionPlanPkColumnsInput!
  ): NutritionPlan

  """
  update multiples rows of table: "nutrition_plan"
  """
  updateNutritionPlanMany(
    """updates to execute, in order"""
    updates: [NutritionPlanUpdates!]!
  ): [NutritionPlanMutationResponse]

  """
  update data of the table: "post"
  """
  updatePost(
    """sets the columns of the filtered rows to the given values"""
    _set: PostSetInput

    """filter the rows which have to be updated"""
    where: PostBoolExp!
  ): PostMutationResponse

  """
  update single row of the table: "post"
  """
  updatePostByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostSetInput
    pkColumns: PostPkColumnsInput!
  ): Post

  """
  update data of the table: "post_comment"
  """
  updatePostComment(
    """sets the columns of the filtered rows to the given values"""
    _set: PostCommentSetInput

    """filter the rows which have to be updated"""
    where: PostCommentBoolExp!
  ): PostCommentMutationResponse

  """
  update single row of the table: "post_comment"
  """
  updatePostCommentByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostCommentSetInput
    pkColumns: PostCommentPkColumnsInput!
  ): PostComment

  """
  update multiples rows of table: "post_comment"
  """
  updatePostCommentMany(
    """updates to execute, in order"""
    updates: [PostCommentUpdates!]!
  ): [PostCommentMutationResponse]

  """
  update data of the table: "post_comment_reaction"
  """
  updatePostCommentReaction(
    """sets the columns of the filtered rows to the given values"""
    _set: PostCommentReactionSetInput

    """filter the rows which have to be updated"""
    where: PostCommentReactionBoolExp!
  ): PostCommentReactionMutationResponse

  """
  update single row of the table: "post_comment_reaction"
  """
  updatePostCommentReactionByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostCommentReactionSetInput
    pkColumns: PostCommentReactionPkColumnsInput!
  ): PostCommentReaction

  """
  update multiples rows of table: "post_comment_reaction"
  """
  updatePostCommentReactionMany(
    """updates to execute, in order"""
    updates: [PostCommentReactionUpdates!]!
  ): [PostCommentReactionMutationResponse]

  """
  update data of the table: "post_kind"
  """
  updatePostKind(
    """sets the columns of the filtered rows to the given values"""
    _set: PostKindSetInput

    """filter the rows which have to be updated"""
    where: PostKindBoolExp!
  ): PostKindMutationResponse

  """
  update single row of the table: "post_kind"
  """
  updatePostKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostKindSetInput
    pkColumns: PostKindPkColumnsInput!
  ): PostKind

  """
  update multiples rows of table: "post_kind"
  """
  updatePostKindMany(
    """updates to execute, in order"""
    updates: [PostKindUpdates!]!
  ): [PostKindMutationResponse]

  """
  update multiples rows of table: "post"
  """
  updatePostMany(
    """updates to execute, in order"""
    updates: [PostUpdates!]!
  ): [PostMutationResponse]

  """
  update data of the table: "post_media_item"
  """
  updatePostMediaItem(
    """sets the columns of the filtered rows to the given values"""
    _set: PostMediaItemSetInput

    """filter the rows which have to be updated"""
    where: PostMediaItemBoolExp!
  ): PostMediaItemMutationResponse

  """
  update single row of the table: "post_media_item"
  """
  updatePostMediaItemByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostMediaItemSetInput
    pkColumns: PostMediaItemPkColumnsInput!
  ): PostMediaItem

  """
  update multiples rows of table: "post_media_item"
  """
  updatePostMediaItemMany(
    """updates to execute, in order"""
    updates: [PostMediaItemUpdates!]!
  ): [PostMediaItemMutationResponse]

  """
  update data of the table: "post_reaction"
  """
  updatePostReaction(
    """sets the columns of the filtered rows to the given values"""
    _set: PostReactionSetInput

    """filter the rows which have to be updated"""
    where: PostReactionBoolExp!
  ): PostReactionMutationResponse

  """
  update single row of the table: "post_reaction"
  """
  updatePostReactionByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostReactionSetInput
    pkColumns: PostReactionPkColumnsInput!
  ): PostReaction

  """
  update data of the table: "post_reaction_kind"
  """
  updatePostReactionKind(
    """sets the columns of the filtered rows to the given values"""
    _set: PostReactionKindSetInput

    """filter the rows which have to be updated"""
    where: PostReactionKindBoolExp!
  ): PostReactionKindMutationResponse

  """
  update single row of the table: "post_reaction_kind"
  """
  updatePostReactionKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostReactionKindSetInput
    pkColumns: PostReactionKindPkColumnsInput!
  ): PostReactionKind

  """
  update multiples rows of table: "post_reaction_kind"
  """
  updatePostReactionKindMany(
    """updates to execute, in order"""
    updates: [PostReactionKindUpdates!]!
  ): [PostReactionKindMutationResponse]

  """
  update multiples rows of table: "post_reaction"
  """
  updatePostReactionMany(
    """updates to execute, in order"""
    updates: [PostReactionUpdates!]!
  ): [PostReactionMutationResponse]

  """
  update data of the table: "post_tag"
  """
  updatePostTag(
    """sets the columns of the filtered rows to the given values"""
    _set: PostTagSetInput

    """filter the rows which have to be updated"""
    where: PostTagBoolExp!
  ): PostTagMutationResponse

  """
  update single row of the table: "post_tag"
  """
  updatePostTagByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PostTagSetInput
    pkColumns: PostTagPkColumnsInput!
  ): PostTag

  """
  update multiples rows of table: "post_tag"
  """
  updatePostTagMany(
    """updates to execute, in order"""
    updates: [PostTagUpdates!]!
  ): [PostTagMutationResponse]

  """
  update data of the table: "profile"
  """
  updateProfile(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ProfileAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ProfileDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ProfileDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ProfileDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ProfilePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileSetInput

    """filter the rows which have to be updated"""
    where: ProfileBoolExp!
  ): ProfileMutationResponse

  """
  update data of the table: "profile_attribute"
  """
  updateProfileAttribute(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileAttributeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileAttributeSetInput

    """filter the rows which have to be updated"""
    where: ProfileAttributeBoolExp!
  ): ProfileAttributeMutationResponse

  """
  update single row of the table: "profile_attribute"
  """
  updateProfileAttributeByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileAttributeIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileAttributeSetInput
    pkColumns: ProfileAttributePkColumnsInput!
  ): ProfileAttribute

  """
  update data of the table: "profile_attribute_kind"
  """
  updateProfileAttributeKind(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileAttributeKindSetInput

    """filter the rows which have to be updated"""
    where: ProfileAttributeKindBoolExp!
  ): ProfileAttributeKindMutationResponse

  """
  update single row of the table: "profile_attribute_kind"
  """
  updateProfileAttributeKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileAttributeKindSetInput
    pkColumns: ProfileAttributeKindPkColumnsInput!
  ): ProfileAttributeKind

  """
  update multiples rows of table: "profile_attribute_kind"
  """
  updateProfileAttributeKindMany(
    """updates to execute, in order"""
    updates: [ProfileAttributeKindUpdates!]!
  ): [ProfileAttributeKindMutationResponse]

  """
  update multiples rows of table: "profile_attribute"
  """
  updateProfileAttributeMany(
    """updates to execute, in order"""
    updates: [ProfileAttributeUpdates!]!
  ): [ProfileAttributeMutationResponse]

  """
  update data of the table: "profile_attribute_option"
  """
  updateProfileAttributeOption(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileAttributeOptionSetInput

    """filter the rows which have to be updated"""
    where: ProfileAttributeOptionBoolExp!
  ): ProfileAttributeOptionMutationResponse

  """
  update single row of the table: "profile_attribute_option"
  """
  updateProfileAttributeOptionByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileAttributeOptionSetInput
    pkColumns: ProfileAttributeOptionPkColumnsInput!
  ): ProfileAttributeOption

  """
  update multiples rows of table: "profile_attribute_option"
  """
  updateProfileAttributeOptionMany(
    """updates to execute, in order"""
    updates: [ProfileAttributeOptionUpdates!]!
  ): [ProfileAttributeOptionMutationResponse]

  """
  update single row of the table: "profile"
  """
  updateProfileByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ProfileAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ProfileDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ProfileDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ProfileDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ProfilePrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileSetInput
    pkColumns: ProfilePkColumnsInput!
  ): Profile

  """
  update data of the table: "profile_device"
  """
  updateProfileDevice(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileDeviceSetInput

    """filter the rows which have to be updated"""
    where: ProfileDeviceBoolExp!
  ): ProfileDeviceMutationResponse

  """
  update single row of the table: "profile_device"
  """
  updateProfileDeviceByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileDeviceSetInput
    pkColumns: ProfileDevicePkColumnsInput!
  ): ProfileDevice

  """
  update multiples rows of table: "profile_device"
  """
  updateProfileDeviceMany(
    """updates to execute, in order"""
    updates: [ProfileDeviceUpdates!]!
  ): [ProfileDeviceMutationResponse]

  """
  update data of the table: "profile_follower"
  """
  updateProfileFollower(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileFollowerSetInput

    """filter the rows which have to be updated"""
    where: ProfileFollowerBoolExp!
  ): ProfileFollowerMutationResponse

  """
  update single row of the table: "profile_follower"
  """
  updateProfileFollowerByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileFollowerSetInput
    pkColumns: ProfileFollowerPkColumnsInput!
  ): ProfileFollower

  """
  update multiples rows of table: "profile_follower"
  """
  updateProfileFollowerMany(
    """updates to execute, in order"""
    updates: [ProfileFollowerUpdates!]!
  ): [ProfileFollowerMutationResponse]

  """
  update data of the table: "profile_health_configuration"
  """
  updateProfileHealthConfiguration(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileHealthConfigurationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileHealthConfigurationSetInput

    """filter the rows which have to be updated"""
    where: ProfileHealthConfigurationBoolExp!
  ): ProfileHealthConfigurationMutationResponse

  """
  update single row of the table: "profile_health_configuration"
  """
  updateProfileHealthConfigurationByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileHealthConfigurationIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileHealthConfigurationSetInput
    pkColumns: ProfileHealthConfigurationPkColumnsInput!
  ): ProfileHealthConfiguration

  """
  update multiples rows of table: "profile_health_configuration"
  """
  updateProfileHealthConfigurationMany(
    """updates to execute, in order"""
    updates: [ProfileHealthConfigurationUpdates!]!
  ): [ProfileHealthConfigurationMutationResponse]

  """
  update data of the table: "profile_identity"
  """
  updateProfileIdentity(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ProfileIdentityAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ProfileIdentityDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ProfileIdentityDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ProfileIdentityDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ProfileIdentityPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileIdentitySetInput

    """filter the rows which have to be updated"""
    where: ProfileIdentityBoolExp!
  ): ProfileIdentityMutationResponse

  """
  update single row of the table: "profile_identity"
  """
  updateProfileIdentityByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ProfileIdentityAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ProfileIdentityDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ProfileIdentityDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ProfileIdentityDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ProfileIdentityPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileIdentitySetInput
    pkColumns: ProfileIdentityPkColumnsInput!
  ): ProfileIdentity

  """
  update multiples rows of table: "profile_identity"
  """
  updateProfileIdentityMany(
    """updates to execute, in order"""
    updates: [ProfileIdentityUpdates!]!
  ): [ProfileIdentityMutationResponse]

  """
  update data of the table: "profile_kind"
  """
  updateProfileKind(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileKindSetInput

    """filter the rows which have to be updated"""
    where: ProfileKindBoolExp!
  ): ProfileKindMutationResponse

  """
  update single row of the table: "profile_kind"
  """
  updateProfileKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileKindSetInput
    pkColumns: ProfileKindPkColumnsInput!
  ): ProfileKind

  """
  update multiples rows of table: "profile_kind"
  """
  updateProfileKindMany(
    """updates to execute, in order"""
    updates: [ProfileKindUpdates!]!
  ): [ProfileKindMutationResponse]

  """
  update data of the table: "profile_manager"
  """
  updateProfileManager(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileManagerSetInput

    """filter the rows which have to be updated"""
    where: ProfileManagerBoolExp!
  ): ProfileManagerMutationResponse

  """
  update single row of the table: "profile_manager"
  """
  updateProfileManagerByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileManagerSetInput
    pkColumns: ProfileManagerPkColumnsInput!
  ): ProfileManager

  """
  update data of the table: "profile_manager_kind"
  """
  updateProfileManagerKind(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileManagerKindSetInput

    """filter the rows which have to be updated"""
    where: ProfileManagerKindBoolExp!
  ): ProfileManagerKindMutationResponse

  """
  update single row of the table: "profile_manager_kind"
  """
  updateProfileManagerKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileManagerKindSetInput
    pkColumns: ProfileManagerKindPkColumnsInput!
  ): ProfileManagerKind

  """
  update multiples rows of table: "profile_manager_kind"
  """
  updateProfileManagerKindMany(
    """updates to execute, in order"""
    updates: [ProfileManagerKindUpdates!]!
  ): [ProfileManagerKindMutationResponse]

  """
  update multiples rows of table: "profile_manager"
  """
  updateProfileManagerMany(
    """updates to execute, in order"""
    updates: [ProfileManagerUpdates!]!
  ): [ProfileManagerMutationResponse]

  """
  update multiples rows of table: "profile"
  """
  updateProfileMany(
    """updates to execute, in order"""
    updates: [ProfileUpdates!]!
  ): [ProfileMutationResponse]

  """
  update data of the table: "profile_stat"
  """
  updateProfileStat(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileStatIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileStatSetInput

    """filter the rows which have to be updated"""
    where: ProfileStatBoolExp!
  ): ProfileStatMutationResponse

  """
  update single row of the table: "profile_stat"
  """
  updateProfileStatByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProfileStatIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ProfileStatSetInput
    pkColumns: ProfileStatPkColumnsInput!
  ): ProfileStat

  """
  update data of the table: "profile_stat_kind"
  """
  updateProfileStatKind(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileStatKindSetInput

    """filter the rows which have to be updated"""
    where: ProfileStatKindBoolExp!
  ): ProfileStatKindMutationResponse

  """
  update single row of the table: "profile_stat_kind"
  """
  updateProfileStatKindByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ProfileStatKindSetInput
    pkColumns: ProfileStatKindPkColumnsInput!
  ): ProfileStatKind

  """
  update multiples rows of table: "profile_stat_kind"
  """
  updateProfileStatKindMany(
    """updates to execute, in order"""
    updates: [ProfileStatKindUpdates!]!
  ): [ProfileStatKindMutationResponse]

  """
  update multiples rows of table: "profile_stat"
  """
  updateProfileStatMany(
    """updates to execute, in order"""
    updates: [ProfileStatUpdates!]!
  ): [ProfileStatMutationResponse]

  """
  update data of the table: "question"
  """
  updateQuestion(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuestionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: QuestionSetInput

    """filter the rows which have to be updated"""
    where: QuestionBoolExp!
  ): QuestionMutationResponse

  """
  update single row of the table: "question"
  """
  updateQuestionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuestionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: QuestionSetInput
    pkColumns: QuestionPkColumnsInput!
  ): Question

  """
  update multiples rows of table: "question"
  """
  updateQuestionMany(
    """updates to execute, in order"""
    updates: [QuestionUpdates!]!
  ): [QuestionMutationResponse]

  """
  update data of the table: "question_option"
  """
  updateQuestionOption(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuestionOptionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: QuestionOptionSetInput

    """filter the rows which have to be updated"""
    where: QuestionOptionBoolExp!
  ): QuestionOptionMutationResponse

  """
  update single row of the table: "question_option"
  """
  updateQuestionOptionByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuestionOptionIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: QuestionOptionSetInput
    pkColumns: QuestionOptionPkColumnsInput!
  ): QuestionOption

  """
  update multiples rows of table: "question_option"
  """
  updateQuestionOptionMany(
    """updates to execute, in order"""
    updates: [QuestionOptionUpdates!]!
  ): [QuestionOptionMutationResponse]

  """
  update data of the table: "question_response"
  """
  updateQuestionResponse(
    """sets the columns of the filtered rows to the given values"""
    _set: QuestionResponseSetInput

    """filter the rows which have to be updated"""
    where: QuestionResponseBoolExp!
  ): QuestionResponseMutationResponse

  """
  update single row of the table: "question_response"
  """
  updateQuestionResponseByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: QuestionResponseSetInput
    pkColumns: QuestionResponsePkColumnsInput!
  ): QuestionResponse

  """
  update multiples rows of table: "question_response"
  """
  updateQuestionResponseMany(
    """updates to execute, in order"""
    updates: [QuestionResponseUpdates!]!
  ): [QuestionResponseMutationResponse]

  """
  update data of the table: "question_set"
  """
  updateQuestionSet(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuestionSetIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: QuestionSetSetInput

    """filter the rows which have to be updated"""
    where: QuestionSetBoolExp!
  ): QuestionSetMutationResponse

  """
  update single row of the table: "question_set"
  """
  updateQuestionSetByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuestionSetIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: QuestionSetSetInput
    pkColumns: QuestionSetPkColumnsInput!
  ): QuestionSet

  """
  update multiples rows of table: "question_set"
  """
  updateQuestionSetMany(
    """updates to execute, in order"""
    updates: [QuestionSetUpdates!]!
  ): [QuestionSetMutationResponse]

  """
  update data of the table: "shop_order"
  """
  updateShopOrder(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopOrderAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopOrderDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopOrderDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopOrderDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopOrderPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopOrderSetInput

    """filter the rows which have to be updated"""
    where: ShopOrderBoolExp!
  ): ShopOrderMutationResponse

  """
  update single row of the table: "shop_order"
  """
  updateShopOrderByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopOrderAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopOrderDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopOrderDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopOrderDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopOrderPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopOrderSetInput
    pkColumns: ShopOrderPkColumnsInput!
  ): ShopOrder

  """
  update data of the table: "shop_order_item"
  """
  updateShopOrderItem(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopOrderItemAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopOrderItemDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopOrderItemDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopOrderItemDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: ShopOrderItemIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopOrderItemPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopOrderItemSetInput

    """filter the rows which have to be updated"""
    where: ShopOrderItemBoolExp!
  ): ShopOrderItemMutationResponse

  """
  update single row of the table: "shop_order_item"
  """
  updateShopOrderItemByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopOrderItemAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopOrderItemDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopOrderItemDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopOrderItemDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: ShopOrderItemIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopOrderItemPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopOrderItemSetInput
    pkColumns: ShopOrderItemPkColumnsInput!
  ): ShopOrderItem

  """
  update multiples rows of table: "shop_order_item"
  """
  updateShopOrderItemMany(
    """updates to execute, in order"""
    updates: [ShopOrderItemUpdates!]!
  ): [ShopOrderItemMutationResponse]

  """
  update multiples rows of table: "shop_order"
  """
  updateShopOrderMany(
    """updates to execute, in order"""
    updates: [ShopOrderUpdates!]!
  ): [ShopOrderMutationResponse]

  """
  update data of the table: "shop_product"
  """
  updateShopProduct(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopProductAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopProductDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopProductDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopProductDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: ShopProductIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopProductPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopProductSetInput

    """filter the rows which have to be updated"""
    where: ShopProductBoolExp!
  ): ShopProductMutationResponse

  """
  update single row of the table: "shop_product"
  """
  updateShopProductByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopProductAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopProductDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopProductDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopProductDeleteKeyInput

    """increments the numeric columns with given value of the filtered values"""
    _inc: ShopProductIncInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopProductPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopProductSetInput
    pkColumns: ShopProductPkColumnsInput!
  ): ShopProduct

  """
  update multiples rows of table: "shop_product"
  """
  updateShopProductMany(
    """updates to execute, in order"""
    updates: [ShopProductUpdates!]!
  ): [ShopProductMutationResponse]

  """
  update data of the table: "shop_product_price"
  """
  updateShopProductPrice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ShopProductPriceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopProductPriceSetInput

    """filter the rows which have to be updated"""
    where: ShopProductPriceBoolExp!
  ): ShopProductPriceMutationResponse

  """
  update single row of the table: "shop_product_price"
  """
  updateShopProductPriceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ShopProductPriceIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopProductPriceSetInput
    pkColumns: ShopProductPricePkColumnsInput!
  ): ShopProductPrice

  """
  update multiples rows of table: "shop_product_price"
  """
  updateShopProductPriceMany(
    """updates to execute, in order"""
    updates: [ShopProductPriceUpdates!]!
  ): [ShopProductPriceMutationResponse]

  """
  update data of the table: "shop_subscription"
  """
  updateShopSubscription(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopSubscriptionAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopSubscriptionDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopSubscriptionDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopSubscriptionDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopSubscriptionPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopSubscriptionSetInput

    """filter the rows which have to be updated"""
    where: ShopSubscriptionBoolExp!
  ): ShopSubscriptionMutationResponse

  """
  update single row of the table: "shop_subscription"
  """
  updateShopSubscriptionByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ShopSubscriptionAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ShopSubscriptionDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ShopSubscriptionDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ShopSubscriptionDeleteKeyInput

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ShopSubscriptionPrependInput

    """sets the columns of the filtered rows to the given values"""
    _set: ShopSubscriptionSetInput
    pkColumns: ShopSubscriptionPkColumnsInput!
  ): ShopSubscription

  """
  update multiples rows of table: "shop_subscription"
  """
  updateShopSubscriptionMany(
    """updates to execute, in order"""
    updates: [ShopSubscriptionUpdates!]!
  ): [ShopSubscriptionMutationResponse]

  """
  update data of the table: "tenant_app"
  """
  updateTenantApp(
    """sets the columns of the filtered rows to the given values"""
    _set: TenantAppSetInput

    """filter the rows which have to be updated"""
    where: TenantAppBoolExp!
  ): TenantAppMutationResponse

  """
  update single row of the table: "tenant_app"
  """
  updateTenantAppByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: TenantAppSetInput
    pkColumns: TenantAppPkColumnsInput!
  ): TenantApp

  """
  update multiples rows of table: "tenant_app"
  """
  updateTenantAppMany(
    """updates to execute, in order"""
    updates: [TenantAppUpdates!]!
  ): [TenantAppMutationResponse]

  """
  update data of the table: "tenant_app_release"
  """
  updateTenantAppRelease(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TenantAppReleaseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TenantAppReleaseSetInput

    """filter the rows which have to be updated"""
    where: TenantAppReleaseBoolExp!
  ): TenantAppReleaseMutationResponse

  """
  update single row of the table: "tenant_app_release"
  """
  updateTenantAppReleaseByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TenantAppReleaseIncInput

    """sets the columns of the filtered rows to the given values"""
    _set: TenantAppReleaseSetInput
    pkColumns: TenantAppReleasePkColumnsInput!
  ): TenantAppRelease

  """
  update multiples rows of table: "tenant_app_release"
  """
  updateTenantAppReleaseMany(
    """updates to execute, in order"""
    updates: [TenantAppReleaseUpdates!]!
  ): [TenantAppReleaseMutationResponse]
}

scalar numeric

input nutritionDayAggregateBoolExpCount {
  arguments: [NutritionDaySelectColumn!]
  distinct: Boolean
  filter: NutritionDayBoolExp
  predicate: IntComparisonExp!
}

input nutritionMealAggregateBoolExpCount {
  arguments: [NutritionMealSelectColumn!]
  distinct: Boolean
  filter: NutritionMealBoolExp
  predicate: IntComparisonExp!
}

input nutritionMealFoodAggregateBoolExpCount {
  arguments: [NutritionMealFoodSelectColumn!]
  distinct: Boolean
  filter: NutritionMealFoodBoolExp
  predicate: IntComparisonExp!
}

input postAggregateBoolExpBool_and {
  arguments: PostSelectColumnPostAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PostBoolExp
  predicate: BooleanComparisonExp!
}

input postAggregateBoolExpBool_or {
  arguments: PostSelectColumnPostAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PostBoolExp
  predicate: BooleanComparisonExp!
}

input postAggregateBoolExpCount {
  arguments: [PostSelectColumn!]
  distinct: Boolean
  filter: PostBoolExp
  predicate: IntComparisonExp!
}

input postCommentAggregateBoolExpCount {
  arguments: [PostCommentSelectColumn!]
  distinct: Boolean
  filter: PostCommentBoolExp
  predicate: IntComparisonExp!
}

input postCommentReactionAggregateBoolExpCount {
  arguments: [PostCommentReactionSelectColumn!]
  distinct: Boolean
  filter: PostCommentReactionBoolExp
  predicate: IntComparisonExp!
}

input postMediaItemAggregateBoolExpCount {
  arguments: [PostMediaItemSelectColumn!]
  distinct: Boolean
  filter: PostMediaItemBoolExp
  predicate: IntComparisonExp!
}

input postReactionAggregateBoolExpCount {
  arguments: [PostReactionSelectColumn!]
  distinct: Boolean
  filter: PostReactionBoolExp
  predicate: IntComparisonExp!
}

input profileAggregateBoolExpBool_and {
  arguments: ProfileSelectColumnProfileAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ProfileBoolExp
  predicate: BooleanComparisonExp!
}

input profileAggregateBoolExpBool_or {
  arguments: ProfileSelectColumnProfileAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ProfileBoolExp
  predicate: BooleanComparisonExp!
}

input profileAggregateBoolExpCount {
  arguments: [ProfileSelectColumn!]
  distinct: Boolean
  filter: ProfileBoolExp
  predicate: IntComparisonExp!
}

input profileAttributeAggregateBoolExpCount {
  arguments: [ProfileAttributeSelectColumn!]
  distinct: Boolean
  filter: ProfileAttributeBoolExp
  predicate: IntComparisonExp!
}

input profileDeviceAggregateBoolExpBool_and {
  arguments: ProfileDeviceSelectColumnProfileDeviceAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ProfileDeviceBoolExp
  predicate: BooleanComparisonExp!
}

input profileDeviceAggregateBoolExpBool_or {
  arguments: ProfileDeviceSelectColumnProfileDeviceAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ProfileDeviceBoolExp
  predicate: BooleanComparisonExp!
}

input profileDeviceAggregateBoolExpCount {
  arguments: [ProfileDeviceSelectColumn!]
  distinct: Boolean
  filter: ProfileDeviceBoolExp
  predicate: IntComparisonExp!
}

input profileFollowerAggregateBoolExpCount {
  arguments: [ProfileFollowerSelectColumn!]
  distinct: Boolean
  filter: ProfileFollowerBoolExp
  predicate: IntComparisonExp!
}

input profileManagerAggregateBoolExpCount {
  arguments: [ProfileManagerSelectColumn!]
  distinct: Boolean
  filter: ProfileManagerBoolExp
  predicate: IntComparisonExp!
}

input profileStatAggregateBoolExpCount {
  arguments: [ProfileStatSelectColumn!]
  distinct: Boolean
  filter: ProfileStatBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "auth_account"
  """
  authAccount(
    """distinct select on columns"""
    distinctOn: [AuthAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthAccountOrderBy!]

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): [AuthAccount!]!

  """
  fetch aggregated fields from the table: "auth_account"
  """
  authAccountAggregate(
    """distinct select on columns"""
    distinctOn: [AuthAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthAccountOrderBy!]

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): AuthAccountAggregate!

  """fetch data from the table: "auth_account" using primary key columns"""
  authAccountByPk(id: uuid!): AuthAccount

  """
  fetch data from the table: "auth_provider"
  """
  authProvider(
    """distinct select on columns"""
    distinctOn: [AuthProviderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthProviderOrderBy!]

    """filter the rows returned"""
    where: AuthProviderBoolExp
  ): [AuthProvider!]!

  """
  fetch aggregated fields from the table: "auth_provider"
  """
  authProviderAggregate(
    """distinct select on columns"""
    distinctOn: [AuthProviderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthProviderOrderBy!]

    """filter the rows returned"""
    where: AuthProviderBoolExp
  ): AuthProviderAggregate!

  """fetch data from the table: "auth_provider" using primary key columns"""
  authProviderByPk(id: String!, tenantId: String!): AuthProvider

  """
  fetch data from the table: "auth_role_kind"
  """
  authRoleKind(
    """distinct select on columns"""
    distinctOn: [AuthRoleKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthRoleKindOrderBy!]

    """filter the rows returned"""
    where: AuthRoleKindBoolExp
  ): [AuthRoleKind!]!

  """fetch data from the table: "auth_role_kind" using primary key columns"""
  authRoleKindByPk(id: String!): AuthRoleKind

  """
  fetch data from the table: "auth_session"
  """
  authSession(
    """distinct select on columns"""
    distinctOn: [AuthSessionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthSessionOrderBy!]

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): [AuthSession!]!

  """
  fetch aggregated fields from the table: "auth_session"
  """
  authSessionAggregate(
    """distinct select on columns"""
    distinctOn: [AuthSessionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthSessionOrderBy!]

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): AuthSessionAggregate!

  """fetch data from the table: "auth_session" using primary key columns"""
  authSessionByPk(id: uuid!): AuthSession

  """
  fetch data from the table: "auth_user"
  """
  authUser(
    """distinct select on columns"""
    distinctOn: [AuthUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthUserOrderBy!]

    """filter the rows returned"""
    where: AuthUserBoolExp
  ): [AuthUser!]!

  """
  fetch aggregated fields from the table: "auth_user"
  """
  authUserAggregate(
    """distinct select on columns"""
    distinctOn: [AuthUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthUserOrderBy!]

    """filter the rows returned"""
    where: AuthUserBoolExp
  ): AuthUserAggregate!

  """fetch data from the table: "auth_user" using primary key columns"""
  authUserByPk(id: uuid!): AuthUser

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(id: String!, tenantId: String!): Category

  """
  fetch data from the table: "category_kind"
  """
  categoryKind(
    """distinct select on columns"""
    distinctOn: [CategoryKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryKindOrderBy!]

    """filter the rows returned"""
    where: CategoryKindBoolExp
  ): [CategoryKind!]!

  """
  fetch aggregated fields from the table: "category_kind"
  """
  categoryKindAggregate(
    """distinct select on columns"""
    distinctOn: [CategoryKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryKindOrderBy!]

    """filter the rows returned"""
    where: CategoryKindBoolExp
  ): CategoryKindAggregate!

  """fetch data from the table: "category_kind" using primary key columns"""
  categoryKindByPk(id: String!, tenantId: String!): CategoryKind

  """
  fetch data from the table: "contact_opt_in"
  """
  contactOptIn(
    """distinct select on columns"""
    distinctOn: [ContactOptInSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ContactOptInOrderBy!]

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): [ContactOptIn!]!

  """
  fetch aggregated fields from the table: "contact_opt_in"
  """
  contactOptInAggregate(
    """distinct select on columns"""
    distinctOn: [ContactOptInSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ContactOptInOrderBy!]

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): ContactOptInAggregate!

  """fetch data from the table: "contact_opt_in" using primary key columns"""
  contactOptInByPk(id: uuid!): ContactOptIn

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(id: uuid!): Course

  """
  fetch data from the table: "course_exercise"
  """
  courseExercise(
    """distinct select on columns"""
    distinctOn: [CourseExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseBoolExp
  ): [CourseExercise!]!

  """
  fetch aggregated fields from the table: "course_exercise"
  """
  courseExerciseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseBoolExp
  ): CourseExerciseAggregate!

  """fetch data from the table: "course_exercise" using primary key columns"""
  courseExerciseByPk(id: uuid!): CourseExercise

  """
  fetch data from the table: "course_exercise_category"
  """
  courseExerciseCategory(
    """distinct select on columns"""
    distinctOn: [CourseExerciseCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseCategoryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): [CourseExerciseCategory!]!

  """
  fetch aggregated fields from the table: "course_exercise_category"
  """
  courseExerciseCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseCategoryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): CourseExerciseCategoryAggregate!

  """
  fetch data from the table: "course_exercise_category" using primary key columns
  """
  courseExerciseCategoryByPk(categoryId: String!, courseExerciseId: uuid!, tenantId: String!): CourseExerciseCategory

  """
  fetch data from the table: "course_exercise_entry"
  """
  courseExerciseEntry(
    """distinct select on columns"""
    distinctOn: [CourseExerciseEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseEntryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): [CourseExerciseEntry!]!

  """
  fetch aggregated fields from the table: "course_exercise_entry"
  """
  courseExerciseEntryAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseEntryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): CourseExerciseEntryAggregate!

  """
  fetch data from the table: "course_exercise_entry" using primary key columns
  """
  courseExerciseEntryByPk(id: uuid!): CourseExerciseEntry

  """
  fetch data from the table: "course_exercise_kind"
  """
  courseExerciseKind(
    """distinct select on columns"""
    distinctOn: [CourseExerciseKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseKindOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseKindBoolExp
  ): [CourseExerciseKind!]!

  """
  fetch aggregated fields from the table: "course_exercise_kind"
  """
  courseExerciseKindAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseKindOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseKindBoolExp
  ): CourseExerciseKindAggregate!

  """
  fetch data from the table: "course_exercise_kind" using primary key columns
  """
  courseExerciseKindByPk(id: String!, tenantId: String!): CourseExerciseKind

  """
  fetch data from the table: "course_exercise_media_item"
  """
  courseExerciseMediaItem(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): [CourseExerciseMediaItem!]!

  """
  fetch aggregated fields from the table: "course_exercise_media_item"
  """
  courseExerciseMediaItemAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): CourseExerciseMediaItemAggregate!

  """
  fetch data from the table: "course_exercise_media_item" using primary key columns
  """
  courseExerciseMediaItemByPk(courseExerciseId: uuid!, mediaItemId: String!): CourseExerciseMediaItem

  """
  fetch data from the table: "course_lesson"
  """
  courseLesson(
    """distinct select on columns"""
    distinctOn: [CourseLessonSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonOrderBy!]

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): [CourseLesson!]!

  """
  fetch aggregated fields from the table: "course_lesson"
  """
  courseLessonAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonOrderBy!]

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): CourseLessonAggregate!

  """fetch data from the table: "course_lesson" using primary key columns"""
  courseLessonByPk(id: uuid!): CourseLesson

  """
  fetch data from the table: "course_lesson_entry"
  """
  courseLessonEntry(
    """distinct select on columns"""
    distinctOn: [CourseLessonEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonEntryOrderBy!]

    """filter the rows returned"""
    where: CourseLessonEntryBoolExp
  ): [CourseLessonEntry!]!

  """
  fetch aggregated fields from the table: "course_lesson_entry"
  """
  courseLessonEntryAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonEntryOrderBy!]

    """filter the rows returned"""
    where: CourseLessonEntryBoolExp
  ): CourseLessonEntryAggregate!

  """
  fetch data from the table: "course_lesson_entry" using primary key columns
  """
  courseLessonEntryByPk(id: uuid!): CourseLessonEntry

  """
  fetch data from the table: "course_lesson_section"
  """
  courseLessonSection(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): [CourseLessonSection!]!

  """
  fetch aggregated fields from the table: "course_lesson_section"
  """
  courseLessonSectionAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): CourseLessonSectionAggregate!

  """
  fetch data from the table: "course_lesson_section" using primary key columns
  """
  courseLessonSectionByPk(id: uuid!): CourseLessonSection

  """
  fetch data from the table: "course_lesson_section_exercise"
  """
  courseLessonSectionExercise(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): [CourseLessonSectionExercise!]!

  """
  fetch aggregated fields from the table: "course_lesson_section_exercise"
  """
  courseLessonSectionExerciseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): CourseLessonSectionExerciseAggregate!

  """
  fetch data from the table: "course_lesson_section_exercise" using primary key columns
  """
  courseLessonSectionExerciseByPk(exerciseId: uuid!, lessonSectionId: uuid!): CourseLessonSectionExercise

  """
  fetch data from the table: "course_lesson_section_exercise_sub"
  """
  courseLessonSectionExerciseSub(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSubSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseSubOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): [CourseLessonSectionExerciseSub!]!

  """
  fetch aggregated fields from the table: "course_lesson_section_exercise_sub"
  """
  courseLessonSectionExerciseSubAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSubSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseSubOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): CourseLessonSectionExerciseSubAggregate!

  """
  fetch data from the table: "course_lesson_section_exercise_sub" using primary key columns
  """
  courseLessonSectionExerciseSubByPk(id: uuid!): CourseLessonSectionExerciseSub

  """
  fetch data from the table: "document"
  """
  document(
    """distinct select on columns"""
    distinctOn: [DocumentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentOrderBy!]

    """filter the rows returned"""
    where: DocumentBoolExp
  ): [Document!]!

  """
  fetch aggregated fields from the table: "document"
  """
  documentAggregate(
    """distinct select on columns"""
    distinctOn: [DocumentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentOrderBy!]

    """filter the rows returned"""
    where: DocumentBoolExp
  ): DocumentAggregate!

  """
  fetch data from the table: "document_block"
  """
  documentBlock(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!

  """
  fetch aggregated fields from the table: "document_block"
  """
  documentBlockAggregate(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): DocumentBlockAggregate!

  """fetch data from the table: "document_block" using primary key columns"""
  documentBlockByPk(id: uuid!): DocumentBlock

  """
  fetch data from the table: "document_block_kind"
  """
  documentBlockKind(
    """distinct select on columns"""
    distinctOn: [DocumentBlockKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockKindOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockKindBoolExp
  ): [DocumentBlockKind!]!

  """
  fetch data from the table: "document_block_kind" using primary key columns
  """
  documentBlockKindByPk(id: String!): DocumentBlockKind

  """fetch data from the table: "document" using primary key columns"""
  documentByPk(id: uuid!): Document

  """
  fetch data from the table: "document_kind"
  """
  documentKind(
    """distinct select on columns"""
    distinctOn: [DocumentKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentKindOrderBy!]

    """filter the rows returned"""
    where: DocumentKindBoolExp
  ): [DocumentKind!]!

  """fetch data from the table: "document_kind" using primary key columns"""
  documentKindByPk(id: String!): DocumentKind

  """
  fetch data from the table: "event"
  """
  event(
    """distinct select on columns"""
    distinctOn: [EventSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventOrderBy!]

    """filter the rows returned"""
    where: EventBoolExp
  ): [Event!]!

  """
  fetch aggregated fields from the table: "event"
  """
  eventAggregate(
    """distinct select on columns"""
    distinctOn: [EventSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventOrderBy!]

    """filter the rows returned"""
    where: EventBoolExp
  ): EventAggregate!

  """
  fetch data from the table: "event_attendee"
  """
  eventAttendee(
    """distinct select on columns"""
    distinctOn: [EventAttendeeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAttendeeOrderBy!]

    """filter the rows returned"""
    where: EventAttendeeBoolExp
  ): [EventAttendee!]!

  """
  fetch aggregated fields from the table: "event_attendee"
  """
  eventAttendeeAggregate(
    """distinct select on columns"""
    distinctOn: [EventAttendeeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAttendeeOrderBy!]

    """filter the rows returned"""
    where: EventAttendeeBoolExp
  ): EventAttendeeAggregate!

  """fetch data from the table: "event_attendee" using primary key columns"""
  eventAttendeeByPk(id: uuid!): EventAttendee

  """
  fetch data from the table: "event_availability"
  """
  eventAvailability(
    """distinct select on columns"""
    distinctOn: [EventAvailabilitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityBoolExp
  ): [EventAvailability!]!

  """
  fetch aggregated fields from the table: "event_availability"
  """
  eventAvailabilityAggregate(
    """distinct select on columns"""
    distinctOn: [EventAvailabilitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityBoolExp
  ): EventAvailabilityAggregate!

  """
  fetch data from the table: "event_availability" using primary key columns
  """
  eventAvailabilityByPk(id: uuid!): EventAvailability

  """
  fetch data from the table: "event_availability_kind"
  """
  eventAvailabilityKind(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityKindOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityKindBoolExp
  ): [EventAvailabilityKind!]!

  """
  fetch data from the table: "event_availability_kind" using primary key columns
  """
  eventAvailabilityKindByPk(id: String!): EventAvailabilityKind

  """
  fetch data from the table: "event_availability_override"
  """
  eventAvailabilityOverride(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityOverrideSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOverrideOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityOverrideBoolExp
  ): [EventAvailabilityOverride!]!

  """
  fetch aggregated fields from the table: "event_availability_override"
  """
  eventAvailabilityOverrideAggregate(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityOverrideSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOverrideOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityOverrideBoolExp
  ): EventAvailabilityOverrideAggregate!

  """
  fetch data from the table: "event_availability_override" using primary key columns
  """
  eventAvailabilityOverrideByPk(id: uuid!): EventAvailabilityOverride

  """fetch data from the table: "event" using primary key columns"""
  eventByPk(id: uuid!): Event

  """
  fetch data from the table: "event_kind"
  """
  eventKind(
    """distinct select on columns"""
    distinctOn: [EventKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventKindOrderBy!]

    """filter the rows returned"""
    where: EventKindBoolExp
  ): [EventKind!]!

  """
  fetch aggregated fields from the table: "event_kind"
  """
  eventKindAggregate(
    """distinct select on columns"""
    distinctOn: [EventKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventKindOrderBy!]

    """filter the rows returned"""
    where: EventKindBoolExp
  ): EventKindAggregate!

  """fetch data from the table: "event_kind" using primary key columns"""
  eventKindByPk(id: String!, tenantId: String!): EventKind

  """
  fetch data from the table: "event_live"
  """
  eventLive(
    """distinct select on columns"""
    distinctOn: [EventLiveSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventLiveOrderBy!]

    """filter the rows returned"""
    where: EventLiveBoolExp
  ): [EventLive!]!

  """
  fetch aggregated fields from the table: "event_live"
  """
  eventLiveAggregate(
    """distinct select on columns"""
    distinctOn: [EventLiveSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventLiveOrderBy!]

    """filter the rows returned"""
    where: EventLiveBoolExp
  ): EventLiveAggregate!

  """fetch data from the table: "event_live" using primary key columns"""
  eventLiveByPk(id: String!): EventLive

  """
  fetch data from the table: "event_recurrence"
  """
  eventRecurrence(
    """distinct select on columns"""
    distinctOn: [EventRecurrenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventRecurrenceOrderBy!]

    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): [EventRecurrence!]!

  """
  fetch aggregated fields from the table: "event_recurrence"
  """
  eventRecurrenceAggregate(
    """distinct select on columns"""
    distinctOn: [EventRecurrenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventRecurrenceOrderBy!]

    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): EventRecurrenceAggregate!

  """
  fetch data from the table: "event_recurrence" using primary key columns
  """
  eventRecurrenceByPk(id: uuid!): EventRecurrence

  """
  fetch data from the table: "event_template"
  """
  eventTemplate(
    """distinct select on columns"""
    distinctOn: [EventTemplateSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateOrderBy!]

    """filter the rows returned"""
    where: EventTemplateBoolExp
  ): [EventTemplate!]!

  """
  fetch aggregated fields from the table: "event_template"
  """
  eventTemplateAggregate(
    """distinct select on columns"""
    distinctOn: [EventTemplateSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateOrderBy!]

    """filter the rows returned"""
    where: EventTemplateBoolExp
  ): EventTemplateAggregate!

  """fetch data from the table: "event_template" using primary key columns"""
  eventTemplateByPk(id: uuid!): EventTemplate

  """
  fetch data from the table: "event_template_tag"
  """
  eventTemplateTag(
    """distinct select on columns"""
    distinctOn: [EventTemplateTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateTagOrderBy!]

    """filter the rows returned"""
    where: EventTemplateTagBoolExp
  ): [EventTemplateTag!]!

  """
  fetch aggregated fields from the table: "event_template_tag"
  """
  eventTemplateTagAggregate(
    """distinct select on columns"""
    distinctOn: [EventTemplateTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateTagOrderBy!]

    """filter the rows returned"""
    where: EventTemplateTagBoolExp
  ): EventTemplateTagAggregate!

  """
  fetch data from the table: "event_template_tag" using primary key columns
  """
  eventTemplateTagByPk(eventTemplateId: uuid!, tag: String!): EventTemplateTag

  """
  fetch data from the table: "event_ticket_option"
  """
  eventTicketOption(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!

  """
  fetch aggregated fields from the table: "event_ticket_option"
  """
  eventTicketOptionAggregate(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): EventTicketOptionAggregate!

  """
  fetch data from the table: "event_ticket_option" using primary key columns
  """
  eventTicketOptionByPk(eventId: uuid!, productId: uuid!, tenantId: String!): EventTicketOption

  """
  fetch data from the table: "game_raffle"
  """
  gameRaffle(
    """distinct select on columns"""
    distinctOn: [GameRaffleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleOrderBy!]

    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): [GameRaffle!]!

  """
  fetch aggregated fields from the table: "game_raffle"
  """
  gameRaffleAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleOrderBy!]

    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): GameRaffleAggregate!

  """fetch data from the table: "game_raffle" using primary key columns"""
  gameRaffleByPk(id: uuid!): GameRaffle

  """
  fetch data from the table: "game_raffle_prize"
  """
  gameRafflePrize(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!

  """
  fetch aggregated fields from the table: "game_raffle_prize"
  """
  gameRafflePrizeAggregate(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): GameRafflePrizeAggregate!

  """
  fetch data from the table: "game_raffle_prize" using primary key columns
  """
  gameRafflePrizeByPk(id: uuid!): GameRafflePrize

  """
  fetch data from the table: "game_raffle_ticket"
  """
  gameRaffleTicket(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): [GameRaffleTicket!]!

  """
  fetch aggregated fields from the table: "game_raffle_ticket"
  """
  gameRaffleTicketAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): GameRaffleTicketAggregate!

  """
  fetch data from the table: "game_raffle_ticket" using primary key columns
  """
  gameRaffleTicketByPk(id: uuid!): GameRaffleTicket

  """
  fetch data from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOption(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!

  """
  fetch aggregated fields from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOptionAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): GameRaffleTicketOptionAggregate!

  """
  fetch data from the table: "game_raffle_ticket_option" using primary key columns
  """
  gameRaffleTicketOptionByPk(id: uuid!): GameRaffleTicketOption

  """
  fetch data from the table: "geo_location"
  """
  geoLocation(
    """distinct select on columns"""
    distinctOn: [GeoLocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GeoLocationOrderBy!]

    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): [GeoLocation!]!

  """
  fetch aggregated fields from the table: "geo_location"
  """
  geoLocationAggregate(
    """distinct select on columns"""
    distinctOn: [GeoLocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GeoLocationOrderBy!]

    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): GeoLocationAggregate!

  """fetch data from the table: "geo_location" using primary key columns"""
  geoLocationByPk(id: uuid!): GeoLocation
  geoPlaceSearch(args: GeoPlaceAutocompleteInput!): GeoPlaceOutput!

  """
  fetch data from the table: "log"
  """
  log(
    """distinct select on columns"""
    distinctOn: [LogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogOrderBy!]

    """filter the rows returned"""
    where: LogBoolExp
  ): [Log!]!

  """
  fetch data from the table: "log_activity"
  """
  logActivity(
    """distinct select on columns"""
    distinctOn: [LogActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogActivityOrderBy!]

    """filter the rows returned"""
    where: LogActivityBoolExp
  ): [LogActivity!]!

  """
  fetch aggregated fields from the table: "log_activity"
  """
  logActivityAggregate(
    """distinct select on columns"""
    distinctOn: [LogActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogActivityOrderBy!]

    """filter the rows returned"""
    where: LogActivityBoolExp
  ): LogActivityAggregate!

  """fetch data from the table: "log_activity" using primary key columns"""
  logActivityByPk(id: uuid!): LogActivity

  """
  fetch aggregated fields from the table: "log"
  """
  logAggregate(
    """distinct select on columns"""
    distinctOn: [LogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogOrderBy!]

    """filter the rows returned"""
    where: LogBoolExp
  ): LogAggregate!

  """
  fetch data from the table: "log_audit"
  """
  logAudit(
    """distinct select on columns"""
    distinctOn: [LogAuditSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogAuditOrderBy!]

    """filter the rows returned"""
    where: LogAuditBoolExp
  ): [LogAudit!]!

  """
  fetch aggregated fields from the table: "log_audit"
  """
  logAuditAggregate(
    """distinct select on columns"""
    distinctOn: [LogAuditSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogAuditOrderBy!]

    """filter the rows returned"""
    where: LogAuditBoolExp
  ): LogAuditAggregate!

  """fetch data from the table: "log_audit" using primary key columns"""
  logAuditByPk(id: uuid!): LogAudit

  """fetch data from the table: "log" using primary key columns"""
  logByPk(id: uuid!): Log

  """
  fetch data from the table: "media_item"
  """
  mediaItem(
    """distinct select on columns"""
    distinctOn: [MediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemOrderBy!]

    """filter the rows returned"""
    where: MediaItemBoolExp
  ): [MediaItem!]!

  """
  fetch aggregated fields from the table: "media_item"
  """
  mediaItemAggregate(
    """distinct select on columns"""
    distinctOn: [MediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemOrderBy!]

    """filter the rows returned"""
    where: MediaItemBoolExp
  ): MediaItemAggregate!

  """fetch data from the table: "media_item" using primary key columns"""
  mediaItemByPk(id: String!): MediaItem

  """
  fetch data from the table: "media_item_tag"
  """
  mediaItemTag(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!

  """
  fetch aggregated fields from the table: "media_item_tag"
  """
  mediaItemTagAggregate(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): MediaItemTagAggregate!

  """fetch data from the table: "media_item_tag" using primary key columns"""
  mediaItemTagByPk(mediaItemId: String!, tag: String!): MediaItemTag

  """
  fetch data from the table: "media_kind"
  """
  mediaKind(
    """distinct select on columns"""
    distinctOn: [MediaKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaKindOrderBy!]

    """filter the rows returned"""
    where: MediaKindBoolExp
  ): [MediaKind!]!

  """fetch data from the table: "media_kind" using primary key columns"""
  mediaKindByPk(id: String!): MediaKind

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notificationAggregate(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): NotificationAggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notificationByPk(id: uuid!): Notification

  """
  fetch data from the table: "nutrition_day"
  """
  nutritionDay(
    """distinct select on columns"""
    distinctOn: [NutritionDaySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionDayOrderBy!]

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): [NutritionDay!]!

  """
  fetch aggregated fields from the table: "nutrition_day"
  """
  nutritionDayAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionDaySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionDayOrderBy!]

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): NutritionDayAggregate!

  """fetch data from the table: "nutrition_day" using primary key columns"""
  nutritionDayByPk(id: uuid!): NutritionDay

  """
  fetch data from the table: "nutrition_food"
  """
  nutritionFood(
    """distinct select on columns"""
    distinctOn: [NutritionFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionFoodBoolExp
  ): [NutritionFood!]!

  """
  fetch aggregated fields from the table: "nutrition_food"
  """
  nutritionFoodAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionFoodBoolExp
  ): NutritionFoodAggregate!

  """fetch data from the table: "nutrition_food" using primary key columns"""
  nutritionFoodByPk(id: uuid!): NutritionFood

  """
  fetch data from the table: "nutrition_meal"
  """
  nutritionMeal(
    """distinct select on columns"""
    distinctOn: [NutritionMealSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealOrderBy!]

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): [NutritionMeal!]!

  """
  fetch aggregated fields from the table: "nutrition_meal"
  """
  nutritionMealAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionMealSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealOrderBy!]

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): NutritionMealAggregate!

  """fetch data from the table: "nutrition_meal" using primary key columns"""
  nutritionMealByPk(id: uuid!): NutritionMeal

  """
  fetch data from the table: "nutrition_meal_food"
  """
  nutritionMealFood(
    """distinct select on columns"""
    distinctOn: [NutritionMealFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): [NutritionMealFood!]!

  """
  fetch aggregated fields from the table: "nutrition_meal_food"
  """
  nutritionMealFoodAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionMealFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): NutritionMealFoodAggregate!

  """
  fetch data from the table: "nutrition_meal_food" using primary key columns
  """
  nutritionMealFoodByPk(foodId: uuid!, mealId: uuid!): NutritionMealFood

  """
  fetch data from the table: "nutrition_plan"
  """
  nutritionPlan(
    """distinct select on columns"""
    distinctOn: [NutritionPlanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionPlanOrderBy!]

    """filter the rows returned"""
    where: NutritionPlanBoolExp
  ): [NutritionPlan!]!

  """
  fetch aggregated fields from the table: "nutrition_plan"
  """
  nutritionPlanAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionPlanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionPlanOrderBy!]

    """filter the rows returned"""
    where: NutritionPlanBoolExp
  ): NutritionPlanAggregate!

  """fetch data from the table: "nutrition_plan" using primary key columns"""
  nutritionPlanByPk(id: uuid!): NutritionPlan

  """
  fetch data from the table: "post"
  """
  post(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): [Post!]!

  """
  fetch aggregated fields from the table: "post"
  """
  postAggregate(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): PostAggregate!

  """fetch data from the table: "post" using primary key columns"""
  postByPk(id: uuid!): Post

  """
  fetch data from the table: "post_comment"
  """
  postComment(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): [PostComment!]!

  """
  fetch aggregated fields from the table: "post_comment"
  """
  postCommentAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): PostCommentAggregate!

  """fetch data from the table: "post_comment" using primary key columns"""
  postCommentByPk(id: uuid!): PostComment

  """
  fetch data from the table: "post_comment_reaction"
  """
  postCommentReaction(
    """distinct select on columns"""
    distinctOn: [PostCommentReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentReactionOrderBy!]

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): [PostCommentReaction!]!

  """
  fetch aggregated fields from the table: "post_comment_reaction"
  """
  postCommentReactionAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentReactionOrderBy!]

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): PostCommentReactionAggregate!

  """
  fetch data from the table: "post_comment_reaction" using primary key columns
  """
  postCommentReactionByPk(commentId: uuid!, profileId: uuid!): PostCommentReaction

  """
  fetch data from the table: "post_kind"
  """
  postKind(
    """distinct select on columns"""
    distinctOn: [PostKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostKindOrderBy!]

    """filter the rows returned"""
    where: PostKindBoolExp
  ): [PostKind!]!

  """
  fetch aggregated fields from the table: "post_kind"
  """
  postKindAggregate(
    """distinct select on columns"""
    distinctOn: [PostKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostKindOrderBy!]

    """filter the rows returned"""
    where: PostKindBoolExp
  ): PostKindAggregate!

  """fetch data from the table: "post_kind" using primary key columns"""
  postKindByPk(id: String!, tenantId: String!): PostKind

  """
  fetch data from the table: "post_media_item"
  """
  postMediaItem(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): [PostMediaItem!]!

  """
  fetch aggregated fields from the table: "post_media_item"
  """
  postMediaItemAggregate(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): PostMediaItemAggregate!

  """fetch data from the table: "post_media_item" using primary key columns"""
  postMediaItemByPk(id: uuid!): PostMediaItem

  """
  fetch data from the table: "post_reaction"
  """
  postReaction(
    """distinct select on columns"""
    distinctOn: [PostReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionOrderBy!]

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): [PostReaction!]!

  """
  fetch aggregated fields from the table: "post_reaction"
  """
  postReactionAggregate(
    """distinct select on columns"""
    distinctOn: [PostReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionOrderBy!]

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): PostReactionAggregate!

  """fetch data from the table: "post_reaction" using primary key columns"""
  postReactionByPk(kind: String!, postId: uuid!, profileId: uuid!): PostReaction

  """
  fetch data from the table: "post_reaction_kind"
  """
  postReactionKind(
    """distinct select on columns"""
    distinctOn: [PostReactionKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionKindOrderBy!]

    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): [PostReactionKind!]!

  """
  fetch aggregated fields from the table: "post_reaction_kind"
  """
  postReactionKindAggregate(
    """distinct select on columns"""
    distinctOn: [PostReactionKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionKindOrderBy!]

    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): PostReactionKindAggregate!

  """
  fetch data from the table: "post_reaction_kind" using primary key columns
  """
  postReactionKindByPk(id: String!, tenantId: String!): PostReactionKind

  """
  fetch data from the table: "post_tag"
  """
  postTag(
    """distinct select on columns"""
    distinctOn: [PostTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostTagOrderBy!]

    """filter the rows returned"""
    where: PostTagBoolExp
  ): [PostTag!]!

  """
  fetch aggregated fields from the table: "post_tag"
  """
  postTagAggregate(
    """distinct select on columns"""
    distinctOn: [PostTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostTagOrderBy!]

    """filter the rows returned"""
    where: PostTagBoolExp
  ): PostTagAggregate!

  """fetch data from the table: "post_tag" using primary key columns"""
  postTagByPk(postId: uuid!, tag: String!): PostTag

  """
  fetch data from the table: "profile"
  """
  profile(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]

    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!

  """
  fetch aggregated fields from the table: "profile"
  """
  profileAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]

    """filter the rows returned"""
    where: ProfileBoolExp
  ): ProfileAggregate!

  """
  fetch data from the table: "profile_attribute"
  """
  profileAttribute(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!

  """
  fetch aggregated fields from the table: "profile_attribute"
  """
  profileAttributeAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): ProfileAttributeAggregate!

  """
  fetch data from the table: "profile_attribute" using primary key columns
  """
  profileAttributeByPk(id: String!, profileId: uuid!): ProfileAttribute

  """
  fetch data from the table: "profile_attribute_kind"
  """
  profileAttributeKind(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeKindOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeKindBoolExp
  ): [ProfileAttributeKind!]!

  """
  fetch aggregated fields from the table: "profile_attribute_kind"
  """
  profileAttributeKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeKindOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeKindBoolExp
  ): ProfileAttributeKindAggregate!

  """
  fetch data from the table: "profile_attribute_kind" using primary key columns
  """
  profileAttributeKindByPk(id: String!, tenantId: String!): ProfileAttributeKind

  """
  fetch data from the table: "profile_attribute_option"
  """
  profileAttributeOption(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOptionOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeOptionBoolExp
  ): [ProfileAttributeOption!]!

  """
  fetch aggregated fields from the table: "profile_attribute_option"
  """
  profileAttributeOptionAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOptionOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeOptionBoolExp
  ): ProfileAttributeOptionAggregate!

  """
  fetch data from the table: "profile_attribute_option" using primary key columns
  """
  profileAttributeOptionByPk(id: String!, tenantId: String!): ProfileAttributeOption

  """fetch data from the table: "profile" using primary key columns"""
  profileByPk(id: uuid!): Profile
  profileCheckUsername(args: ProfileCheckUsernameInput!): ProfileCheckUsernameOutput

  """
  fetch data from the table: "profile_device"
  """
  profileDevice(
    """distinct select on columns"""
    distinctOn: [ProfileDeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileDeviceOrderBy!]

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): [ProfileDevice!]!

  """
  fetch aggregated fields from the table: "profile_device"
  """
  profileDeviceAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileDeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileDeviceOrderBy!]

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): ProfileDeviceAggregate!

  """fetch data from the table: "profile_device" using primary key columns"""
  profileDeviceByPk(
    """unique push token"""
    id: String!
  ): ProfileDevice

  """
  fetch data from the table: "profile_follower"
  """
  profileFollower(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!

  """
  fetch aggregated fields from the table: "profile_follower"
  """
  profileFollowerAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!

  """
  fetch data from the table: "profile_follower" using primary key columns
  """
  profileFollowerByPk(followedProfileId: uuid!, followerId: uuid!): ProfileFollower

  """
  fetch data from the table: "profile_health_configuration"
  """
  profileHealthConfiguration(
    """distinct select on columns"""
    distinctOn: [ProfileHealthConfigurationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileHealthConfigurationOrderBy!]

    """filter the rows returned"""
    where: ProfileHealthConfigurationBoolExp
  ): [ProfileHealthConfiguration!]!

  """
  fetch aggregated fields from the table: "profile_health_configuration"
  """
  profileHealthConfigurationAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileHealthConfigurationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileHealthConfigurationOrderBy!]

    """filter the rows returned"""
    where: ProfileHealthConfigurationBoolExp
  ): ProfileHealthConfigurationAggregate!

  """
  fetch data from the table: "profile_health_configuration" using primary key columns
  """
  profileHealthConfigurationByPk(id: uuid!): ProfileHealthConfiguration

  """
  fetch data from the table: "profile_identity"
  """
  profileIdentity(
    """distinct select on columns"""
    distinctOn: [ProfileIdentitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileIdentityOrderBy!]

    """filter the rows returned"""
    where: ProfileIdentityBoolExp
  ): [ProfileIdentity!]!

  """
  fetch aggregated fields from the table: "profile_identity"
  """
  profileIdentityAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileIdentitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileIdentityOrderBy!]

    """filter the rows returned"""
    where: ProfileIdentityBoolExp
  ): ProfileIdentityAggregate!

  """
  fetch data from the table: "profile_identity" using primary key columns
  """
  profileIdentityByPk(id: uuid!): ProfileIdentity

  """
  fetch data from the table: "profile_kind"
  """
  profileKind(
    """distinct select on columns"""
    distinctOn: [ProfileKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileKindOrderBy!]

    """filter the rows returned"""
    where: ProfileKindBoolExp
  ): [ProfileKind!]!

  """
  fetch aggregated fields from the table: "profile_kind"
  """
  profileKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileKindOrderBy!]

    """filter the rows returned"""
    where: ProfileKindBoolExp
  ): ProfileKindAggregate!

  """fetch data from the table: "profile_kind" using primary key columns"""
  profileKindByPk(
    """anonymous_user, user, service_provider, artist, community, etc."""
    id: String!
    tenantId: String!
  ): ProfileKind

  """
  fetch data from the table: "profile_manager"
  """
  profileManager(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): [ProfileManager!]!

  """
  fetch aggregated fields from the table: "profile_manager"
  """
  profileManagerAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): ProfileManagerAggregate!

  """fetch data from the table: "profile_manager" using primary key columns"""
  profileManagerByPk(managedProfileId: uuid!, managerId: uuid!): ProfileManager

  """
  fetch data from the table: "profile_manager_kind"
  """
  profileManagerKind(
    """distinct select on columns"""
    distinctOn: [ProfileManagerKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerKindOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerKindBoolExp
  ): [ProfileManagerKind!]!

  """
  fetch aggregated fields from the table: "profile_manager_kind"
  """
  profileManagerKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileManagerKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerKindOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerKindBoolExp
  ): ProfileManagerKindAggregate!

  """
  fetch data from the table: "profile_manager_kind" using primary key columns
  """
  profileManagerKindByPk(
    """owner, manager, etc."""
    id: String!
    tenantId: String!
  ): ProfileManagerKind

  """
  fetch data from the table: "profile_stat"
  """
  profileStat(
    """distinct select on columns"""
    distinctOn: [ProfileStatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatOrderBy!]

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): [ProfileStat!]!

  """
  fetch aggregated fields from the table: "profile_stat"
  """
  profileStatAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileStatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatOrderBy!]

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): ProfileStatAggregate!

  """fetch data from the table: "profile_stat" using primary key columns"""
  profileStatByPk(id: uuid!): ProfileStat

  """
  fetch data from the table: "profile_stat_kind"
  """
  profileStatKind(
    """distinct select on columns"""
    distinctOn: [ProfileStatKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatKindOrderBy!]

    """filter the rows returned"""
    where: ProfileStatKindBoolExp
  ): [ProfileStatKind!]!

  """
  fetch aggregated fields from the table: "profile_stat_kind"
  """
  profileStatKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileStatKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatKindOrderBy!]

    """filter the rows returned"""
    where: ProfileStatKindBoolExp
  ): ProfileStatKindAggregate!

  """
  fetch data from the table: "profile_stat_kind" using primary key columns
  """
  profileStatKindByPk(id: String!, tenantId: String!): ProfileStatKind

  """
  fetch data from the table: "question"
  """
  question(
    """distinct select on columns"""
    distinctOn: [QuestionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOrderBy!]

    """filter the rows returned"""
    where: QuestionBoolExp
  ): [Question!]!

  """
  fetch aggregated fields from the table: "question"
  """
  questionAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOrderBy!]

    """filter the rows returned"""
    where: QuestionBoolExp
  ): QuestionAggregate!

  """fetch data from the table: "question" using primary key columns"""
  questionByPk(id: uuid!): Question

  """
  fetch data from the table: "question_kind"
  """
  questionKind(
    """distinct select on columns"""
    distinctOn: [QuestionKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionKindOrderBy!]

    """filter the rows returned"""
    where: QuestionKindBoolExp
  ): [QuestionKind!]!

  """fetch data from the table: "question_kind" using primary key columns"""
  questionKindByPk(id: String!): QuestionKind

  """
  fetch data from the table: "question_option"
  """
  questionOption(
    """distinct select on columns"""
    distinctOn: [QuestionOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOptionOrderBy!]

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): [QuestionOption!]!

  """
  fetch aggregated fields from the table: "question_option"
  """
  questionOptionAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOptionOrderBy!]

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): QuestionOptionAggregate!

  """fetch data from the table: "question_option" using primary key columns"""
  questionOptionByPk(id: uuid!): QuestionOption

  """
  fetch data from the table: "question_response"
  """
  questionResponse(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): [QuestionResponse!]!

  """
  fetch aggregated fields from the table: "question_response"
  """
  questionResponseAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): QuestionResponseAggregate!

  """
  fetch data from the table: "question_response" using primary key columns
  """
  questionResponseByPk(id: uuid!): QuestionResponse

  """
  fetch data from the table: "question_set"
  """
  questionSet(
    """distinct select on columns"""
    distinctOn: [QuestionSetSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionSetOrderBy!]

    """filter the rows returned"""
    where: QuestionSetBoolExp
  ): [QuestionSet!]!

  """
  fetch aggregated fields from the table: "question_set"
  """
  questionSetAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionSetSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionSetOrderBy!]

    """filter the rows returned"""
    where: QuestionSetBoolExp
  ): QuestionSetAggregate!

  """fetch data from the table: "question_set" using primary key columns"""
  questionSetByPk(id: uuid!): QuestionSet

  """
  fetch data from the table: "shop_order"
  """
  shopOrder(
    """distinct select on columns"""
    distinctOn: [ShopOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderOrderBy!]

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): [ShopOrder!]!

  """
  fetch aggregated fields from the table: "shop_order"
  """
  shopOrderAggregate(
    """distinct select on columns"""
    distinctOn: [ShopOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderOrderBy!]

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): ShopOrderAggregate!

  """fetch data from the table: "shop_order" using primary key columns"""
  shopOrderByPk(id: uuid!): ShopOrder

  """
  fetch data from the table: "shop_order_item"
  """
  shopOrderItem(
    """distinct select on columns"""
    distinctOn: [ShopOrderItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderItemOrderBy!]

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): [ShopOrderItem!]!

  """
  fetch aggregated fields from the table: "shop_order_item"
  """
  shopOrderItemAggregate(
    """distinct select on columns"""
    distinctOn: [ShopOrderItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderItemOrderBy!]

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): ShopOrderItemAggregate!

  """fetch data from the table: "shop_order_item" using primary key columns"""
  shopOrderItemByPk(id: uuid!): ShopOrderItem

  """
  fetch data from the table: "shop_product"
  """
  shopProduct(
    """distinct select on columns"""
    distinctOn: [ShopProductSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductOrderBy!]

    """filter the rows returned"""
    where: ShopProductBoolExp
  ): [ShopProduct!]!

  """
  fetch aggregated fields from the table: "shop_product"
  """
  shopProductAggregate(
    """distinct select on columns"""
    distinctOn: [ShopProductSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductOrderBy!]

    """filter the rows returned"""
    where: ShopProductBoolExp
  ): ShopProductAggregate!

  """fetch data from the table: "shop_product" using primary key columns"""
  shopProductByPk(id: uuid!): ShopProduct

  """
  fetch data from the table: "shop_product_kind"
  """
  shopProductKind(
    """distinct select on columns"""
    distinctOn: [ShopProductKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductKindOrderBy!]

    """filter the rows returned"""
    where: ShopProductKindBoolExp
  ): [ShopProductKind!]!

  """
  fetch data from the table: "shop_product_kind" using primary key columns
  """
  shopProductKindByPk(id: String!): ShopProductKind

  """
  fetch data from the table: "shop_product_price"
  """
  shopProductPrice(
    """distinct select on columns"""
    distinctOn: [ShopProductPriceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductPriceOrderBy!]

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): [ShopProductPrice!]!

  """
  fetch aggregated fields from the table: "shop_product_price"
  """
  shopProductPriceAggregate(
    """distinct select on columns"""
    distinctOn: [ShopProductPriceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductPriceOrderBy!]

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): ShopProductPriceAggregate!

  """
  fetch data from the table: "shop_product_price" using primary key columns
  """
  shopProductPriceByPk(id: uuid!): ShopProductPrice
  shopStripePortalSession(args: ShopStripePortalSessionInput!): ShopStripePortalSessionOutput!

  """
  fetch data from the table: "shop_subscription"
  """
  shopSubscription(
    """distinct select on columns"""
    distinctOn: [ShopSubscriptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopSubscriptionOrderBy!]

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): [ShopSubscription!]!

  """
  fetch aggregated fields from the table: "shop_subscription"
  """
  shopSubscriptionAggregate(
    """distinct select on columns"""
    distinctOn: [ShopSubscriptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopSubscriptionOrderBy!]

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): ShopSubscriptionAggregate!

  """
  fetch data from the table: "shop_subscription" using primary key columns
  """
  shopSubscriptionByPk(id: uuid!): ShopSubscription

  """
  fetch data from the table: "tenant"
  """
  tenant(
    """distinct select on columns"""
    distinctOn: [TenantSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantOrderBy!]

    """filter the rows returned"""
    where: TenantBoolExp
  ): [Tenant!]!

  """
  fetch data from the table: "tenant_app"
  """
  tenantApp(
    """distinct select on columns"""
    distinctOn: [TenantAppSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppOrderBy!]

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): [TenantApp!]!

  """
  fetch aggregated fields from the table: "tenant_app"
  """
  tenantAppAggregate(
    """distinct select on columns"""
    distinctOn: [TenantAppSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppOrderBy!]

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): TenantAppAggregate!

  """fetch data from the table: "tenant_app" using primary key columns"""
  tenantAppByPk(id: String!, tenantId: String!): TenantApp

  """
  fetch data from the table: "tenant_app_release"
  """
  tenantAppRelease(
    """distinct select on columns"""
    distinctOn: [TenantAppReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppReleaseOrderBy!]

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): [TenantAppRelease!]!

  """
  fetch aggregated fields from the table: "tenant_app_release"
  """
  tenantAppReleaseAggregate(
    """distinct select on columns"""
    distinctOn: [TenantAppReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppReleaseOrderBy!]

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): TenantAppReleaseAggregate!

  """
  fetch data from the table: "tenant_app_release" using primary key columns
  """
  tenantAppReleaseByPk(id: uuid!): TenantAppRelease

  """fetch data from the table: "tenant" using primary key columns"""
  tenantByPk(
    """url friendly version of name"""
    id: String!
  ): Tenant

  """
  fetch data from the table: "value_kind"
  """
  valueKind(
    """distinct select on columns"""
    distinctOn: [ValueKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValueKindOrderBy!]

    """filter the rows returned"""
    where: ValueKindBoolExp
  ): [ValueKind!]!

  """fetch data from the table: "value_kind" using primary key columns"""
  valueKindByPk(id: String!): ValueKind

  """
  fetch data from the table: "visibility_kind"
  """
  visibilityKind(
    """distinct select on columns"""
    distinctOn: [VisibilityKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VisibilityKindOrderBy!]

    """filter the rows returned"""
    where: VisibilityKindBoolExp
  ): [VisibilityKind!]!

  """fetch data from the table: "visibility_kind" using primary key columns"""
  visibilityKindByPk(id: String!): VisibilityKind
}

input questionAggregateBoolExpCount {
  arguments: [QuestionSelectColumn!]
  distinct: Boolean
  filter: QuestionBoolExp
  predicate: IntComparisonExp!
}

input questionOptionAggregateBoolExpBool_and {
  arguments: QuestionOptionSelectColumnQuestionOptionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: QuestionOptionBoolExp
  predicate: BooleanComparisonExp!
}

input questionOptionAggregateBoolExpBool_or {
  arguments: QuestionOptionSelectColumnQuestionOptionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: QuestionOptionBoolExp
  predicate: BooleanComparisonExp!
}

input questionOptionAggregateBoolExpCount {
  arguments: [QuestionOptionSelectColumn!]
  distinct: Boolean
  filter: QuestionOptionBoolExp
  predicate: IntComparisonExp!
}

input questionResponseAggregateBoolExpCount {
  arguments: [QuestionResponseSelectColumn!]
  distinct: Boolean
  filter: QuestionResponseBoolExp
  predicate: IntComparisonExp!
}

input shopOrderAggregateBoolExpCount {
  arguments: [ShopOrderSelectColumn!]
  distinct: Boolean
  filter: ShopOrderBoolExp
  predicate: IntComparisonExp!
}

input shopOrderItemAggregateBoolExpCount {
  arguments: [ShopOrderItemSelectColumn!]
  distinct: Boolean
  filter: ShopOrderItemBoolExp
  predicate: IntComparisonExp!
}

input shopProductPriceAggregateBoolExpCount {
  arguments: [ShopProductPriceSelectColumn!]
  distinct: Boolean
  filter: ShopProductPriceBoolExp
  predicate: IntComparisonExp!
}

input shopSubscriptionAggregateBoolExpCount {
  arguments: [ShopSubscriptionSelectColumn!]
  distinct: Boolean
  filter: ShopSubscriptionBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "auth_account"
  """
  authAccount(
    """distinct select on columns"""
    distinctOn: [AuthAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthAccountOrderBy!]

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): [AuthAccount!]!

  """
  fetch aggregated fields from the table: "auth_account"
  """
  authAccountAggregate(
    """distinct select on columns"""
    distinctOn: [AuthAccountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthAccountOrderBy!]

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): AuthAccountAggregate!

  """fetch data from the table: "auth_account" using primary key columns"""
  authAccountByPk(id: uuid!): AuthAccount

  """
  fetch data from the table in a streaming manner: "auth_account"
  """
  authAccountStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuthAccountStreamCursorInput]!

    """filter the rows returned"""
    where: AuthAccountBoolExp
  ): [AuthAccount!]!

  """
  fetch data from the table: "auth_provider"
  """
  authProvider(
    """distinct select on columns"""
    distinctOn: [AuthProviderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthProviderOrderBy!]

    """filter the rows returned"""
    where: AuthProviderBoolExp
  ): [AuthProvider!]!

  """
  fetch aggregated fields from the table: "auth_provider"
  """
  authProviderAggregate(
    """distinct select on columns"""
    distinctOn: [AuthProviderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthProviderOrderBy!]

    """filter the rows returned"""
    where: AuthProviderBoolExp
  ): AuthProviderAggregate!

  """fetch data from the table: "auth_provider" using primary key columns"""
  authProviderByPk(id: String!, tenantId: String!): AuthProvider

  """
  fetch data from the table in a streaming manner: "auth_provider"
  """
  authProviderStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuthProviderStreamCursorInput]!

    """filter the rows returned"""
    where: AuthProviderBoolExp
  ): [AuthProvider!]!

  """
  fetch data from the table: "auth_role_kind"
  """
  authRoleKind(
    """distinct select on columns"""
    distinctOn: [AuthRoleKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthRoleKindOrderBy!]

    """filter the rows returned"""
    where: AuthRoleKindBoolExp
  ): [AuthRoleKind!]!

  """fetch data from the table: "auth_role_kind" using primary key columns"""
  authRoleKindByPk(id: String!): AuthRoleKind

  """
  fetch data from the table in a streaming manner: "auth_role_kind"
  """
  authRoleKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuthRoleKindStreamCursorInput]!

    """filter the rows returned"""
    where: AuthRoleKindBoolExp
  ): [AuthRoleKind!]!

  """
  fetch data from the table: "auth_session"
  """
  authSession(
    """distinct select on columns"""
    distinctOn: [AuthSessionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthSessionOrderBy!]

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): [AuthSession!]!

  """
  fetch aggregated fields from the table: "auth_session"
  """
  authSessionAggregate(
    """distinct select on columns"""
    distinctOn: [AuthSessionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthSessionOrderBy!]

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): AuthSessionAggregate!

  """fetch data from the table: "auth_session" using primary key columns"""
  authSessionByPk(id: uuid!): AuthSession

  """
  fetch data from the table in a streaming manner: "auth_session"
  """
  authSessionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuthSessionStreamCursorInput]!

    """filter the rows returned"""
    where: AuthSessionBoolExp
  ): [AuthSession!]!

  """
  fetch data from the table: "auth_user"
  """
  authUser(
    """distinct select on columns"""
    distinctOn: [AuthUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthUserOrderBy!]

    """filter the rows returned"""
    where: AuthUserBoolExp
  ): [AuthUser!]!

  """
  fetch aggregated fields from the table: "auth_user"
  """
  authUserAggregate(
    """distinct select on columns"""
    distinctOn: [AuthUserSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [AuthUserOrderBy!]

    """filter the rows returned"""
    where: AuthUserBoolExp
  ): AuthUserAggregate!

  """fetch data from the table: "auth_user" using primary key columns"""
  authUserByPk(id: uuid!): AuthUser

  """
  fetch data from the table in a streaming manner: "auth_user"
  """
  authUserStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AuthUserStreamCursorInput]!

    """filter the rows returned"""
    where: AuthUserBoolExp
  ): [AuthUser!]!

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  categoryAggregate(
    """distinct select on columns"""
    distinctOn: [CategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryOrderBy!]

    """filter the rows returned"""
    where: CategoryBoolExp
  ): CategoryAggregate!

  """fetch data from the table: "category" using primary key columns"""
  categoryByPk(id: String!, tenantId: String!): Category

  """
  fetch data from the table: "category_kind"
  """
  categoryKind(
    """distinct select on columns"""
    distinctOn: [CategoryKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryKindOrderBy!]

    """filter the rows returned"""
    where: CategoryKindBoolExp
  ): [CategoryKind!]!

  """
  fetch aggregated fields from the table: "category_kind"
  """
  categoryKindAggregate(
    """distinct select on columns"""
    distinctOn: [CategoryKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CategoryKindOrderBy!]

    """filter the rows returned"""
    where: CategoryKindBoolExp
  ): CategoryKindAggregate!

  """fetch data from the table: "category_kind" using primary key columns"""
  categoryKindByPk(id: String!, tenantId: String!): CategoryKind

  """
  fetch data from the table in a streaming manner: "category_kind"
  """
  categoryKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryKindStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryKindBoolExp
  ): [CategoryKind!]!

  """
  fetch data from the table in a streaming manner: "category"
  """
  categoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CategoryStreamCursorInput]!

    """filter the rows returned"""
    where: CategoryBoolExp
  ): [Category!]!

  """
  fetch data from the table: "contact_opt_in"
  """
  contactOptIn(
    """distinct select on columns"""
    distinctOn: [ContactOptInSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ContactOptInOrderBy!]

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): [ContactOptIn!]!

  """
  fetch aggregated fields from the table: "contact_opt_in"
  """
  contactOptInAggregate(
    """distinct select on columns"""
    distinctOn: [ContactOptInSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ContactOptInOrderBy!]

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): ContactOptInAggregate!

  """fetch data from the table: "contact_opt_in" using primary key columns"""
  contactOptInByPk(id: uuid!): ContactOptIn

  """
  fetch data from the table in a streaming manner: "contact_opt_in"
  """
  contactOptInStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ContactOptInStreamCursorInput]!

    """filter the rows returned"""
    where: ContactOptInBoolExp
  ): [ContactOptIn!]!

  """
  fetch data from the table: "course"
  """
  course(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch aggregated fields from the table: "course"
  """
  courseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseOrderBy!]

    """filter the rows returned"""
    where: CourseBoolExp
  ): CourseAggregate!

  """fetch data from the table: "course" using primary key columns"""
  courseByPk(id: uuid!): Course

  """
  fetch data from the table: "course_exercise"
  """
  courseExercise(
    """distinct select on columns"""
    distinctOn: [CourseExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseBoolExp
  ): [CourseExercise!]!

  """
  fetch aggregated fields from the table: "course_exercise"
  """
  courseExerciseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseBoolExp
  ): CourseExerciseAggregate!

  """fetch data from the table: "course_exercise" using primary key columns"""
  courseExerciseByPk(id: uuid!): CourseExercise

  """
  fetch data from the table: "course_exercise_category"
  """
  courseExerciseCategory(
    """distinct select on columns"""
    distinctOn: [CourseExerciseCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseCategoryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): [CourseExerciseCategory!]!

  """
  fetch aggregated fields from the table: "course_exercise_category"
  """
  courseExerciseCategoryAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseCategorySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseCategoryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): CourseExerciseCategoryAggregate!

  """
  fetch data from the table: "course_exercise_category" using primary key columns
  """
  courseExerciseCategoryByPk(categoryId: String!, courseExerciseId: uuid!, tenantId: String!): CourseExerciseCategory

  """
  fetch data from the table in a streaming manner: "course_exercise_category"
  """
  courseExerciseCategoryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseExerciseCategoryStreamCursorInput]!

    """filter the rows returned"""
    where: CourseExerciseCategoryBoolExp
  ): [CourseExerciseCategory!]!

  """
  fetch data from the table: "course_exercise_entry"
  """
  courseExerciseEntry(
    """distinct select on columns"""
    distinctOn: [CourseExerciseEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseEntryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): [CourseExerciseEntry!]!

  """
  fetch aggregated fields from the table: "course_exercise_entry"
  """
  courseExerciseEntryAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseEntryOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): CourseExerciseEntryAggregate!

  """
  fetch data from the table: "course_exercise_entry" using primary key columns
  """
  courseExerciseEntryByPk(id: uuid!): CourseExerciseEntry

  """
  fetch data from the table in a streaming manner: "course_exercise_entry"
  """
  courseExerciseEntryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseExerciseEntryStreamCursorInput]!

    """filter the rows returned"""
    where: CourseExerciseEntryBoolExp
  ): [CourseExerciseEntry!]!

  """
  fetch data from the table: "course_exercise_kind"
  """
  courseExerciseKind(
    """distinct select on columns"""
    distinctOn: [CourseExerciseKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseKindOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseKindBoolExp
  ): [CourseExerciseKind!]!

  """
  fetch aggregated fields from the table: "course_exercise_kind"
  """
  courseExerciseKindAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseKindOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseKindBoolExp
  ): CourseExerciseKindAggregate!

  """
  fetch data from the table: "course_exercise_kind" using primary key columns
  """
  courseExerciseKindByPk(id: String!, tenantId: String!): CourseExerciseKind

  """
  fetch data from the table in a streaming manner: "course_exercise_kind"
  """
  courseExerciseKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseExerciseKindStreamCursorInput]!

    """filter the rows returned"""
    where: CourseExerciseKindBoolExp
  ): [CourseExerciseKind!]!

  """
  fetch data from the table: "course_exercise_media_item"
  """
  courseExerciseMediaItem(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): [CourseExerciseMediaItem!]!

  """
  fetch aggregated fields from the table: "course_exercise_media_item"
  """
  courseExerciseMediaItemAggregate(
    """distinct select on columns"""
    distinctOn: [CourseExerciseMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseExerciseMediaItemOrderBy!]

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): CourseExerciseMediaItemAggregate!

  """
  fetch data from the table: "course_exercise_media_item" using primary key columns
  """
  courseExerciseMediaItemByPk(courseExerciseId: uuid!, mediaItemId: String!): CourseExerciseMediaItem

  """
  fetch data from the table in a streaming manner: "course_exercise_media_item"
  """
  courseExerciseMediaItemStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseExerciseMediaItemStreamCursorInput]!

    """filter the rows returned"""
    where: CourseExerciseMediaItemBoolExp
  ): [CourseExerciseMediaItem!]!

  """
  fetch data from the table in a streaming manner: "course_exercise"
  """
  courseExerciseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseExerciseStreamCursorInput]!

    """filter the rows returned"""
    where: CourseExerciseBoolExp
  ): [CourseExercise!]!

  """
  fetch data from the table: "course_lesson"
  """
  courseLesson(
    """distinct select on columns"""
    distinctOn: [CourseLessonSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonOrderBy!]

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): [CourseLesson!]!

  """
  fetch aggregated fields from the table: "course_lesson"
  """
  courseLessonAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonOrderBy!]

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): CourseLessonAggregate!

  """fetch data from the table: "course_lesson" using primary key columns"""
  courseLessonByPk(id: uuid!): CourseLesson

  """
  fetch data from the table: "course_lesson_entry"
  """
  courseLessonEntry(
    """distinct select on columns"""
    distinctOn: [CourseLessonEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonEntryOrderBy!]

    """filter the rows returned"""
    where: CourseLessonEntryBoolExp
  ): [CourseLessonEntry!]!

  """
  fetch aggregated fields from the table: "course_lesson_entry"
  """
  courseLessonEntryAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonEntrySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonEntryOrderBy!]

    """filter the rows returned"""
    where: CourseLessonEntryBoolExp
  ): CourseLessonEntryAggregate!

  """
  fetch data from the table: "course_lesson_entry" using primary key columns
  """
  courseLessonEntryByPk(id: uuid!): CourseLessonEntry

  """
  fetch data from the table in a streaming manner: "course_lesson_entry"
  """
  courseLessonEntryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseLessonEntryStreamCursorInput]!

    """filter the rows returned"""
    where: CourseLessonEntryBoolExp
  ): [CourseLessonEntry!]!

  """
  fetch data from the table: "course_lesson_section"
  """
  courseLessonSection(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): [CourseLessonSection!]!

  """
  fetch aggregated fields from the table: "course_lesson_section"
  """
  courseLessonSectionAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): CourseLessonSectionAggregate!

  """
  fetch data from the table: "course_lesson_section" using primary key columns
  """
  courseLessonSectionByPk(id: uuid!): CourseLessonSection

  """
  fetch data from the table: "course_lesson_section_exercise"
  """
  courseLessonSectionExercise(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): [CourseLessonSectionExercise!]!

  """
  fetch aggregated fields from the table: "course_lesson_section_exercise"
  """
  courseLessonSectionExerciseAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): CourseLessonSectionExerciseAggregate!

  """
  fetch data from the table: "course_lesson_section_exercise" using primary key columns
  """
  courseLessonSectionExerciseByPk(exerciseId: uuid!, lessonSectionId: uuid!): CourseLessonSectionExercise

  """
  fetch data from the table in a streaming manner: "course_lesson_section_exercise"
  """
  courseLessonSectionExerciseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseLessonSectionExerciseStreamCursorInput]!

    """filter the rows returned"""
    where: CourseLessonSectionExerciseBoolExp
  ): [CourseLessonSectionExercise!]!

  """
  fetch data from the table: "course_lesson_section_exercise_sub"
  """
  courseLessonSectionExerciseSub(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSubSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseSubOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): [CourseLessonSectionExerciseSub!]!

  """
  fetch aggregated fields from the table: "course_lesson_section_exercise_sub"
  """
  courseLessonSectionExerciseSubAggregate(
    """distinct select on columns"""
    distinctOn: [CourseLessonSectionExerciseSubSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CourseLessonSectionExerciseSubOrderBy!]

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): CourseLessonSectionExerciseSubAggregate!

  """
  fetch data from the table: "course_lesson_section_exercise_sub" using primary key columns
  """
  courseLessonSectionExerciseSubByPk(id: uuid!): CourseLessonSectionExerciseSub

  """
  fetch data from the table in a streaming manner: "course_lesson_section_exercise_sub"
  """
  courseLessonSectionExerciseSubStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseLessonSectionExerciseSubStreamCursorInput]!

    """filter the rows returned"""
    where: CourseLessonSectionExerciseSubBoolExp
  ): [CourseLessonSectionExerciseSub!]!

  """
  fetch data from the table in a streaming manner: "course_lesson_section"
  """
  courseLessonSectionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseLessonSectionStreamCursorInput]!

    """filter the rows returned"""
    where: CourseLessonSectionBoolExp
  ): [CourseLessonSection!]!

  """
  fetch data from the table in a streaming manner: "course_lesson"
  """
  courseLessonStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseLessonStreamCursorInput]!

    """filter the rows returned"""
    where: CourseLessonBoolExp
  ): [CourseLesson!]!

  """
  fetch data from the table in a streaming manner: "course"
  """
  courseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CourseStreamCursorInput]!

    """filter the rows returned"""
    where: CourseBoolExp
  ): [Course!]!

  """
  fetch data from the table: "document"
  """
  document(
    """distinct select on columns"""
    distinctOn: [DocumentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentOrderBy!]

    """filter the rows returned"""
    where: DocumentBoolExp
  ): [Document!]!

  """
  fetch aggregated fields from the table: "document"
  """
  documentAggregate(
    """distinct select on columns"""
    distinctOn: [DocumentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentOrderBy!]

    """filter the rows returned"""
    where: DocumentBoolExp
  ): DocumentAggregate!

  """
  fetch data from the table: "document_block"
  """
  documentBlock(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!

  """
  fetch aggregated fields from the table: "document_block"
  """
  documentBlockAggregate(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): DocumentBlockAggregate!

  """fetch data from the table: "document_block" using primary key columns"""
  documentBlockByPk(id: uuid!): DocumentBlock

  """
  fetch data from the table: "document_block_kind"
  """
  documentBlockKind(
    """distinct select on columns"""
    distinctOn: [DocumentBlockKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockKindOrderBy!]

    """filter the rows returned"""
    where: DocumentBlockKindBoolExp
  ): [DocumentBlockKind!]!

  """
  fetch data from the table: "document_block_kind" using primary key columns
  """
  documentBlockKindByPk(id: String!): DocumentBlockKind

  """
  fetch data from the table in a streaming manner: "document_block_kind"
  """
  documentBlockKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DocumentBlockKindStreamCursorInput]!

    """filter the rows returned"""
    where: DocumentBlockKindBoolExp
  ): [DocumentBlockKind!]!

  """
  fetch data from the table in a streaming manner: "document_block"
  """
  documentBlockStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DocumentBlockStreamCursorInput]!

    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!

  """fetch data from the table: "document" using primary key columns"""
  documentByPk(id: uuid!): Document

  """
  fetch data from the table: "document_kind"
  """
  documentKind(
    """distinct select on columns"""
    distinctOn: [DocumentKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DocumentKindOrderBy!]

    """filter the rows returned"""
    where: DocumentKindBoolExp
  ): [DocumentKind!]!

  """fetch data from the table: "document_kind" using primary key columns"""
  documentKindByPk(id: String!): DocumentKind

  """
  fetch data from the table in a streaming manner: "document_kind"
  """
  documentKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DocumentKindStreamCursorInput]!

    """filter the rows returned"""
    where: DocumentKindBoolExp
  ): [DocumentKind!]!

  """
  fetch data from the table in a streaming manner: "document"
  """
  documentStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DocumentStreamCursorInput]!

    """filter the rows returned"""
    where: DocumentBoolExp
  ): [Document!]!

  """
  fetch data from the table: "event"
  """
  event(
    """distinct select on columns"""
    distinctOn: [EventSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventOrderBy!]

    """filter the rows returned"""
    where: EventBoolExp
  ): [Event!]!

  """
  fetch aggregated fields from the table: "event"
  """
  eventAggregate(
    """distinct select on columns"""
    distinctOn: [EventSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventOrderBy!]

    """filter the rows returned"""
    where: EventBoolExp
  ): EventAggregate!

  """
  fetch data from the table: "event_attendee"
  """
  eventAttendee(
    """distinct select on columns"""
    distinctOn: [EventAttendeeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAttendeeOrderBy!]

    """filter the rows returned"""
    where: EventAttendeeBoolExp
  ): [EventAttendee!]!

  """
  fetch aggregated fields from the table: "event_attendee"
  """
  eventAttendeeAggregate(
    """distinct select on columns"""
    distinctOn: [EventAttendeeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAttendeeOrderBy!]

    """filter the rows returned"""
    where: EventAttendeeBoolExp
  ): EventAttendeeAggregate!

  """fetch data from the table: "event_attendee" using primary key columns"""
  eventAttendeeByPk(id: uuid!): EventAttendee

  """
  fetch data from the table in a streaming manner: "event_attendee"
  """
  eventAttendeeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventAttendeeStreamCursorInput]!

    """filter the rows returned"""
    where: EventAttendeeBoolExp
  ): [EventAttendee!]!

  """
  fetch data from the table: "event_availability"
  """
  eventAvailability(
    """distinct select on columns"""
    distinctOn: [EventAvailabilitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityBoolExp
  ): [EventAvailability!]!

  """
  fetch aggregated fields from the table: "event_availability"
  """
  eventAvailabilityAggregate(
    """distinct select on columns"""
    distinctOn: [EventAvailabilitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityBoolExp
  ): EventAvailabilityAggregate!

  """
  fetch data from the table: "event_availability" using primary key columns
  """
  eventAvailabilityByPk(id: uuid!): EventAvailability

  """
  fetch data from the table: "event_availability_kind"
  """
  eventAvailabilityKind(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityKindOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityKindBoolExp
  ): [EventAvailabilityKind!]!

  """
  fetch data from the table: "event_availability_kind" using primary key columns
  """
  eventAvailabilityKindByPk(id: String!): EventAvailabilityKind

  """
  fetch data from the table in a streaming manner: "event_availability_kind"
  """
  eventAvailabilityKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventAvailabilityKindStreamCursorInput]!

    """filter the rows returned"""
    where: EventAvailabilityKindBoolExp
  ): [EventAvailabilityKind!]!

  """
  fetch data from the table: "event_availability_override"
  """
  eventAvailabilityOverride(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityOverrideSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOverrideOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityOverrideBoolExp
  ): [EventAvailabilityOverride!]!

  """
  fetch aggregated fields from the table: "event_availability_override"
  """
  eventAvailabilityOverrideAggregate(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityOverrideSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityOverrideOrderBy!]

    """filter the rows returned"""
    where: EventAvailabilityOverrideBoolExp
  ): EventAvailabilityOverrideAggregate!

  """
  fetch data from the table: "event_availability_override" using primary key columns
  """
  eventAvailabilityOverrideByPk(id: uuid!): EventAvailabilityOverride

  """
  fetch data from the table in a streaming manner: "event_availability_override"
  """
  eventAvailabilityOverrideStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventAvailabilityOverrideStreamCursorInput]!

    """filter the rows returned"""
    where: EventAvailabilityOverrideBoolExp
  ): [EventAvailabilityOverride!]!

  """
  fetch data from the table in a streaming manner: "event_availability"
  """
  eventAvailabilityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventAvailabilityStreamCursorInput]!

    """filter the rows returned"""
    where: EventAvailabilityBoolExp
  ): [EventAvailability!]!

  """fetch data from the table: "event" using primary key columns"""
  eventByPk(id: uuid!): Event

  """
  fetch data from the table: "event_kind"
  """
  eventKind(
    """distinct select on columns"""
    distinctOn: [EventKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventKindOrderBy!]

    """filter the rows returned"""
    where: EventKindBoolExp
  ): [EventKind!]!

  """
  fetch aggregated fields from the table: "event_kind"
  """
  eventKindAggregate(
    """distinct select on columns"""
    distinctOn: [EventKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventKindOrderBy!]

    """filter the rows returned"""
    where: EventKindBoolExp
  ): EventKindAggregate!

  """fetch data from the table: "event_kind" using primary key columns"""
  eventKindByPk(id: String!, tenantId: String!): EventKind

  """
  fetch data from the table in a streaming manner: "event_kind"
  """
  eventKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventKindStreamCursorInput]!

    """filter the rows returned"""
    where: EventKindBoolExp
  ): [EventKind!]!

  """
  fetch data from the table: "event_live"
  """
  eventLive(
    """distinct select on columns"""
    distinctOn: [EventLiveSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventLiveOrderBy!]

    """filter the rows returned"""
    where: EventLiveBoolExp
  ): [EventLive!]!

  """
  fetch aggregated fields from the table: "event_live"
  """
  eventLiveAggregate(
    """distinct select on columns"""
    distinctOn: [EventLiveSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventLiveOrderBy!]

    """filter the rows returned"""
    where: EventLiveBoolExp
  ): EventLiveAggregate!

  """fetch data from the table: "event_live" using primary key columns"""
  eventLiveByPk(id: String!): EventLive

  """
  fetch data from the table in a streaming manner: "event_live"
  """
  eventLiveStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventLiveStreamCursorInput]!

    """filter the rows returned"""
    where: EventLiveBoolExp
  ): [EventLive!]!

  """
  fetch data from the table: "event_recurrence"
  """
  eventRecurrence(
    """distinct select on columns"""
    distinctOn: [EventRecurrenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventRecurrenceOrderBy!]

    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): [EventRecurrence!]!

  """
  fetch aggregated fields from the table: "event_recurrence"
  """
  eventRecurrenceAggregate(
    """distinct select on columns"""
    distinctOn: [EventRecurrenceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventRecurrenceOrderBy!]

    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): EventRecurrenceAggregate!

  """
  fetch data from the table: "event_recurrence" using primary key columns
  """
  eventRecurrenceByPk(id: uuid!): EventRecurrence

  """
  fetch data from the table in a streaming manner: "event_recurrence"
  """
  eventRecurrenceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventRecurrenceStreamCursorInput]!

    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): [EventRecurrence!]!

  """
  fetch data from the table in a streaming manner: "event"
  """
  eventStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventStreamCursorInput]!

    """filter the rows returned"""
    where: EventBoolExp
  ): [Event!]!

  """
  fetch data from the table: "event_template"
  """
  eventTemplate(
    """distinct select on columns"""
    distinctOn: [EventTemplateSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateOrderBy!]

    """filter the rows returned"""
    where: EventTemplateBoolExp
  ): [EventTemplate!]!

  """
  fetch aggregated fields from the table: "event_template"
  """
  eventTemplateAggregate(
    """distinct select on columns"""
    distinctOn: [EventTemplateSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateOrderBy!]

    """filter the rows returned"""
    where: EventTemplateBoolExp
  ): EventTemplateAggregate!

  """fetch data from the table: "event_template" using primary key columns"""
  eventTemplateByPk(id: uuid!): EventTemplate

  """
  fetch data from the table in a streaming manner: "event_template"
  """
  eventTemplateStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventTemplateStreamCursorInput]!

    """filter the rows returned"""
    where: EventTemplateBoolExp
  ): [EventTemplate!]!

  """
  fetch data from the table: "event_template_tag"
  """
  eventTemplateTag(
    """distinct select on columns"""
    distinctOn: [EventTemplateTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateTagOrderBy!]

    """filter the rows returned"""
    where: EventTemplateTagBoolExp
  ): [EventTemplateTag!]!

  """
  fetch aggregated fields from the table: "event_template_tag"
  """
  eventTemplateTagAggregate(
    """distinct select on columns"""
    distinctOn: [EventTemplateTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTemplateTagOrderBy!]

    """filter the rows returned"""
    where: EventTemplateTagBoolExp
  ): EventTemplateTagAggregate!

  """
  fetch data from the table: "event_template_tag" using primary key columns
  """
  eventTemplateTagByPk(eventTemplateId: uuid!, tag: String!): EventTemplateTag

  """
  fetch data from the table in a streaming manner: "event_template_tag"
  """
  eventTemplateTagStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventTemplateTagStreamCursorInput]!

    """filter the rows returned"""
    where: EventTemplateTagBoolExp
  ): [EventTemplateTag!]!

  """
  fetch data from the table: "event_ticket_option"
  """
  eventTicketOption(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!

  """
  fetch aggregated fields from the table: "event_ticket_option"
  """
  eventTicketOptionAggregate(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): EventTicketOptionAggregate!

  """
  fetch data from the table: "event_ticket_option" using primary key columns
  """
  eventTicketOptionByPk(eventId: uuid!, productId: uuid!, tenantId: String!): EventTicketOption

  """
  fetch data from the table in a streaming manner: "event_ticket_option"
  """
  eventTicketOptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [EventTicketOptionStreamCursorInput]!

    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!

  """
  fetch data from the table: "game_raffle"
  """
  gameRaffle(
    """distinct select on columns"""
    distinctOn: [GameRaffleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleOrderBy!]

    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): [GameRaffle!]!

  """
  fetch aggregated fields from the table: "game_raffle"
  """
  gameRaffleAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleOrderBy!]

    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): GameRaffleAggregate!

  """fetch data from the table: "game_raffle" using primary key columns"""
  gameRaffleByPk(id: uuid!): GameRaffle

  """
  fetch data from the table: "game_raffle_prize"
  """
  gameRafflePrize(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!

  """
  fetch aggregated fields from the table: "game_raffle_prize"
  """
  gameRafflePrizeAggregate(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): GameRafflePrizeAggregate!

  """
  fetch data from the table: "game_raffle_prize" using primary key columns
  """
  gameRafflePrizeByPk(id: uuid!): GameRafflePrize

  """
  fetch data from the table in a streaming manner: "game_raffle_prize"
  """
  gameRafflePrizeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GameRafflePrizeStreamCursorInput]!

    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!

  """
  fetch data from the table in a streaming manner: "game_raffle"
  """
  gameRaffleStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GameRaffleStreamCursorInput]!

    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): [GameRaffle!]!

  """
  fetch data from the table: "game_raffle_ticket"
  """
  gameRaffleTicket(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): [GameRaffleTicket!]!

  """
  fetch aggregated fields from the table: "game_raffle_ticket"
  """
  gameRaffleTicketAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): GameRaffleTicketAggregate!

  """
  fetch data from the table: "game_raffle_ticket" using primary key columns
  """
  gameRaffleTicketByPk(id: uuid!): GameRaffleTicket

  """
  fetch data from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOption(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!

  """
  fetch aggregated fields from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOptionAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): GameRaffleTicketOptionAggregate!

  """
  fetch data from the table: "game_raffle_ticket_option" using primary key columns
  """
  gameRaffleTicketOptionByPk(id: uuid!): GameRaffleTicketOption

  """
  fetch data from the table in a streaming manner: "game_raffle_ticket_option"
  """
  gameRaffleTicketOptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GameRaffleTicketOptionStreamCursorInput]!

    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!

  """
  fetch data from the table in a streaming manner: "game_raffle_ticket"
  """
  gameRaffleTicketStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GameRaffleTicketStreamCursorInput]!

    """filter the rows returned"""
    where: GameRaffleTicketBoolExp
  ): [GameRaffleTicket!]!

  """
  fetch data from the table: "geo_location"
  """
  geoLocation(
    """distinct select on columns"""
    distinctOn: [GeoLocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GeoLocationOrderBy!]

    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): [GeoLocation!]!

  """
  fetch aggregated fields from the table: "geo_location"
  """
  geoLocationAggregate(
    """distinct select on columns"""
    distinctOn: [GeoLocationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [GeoLocationOrderBy!]

    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): GeoLocationAggregate!

  """fetch data from the table: "geo_location" using primary key columns"""
  geoLocationByPk(id: uuid!): GeoLocation

  """
  fetch data from the table in a streaming manner: "geo_location"
  """
  geoLocationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [GeoLocationStreamCursorInput]!

    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): [GeoLocation!]!

  """
  fetch data from the table: "log"
  """
  log(
    """distinct select on columns"""
    distinctOn: [LogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogOrderBy!]

    """filter the rows returned"""
    where: LogBoolExp
  ): [Log!]!

  """
  fetch data from the table: "log_activity"
  """
  logActivity(
    """distinct select on columns"""
    distinctOn: [LogActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogActivityOrderBy!]

    """filter the rows returned"""
    where: LogActivityBoolExp
  ): [LogActivity!]!

  """
  fetch aggregated fields from the table: "log_activity"
  """
  logActivityAggregate(
    """distinct select on columns"""
    distinctOn: [LogActivitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogActivityOrderBy!]

    """filter the rows returned"""
    where: LogActivityBoolExp
  ): LogActivityAggregate!

  """fetch data from the table: "log_activity" using primary key columns"""
  logActivityByPk(id: uuid!): LogActivity

  """
  fetch data from the table in a streaming manner: "log_activity"
  """
  logActivityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LogActivityStreamCursorInput]!

    """filter the rows returned"""
    where: LogActivityBoolExp
  ): [LogActivity!]!

  """
  fetch aggregated fields from the table: "log"
  """
  logAggregate(
    """distinct select on columns"""
    distinctOn: [LogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogOrderBy!]

    """filter the rows returned"""
    where: LogBoolExp
  ): LogAggregate!

  """
  fetch data from the table: "log_audit"
  """
  logAudit(
    """distinct select on columns"""
    distinctOn: [LogAuditSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogAuditOrderBy!]

    """filter the rows returned"""
    where: LogAuditBoolExp
  ): [LogAudit!]!

  """
  fetch aggregated fields from the table: "log_audit"
  """
  logAuditAggregate(
    """distinct select on columns"""
    distinctOn: [LogAuditSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [LogAuditOrderBy!]

    """filter the rows returned"""
    where: LogAuditBoolExp
  ): LogAuditAggregate!

  """fetch data from the table: "log_audit" using primary key columns"""
  logAuditByPk(id: uuid!): LogAudit

  """
  fetch data from the table in a streaming manner: "log_audit"
  """
  logAuditStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LogAuditStreamCursorInput]!

    """filter the rows returned"""
    where: LogAuditBoolExp
  ): [LogAudit!]!

  """fetch data from the table: "log" using primary key columns"""
  logByPk(id: uuid!): Log

  """
  fetch data from the table in a streaming manner: "log"
  """
  logStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [LogStreamCursorInput]!

    """filter the rows returned"""
    where: LogBoolExp
  ): [Log!]!

  """
  fetch data from the table: "media_item"
  """
  mediaItem(
    """distinct select on columns"""
    distinctOn: [MediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemOrderBy!]

    """filter the rows returned"""
    where: MediaItemBoolExp
  ): [MediaItem!]!

  """
  fetch aggregated fields from the table: "media_item"
  """
  mediaItemAggregate(
    """distinct select on columns"""
    distinctOn: [MediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemOrderBy!]

    """filter the rows returned"""
    where: MediaItemBoolExp
  ): MediaItemAggregate!

  """fetch data from the table: "media_item" using primary key columns"""
  mediaItemByPk(id: String!): MediaItem

  """
  fetch data from the table in a streaming manner: "media_item"
  """
  mediaItemStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MediaItemStreamCursorInput]!

    """filter the rows returned"""
    where: MediaItemBoolExp
  ): [MediaItem!]!

  """
  fetch data from the table: "media_item_tag"
  """
  mediaItemTag(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!

  """
  fetch aggregated fields from the table: "media_item_tag"
  """
  mediaItemTagAggregate(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): MediaItemTagAggregate!

  """fetch data from the table: "media_item_tag" using primary key columns"""
  mediaItemTagByPk(mediaItemId: String!, tag: String!): MediaItemTag

  """
  fetch data from the table in a streaming manner: "media_item_tag"
  """
  mediaItemTagStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MediaItemTagStreamCursorInput]!

    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!

  """
  fetch data from the table: "media_kind"
  """
  mediaKind(
    """distinct select on columns"""
    distinctOn: [MediaKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MediaKindOrderBy!]

    """filter the rows returned"""
    where: MediaKindBoolExp
  ): [MediaKind!]!

  """fetch data from the table: "media_kind" using primary key columns"""
  mediaKindByPk(id: String!): MediaKind

  """
  fetch data from the table in a streaming manner: "media_kind"
  """
  mediaKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [MediaKindStreamCursorInput]!

    """filter the rows returned"""
    where: MediaKindBoolExp
  ): [MediaKind!]!

  """
  fetch data from the table: "notification"
  """
  notification(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """
  fetch aggregated fields from the table: "notification"
  """
  notificationAggregate(
    """distinct select on columns"""
    distinctOn: [NotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NotificationOrderBy!]

    """filter the rows returned"""
    where: NotificationBoolExp
  ): NotificationAggregate!

  """fetch data from the table: "notification" using primary key columns"""
  notificationByPk(id: uuid!): Notification

  """
  fetch data from the table in a streaming manner: "notification"
  """
  notificationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NotificationStreamCursorInput]!

    """filter the rows returned"""
    where: NotificationBoolExp
  ): [Notification!]!

  """
  fetch data from the table: "nutrition_day"
  """
  nutritionDay(
    """distinct select on columns"""
    distinctOn: [NutritionDaySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionDayOrderBy!]

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): [NutritionDay!]!

  """
  fetch aggregated fields from the table: "nutrition_day"
  """
  nutritionDayAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionDaySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionDayOrderBy!]

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): NutritionDayAggregate!

  """fetch data from the table: "nutrition_day" using primary key columns"""
  nutritionDayByPk(id: uuid!): NutritionDay

  """
  fetch data from the table in a streaming manner: "nutrition_day"
  """
  nutritionDayStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NutritionDayStreamCursorInput]!

    """filter the rows returned"""
    where: NutritionDayBoolExp
  ): [NutritionDay!]!

  """
  fetch data from the table: "nutrition_food"
  """
  nutritionFood(
    """distinct select on columns"""
    distinctOn: [NutritionFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionFoodBoolExp
  ): [NutritionFood!]!

  """
  fetch aggregated fields from the table: "nutrition_food"
  """
  nutritionFoodAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionFoodBoolExp
  ): NutritionFoodAggregate!

  """fetch data from the table: "nutrition_food" using primary key columns"""
  nutritionFoodByPk(id: uuid!): NutritionFood

  """
  fetch data from the table in a streaming manner: "nutrition_food"
  """
  nutritionFoodStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NutritionFoodStreamCursorInput]!

    """filter the rows returned"""
    where: NutritionFoodBoolExp
  ): [NutritionFood!]!

  """
  fetch data from the table: "nutrition_meal"
  """
  nutritionMeal(
    """distinct select on columns"""
    distinctOn: [NutritionMealSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealOrderBy!]

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): [NutritionMeal!]!

  """
  fetch aggregated fields from the table: "nutrition_meal"
  """
  nutritionMealAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionMealSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealOrderBy!]

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): NutritionMealAggregate!

  """fetch data from the table: "nutrition_meal" using primary key columns"""
  nutritionMealByPk(id: uuid!): NutritionMeal

  """
  fetch data from the table: "nutrition_meal_food"
  """
  nutritionMealFood(
    """distinct select on columns"""
    distinctOn: [NutritionMealFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): [NutritionMealFood!]!

  """
  fetch aggregated fields from the table: "nutrition_meal_food"
  """
  nutritionMealFoodAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionMealFoodSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionMealFoodOrderBy!]

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): NutritionMealFoodAggregate!

  """
  fetch data from the table: "nutrition_meal_food" using primary key columns
  """
  nutritionMealFoodByPk(foodId: uuid!, mealId: uuid!): NutritionMealFood

  """
  fetch data from the table in a streaming manner: "nutrition_meal_food"
  """
  nutritionMealFoodStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NutritionMealFoodStreamCursorInput]!

    """filter the rows returned"""
    where: NutritionMealFoodBoolExp
  ): [NutritionMealFood!]!

  """
  fetch data from the table in a streaming manner: "nutrition_meal"
  """
  nutritionMealStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NutritionMealStreamCursorInput]!

    """filter the rows returned"""
    where: NutritionMealBoolExp
  ): [NutritionMeal!]!

  """
  fetch data from the table: "nutrition_plan"
  """
  nutritionPlan(
    """distinct select on columns"""
    distinctOn: [NutritionPlanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionPlanOrderBy!]

    """filter the rows returned"""
    where: NutritionPlanBoolExp
  ): [NutritionPlan!]!

  """
  fetch aggregated fields from the table: "nutrition_plan"
  """
  nutritionPlanAggregate(
    """distinct select on columns"""
    distinctOn: [NutritionPlanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [NutritionPlanOrderBy!]

    """filter the rows returned"""
    where: NutritionPlanBoolExp
  ): NutritionPlanAggregate!

  """fetch data from the table: "nutrition_plan" using primary key columns"""
  nutritionPlanByPk(id: uuid!): NutritionPlan

  """
  fetch data from the table in a streaming manner: "nutrition_plan"
  """
  nutritionPlanStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [NutritionPlanStreamCursorInput]!

    """filter the rows returned"""
    where: NutritionPlanBoolExp
  ): [NutritionPlan!]!

  """
  fetch data from the table: "post"
  """
  post(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): [Post!]!

  """
  fetch aggregated fields from the table: "post"
  """
  postAggregate(
    """distinct select on columns"""
    distinctOn: [PostSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostOrderBy!]

    """filter the rows returned"""
    where: PostBoolExp
  ): PostAggregate!

  """fetch data from the table: "post" using primary key columns"""
  postByPk(id: uuid!): Post

  """
  fetch data from the table: "post_comment"
  """
  postComment(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): [PostComment!]!

  """
  fetch aggregated fields from the table: "post_comment"
  """
  postCommentAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentOrderBy!]

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): PostCommentAggregate!

  """fetch data from the table: "post_comment" using primary key columns"""
  postCommentByPk(id: uuid!): PostComment

  """
  fetch data from the table: "post_comment_reaction"
  """
  postCommentReaction(
    """distinct select on columns"""
    distinctOn: [PostCommentReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentReactionOrderBy!]

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): [PostCommentReaction!]!

  """
  fetch aggregated fields from the table: "post_comment_reaction"
  """
  postCommentReactionAggregate(
    """distinct select on columns"""
    distinctOn: [PostCommentReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostCommentReactionOrderBy!]

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): PostCommentReactionAggregate!

  """
  fetch data from the table: "post_comment_reaction" using primary key columns
  """
  postCommentReactionByPk(commentId: uuid!, profileId: uuid!): PostCommentReaction

  """
  fetch data from the table in a streaming manner: "post_comment_reaction"
  """
  postCommentReactionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostCommentReactionStreamCursorInput]!

    """filter the rows returned"""
    where: PostCommentReactionBoolExp
  ): [PostCommentReaction!]!

  """
  fetch data from the table in a streaming manner: "post_comment"
  """
  postCommentStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostCommentStreamCursorInput]!

    """filter the rows returned"""
    where: PostCommentBoolExp
  ): [PostComment!]!

  """
  fetch data from the table: "post_kind"
  """
  postKind(
    """distinct select on columns"""
    distinctOn: [PostKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostKindOrderBy!]

    """filter the rows returned"""
    where: PostKindBoolExp
  ): [PostKind!]!

  """
  fetch aggregated fields from the table: "post_kind"
  """
  postKindAggregate(
    """distinct select on columns"""
    distinctOn: [PostKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostKindOrderBy!]

    """filter the rows returned"""
    where: PostKindBoolExp
  ): PostKindAggregate!

  """fetch data from the table: "post_kind" using primary key columns"""
  postKindByPk(id: String!, tenantId: String!): PostKind

  """
  fetch data from the table in a streaming manner: "post_kind"
  """
  postKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostKindStreamCursorInput]!

    """filter the rows returned"""
    where: PostKindBoolExp
  ): [PostKind!]!

  """
  fetch data from the table: "post_media_item"
  """
  postMediaItem(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): [PostMediaItem!]!

  """
  fetch aggregated fields from the table: "post_media_item"
  """
  postMediaItemAggregate(
    """distinct select on columns"""
    distinctOn: [PostMediaItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostMediaItemOrderBy!]

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): PostMediaItemAggregate!

  """fetch data from the table: "post_media_item" using primary key columns"""
  postMediaItemByPk(id: uuid!): PostMediaItem

  """
  fetch data from the table in a streaming manner: "post_media_item"
  """
  postMediaItemStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostMediaItemStreamCursorInput]!

    """filter the rows returned"""
    where: PostMediaItemBoolExp
  ): [PostMediaItem!]!

  """
  fetch data from the table: "post_reaction"
  """
  postReaction(
    """distinct select on columns"""
    distinctOn: [PostReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionOrderBy!]

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): [PostReaction!]!

  """
  fetch aggregated fields from the table: "post_reaction"
  """
  postReactionAggregate(
    """distinct select on columns"""
    distinctOn: [PostReactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionOrderBy!]

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): PostReactionAggregate!

  """fetch data from the table: "post_reaction" using primary key columns"""
  postReactionByPk(kind: String!, postId: uuid!, profileId: uuid!): PostReaction

  """
  fetch data from the table: "post_reaction_kind"
  """
  postReactionKind(
    """distinct select on columns"""
    distinctOn: [PostReactionKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionKindOrderBy!]

    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): [PostReactionKind!]!

  """
  fetch aggregated fields from the table: "post_reaction_kind"
  """
  postReactionKindAggregate(
    """distinct select on columns"""
    distinctOn: [PostReactionKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostReactionKindOrderBy!]

    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): PostReactionKindAggregate!

  """
  fetch data from the table: "post_reaction_kind" using primary key columns
  """
  postReactionKindByPk(id: String!, tenantId: String!): PostReactionKind

  """
  fetch data from the table in a streaming manner: "post_reaction_kind"
  """
  postReactionKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostReactionKindStreamCursorInput]!

    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): [PostReactionKind!]!

  """
  fetch data from the table in a streaming manner: "post_reaction"
  """
  postReactionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostReactionStreamCursorInput]!

    """filter the rows returned"""
    where: PostReactionBoolExp
  ): [PostReaction!]!

  """
  fetch data from the table in a streaming manner: "post"
  """
  postStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostStreamCursorInput]!

    """filter the rows returned"""
    where: PostBoolExp
  ): [Post!]!

  """
  fetch data from the table: "post_tag"
  """
  postTag(
    """distinct select on columns"""
    distinctOn: [PostTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostTagOrderBy!]

    """filter the rows returned"""
    where: PostTagBoolExp
  ): [PostTag!]!

  """
  fetch aggregated fields from the table: "post_tag"
  """
  postTagAggregate(
    """distinct select on columns"""
    distinctOn: [PostTagSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PostTagOrderBy!]

    """filter the rows returned"""
    where: PostTagBoolExp
  ): PostTagAggregate!

  """fetch data from the table: "post_tag" using primary key columns"""
  postTagByPk(postId: uuid!, tag: String!): PostTag

  """
  fetch data from the table in a streaming manner: "post_tag"
  """
  postTagStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PostTagStreamCursorInput]!

    """filter the rows returned"""
    where: PostTagBoolExp
  ): [PostTag!]!

  """
  fetch data from the table: "profile"
  """
  profile(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]

    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!

  """
  fetch aggregated fields from the table: "profile"
  """
  profileAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]

    """filter the rows returned"""
    where: ProfileBoolExp
  ): ProfileAggregate!

  """
  fetch data from the table: "profile_attribute"
  """
  profileAttribute(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!

  """
  fetch aggregated fields from the table: "profile_attribute"
  """
  profileAttributeAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): ProfileAttributeAggregate!

  """
  fetch data from the table: "profile_attribute" using primary key columns
  """
  profileAttributeByPk(id: String!, profileId: uuid!): ProfileAttribute

  """
  fetch data from the table: "profile_attribute_kind"
  """
  profileAttributeKind(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeKindOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeKindBoolExp
  ): [ProfileAttributeKind!]!

  """
  fetch aggregated fields from the table: "profile_attribute_kind"
  """
  profileAttributeKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeKindOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeKindBoolExp
  ): ProfileAttributeKindAggregate!

  """
  fetch data from the table: "profile_attribute_kind" using primary key columns
  """
  profileAttributeKindByPk(id: String!, tenantId: String!): ProfileAttributeKind

  """
  fetch data from the table in a streaming manner: "profile_attribute_kind"
  """
  profileAttributeKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileAttributeKindStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileAttributeKindBoolExp
  ): [ProfileAttributeKind!]!

  """
  fetch data from the table: "profile_attribute_option"
  """
  profileAttributeOption(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOptionOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeOptionBoolExp
  ): [ProfileAttributeOption!]!

  """
  fetch aggregated fields from the table: "profile_attribute_option"
  """
  profileAttributeOptionAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOptionOrderBy!]

    """filter the rows returned"""
    where: ProfileAttributeOptionBoolExp
  ): ProfileAttributeOptionAggregate!

  """
  fetch data from the table: "profile_attribute_option" using primary key columns
  """
  profileAttributeOptionByPk(id: String!, tenantId: String!): ProfileAttributeOption

  """
  fetch data from the table in a streaming manner: "profile_attribute_option"
  """
  profileAttributeOptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileAttributeOptionStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileAttributeOptionBoolExp
  ): [ProfileAttributeOption!]!

  """
  fetch data from the table in a streaming manner: "profile_attribute"
  """
  profileAttributeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileAttributeStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!

  """fetch data from the table: "profile" using primary key columns"""
  profileByPk(id: uuid!): Profile

  """
  fetch data from the table: "profile_device"
  """
  profileDevice(
    """distinct select on columns"""
    distinctOn: [ProfileDeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileDeviceOrderBy!]

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): [ProfileDevice!]!

  """
  fetch aggregated fields from the table: "profile_device"
  """
  profileDeviceAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileDeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileDeviceOrderBy!]

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): ProfileDeviceAggregate!

  """fetch data from the table: "profile_device" using primary key columns"""
  profileDeviceByPk(
    """unique push token"""
    id: String!
  ): ProfileDevice

  """
  fetch data from the table in a streaming manner: "profile_device"
  """
  profileDeviceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileDeviceStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileDeviceBoolExp
  ): [ProfileDevice!]!

  """
  fetch data from the table: "profile_follower"
  """
  profileFollower(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!

  """
  fetch aggregated fields from the table: "profile_follower"
  """
  profileFollowerAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!

  """
  fetch data from the table: "profile_follower" using primary key columns
  """
  profileFollowerByPk(followedProfileId: uuid!, followerId: uuid!): ProfileFollower

  """
  fetch data from the table in a streaming manner: "profile_follower"
  """
  profileFollowerStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileFollowerStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!

  """
  fetch data from the table: "profile_health_configuration"
  """
  profileHealthConfiguration(
    """distinct select on columns"""
    distinctOn: [ProfileHealthConfigurationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileHealthConfigurationOrderBy!]

    """filter the rows returned"""
    where: ProfileHealthConfigurationBoolExp
  ): [ProfileHealthConfiguration!]!

  """
  fetch aggregated fields from the table: "profile_health_configuration"
  """
  profileHealthConfigurationAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileHealthConfigurationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileHealthConfigurationOrderBy!]

    """filter the rows returned"""
    where: ProfileHealthConfigurationBoolExp
  ): ProfileHealthConfigurationAggregate!

  """
  fetch data from the table: "profile_health_configuration" using primary key columns
  """
  profileHealthConfigurationByPk(id: uuid!): ProfileHealthConfiguration

  """
  fetch data from the table in a streaming manner: "profile_health_configuration"
  """
  profileHealthConfigurationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileHealthConfigurationStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileHealthConfigurationBoolExp
  ): [ProfileHealthConfiguration!]!

  """
  fetch data from the table: "profile_identity"
  """
  profileIdentity(
    """distinct select on columns"""
    distinctOn: [ProfileIdentitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileIdentityOrderBy!]

    """filter the rows returned"""
    where: ProfileIdentityBoolExp
  ): [ProfileIdentity!]!

  """
  fetch aggregated fields from the table: "profile_identity"
  """
  profileIdentityAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileIdentitySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileIdentityOrderBy!]

    """filter the rows returned"""
    where: ProfileIdentityBoolExp
  ): ProfileIdentityAggregate!

  """
  fetch data from the table: "profile_identity" using primary key columns
  """
  profileIdentityByPk(id: uuid!): ProfileIdentity

  """
  fetch data from the table in a streaming manner: "profile_identity"
  """
  profileIdentityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileIdentityStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileIdentityBoolExp
  ): [ProfileIdentity!]!

  """
  fetch data from the table: "profile_kind"
  """
  profileKind(
    """distinct select on columns"""
    distinctOn: [ProfileKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileKindOrderBy!]

    """filter the rows returned"""
    where: ProfileKindBoolExp
  ): [ProfileKind!]!

  """
  fetch aggregated fields from the table: "profile_kind"
  """
  profileKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileKindOrderBy!]

    """filter the rows returned"""
    where: ProfileKindBoolExp
  ): ProfileKindAggregate!

  """fetch data from the table: "profile_kind" using primary key columns"""
  profileKindByPk(
    """anonymous_user, user, service_provider, artist, community, etc."""
    id: String!
    tenantId: String!
  ): ProfileKind

  """
  fetch data from the table in a streaming manner: "profile_kind"
  """
  profileKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileKindStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileKindBoolExp
  ): [ProfileKind!]!

  """
  fetch data from the table: "profile_manager"
  """
  profileManager(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): [ProfileManager!]!

  """
  fetch aggregated fields from the table: "profile_manager"
  """
  profileManagerAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileManagerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): ProfileManagerAggregate!

  """fetch data from the table: "profile_manager" using primary key columns"""
  profileManagerByPk(managedProfileId: uuid!, managerId: uuid!): ProfileManager

  """
  fetch data from the table: "profile_manager_kind"
  """
  profileManagerKind(
    """distinct select on columns"""
    distinctOn: [ProfileManagerKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerKindOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerKindBoolExp
  ): [ProfileManagerKind!]!

  """
  fetch aggregated fields from the table: "profile_manager_kind"
  """
  profileManagerKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileManagerKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileManagerKindOrderBy!]

    """filter the rows returned"""
    where: ProfileManagerKindBoolExp
  ): ProfileManagerKindAggregate!

  """
  fetch data from the table: "profile_manager_kind" using primary key columns
  """
  profileManagerKindByPk(
    """owner, manager, etc."""
    id: String!
    tenantId: String!
  ): ProfileManagerKind

  """
  fetch data from the table in a streaming manner: "profile_manager_kind"
  """
  profileManagerKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileManagerKindStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileManagerKindBoolExp
  ): [ProfileManagerKind!]!

  """
  fetch data from the table in a streaming manner: "profile_manager"
  """
  profileManagerStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileManagerStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileManagerBoolExp
  ): [ProfileManager!]!

  """
  fetch data from the table: "profile_stat"
  """
  profileStat(
    """distinct select on columns"""
    distinctOn: [ProfileStatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatOrderBy!]

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): [ProfileStat!]!

  """
  fetch aggregated fields from the table: "profile_stat"
  """
  profileStatAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileStatSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatOrderBy!]

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): ProfileStatAggregate!

  """fetch data from the table: "profile_stat" using primary key columns"""
  profileStatByPk(id: uuid!): ProfileStat

  """
  fetch data from the table: "profile_stat_kind"
  """
  profileStatKind(
    """distinct select on columns"""
    distinctOn: [ProfileStatKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatKindOrderBy!]

    """filter the rows returned"""
    where: ProfileStatKindBoolExp
  ): [ProfileStatKind!]!

  """
  fetch aggregated fields from the table: "profile_stat_kind"
  """
  profileStatKindAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileStatKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ProfileStatKindOrderBy!]

    """filter the rows returned"""
    where: ProfileStatKindBoolExp
  ): ProfileStatKindAggregate!

  """
  fetch data from the table: "profile_stat_kind" using primary key columns
  """
  profileStatKindByPk(id: String!, tenantId: String!): ProfileStatKind

  """
  fetch data from the table in a streaming manner: "profile_stat_kind"
  """
  profileStatKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileStatKindStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileStatKindBoolExp
  ): [ProfileStatKind!]!

  """
  fetch data from the table in a streaming manner: "profile_stat"
  """
  profileStatStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileStatStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileStatBoolExp
  ): [ProfileStat!]!

  """
  fetch data from the table in a streaming manner: "profile"
  """
  profileStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProfileStreamCursorInput]!

    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!

  """
  fetch data from the table: "question"
  """
  question(
    """distinct select on columns"""
    distinctOn: [QuestionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOrderBy!]

    """filter the rows returned"""
    where: QuestionBoolExp
  ): [Question!]!

  """
  fetch aggregated fields from the table: "question"
  """
  questionAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOrderBy!]

    """filter the rows returned"""
    where: QuestionBoolExp
  ): QuestionAggregate!

  """fetch data from the table: "question" using primary key columns"""
  questionByPk(id: uuid!): Question

  """
  fetch data from the table: "question_kind"
  """
  questionKind(
    """distinct select on columns"""
    distinctOn: [QuestionKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionKindOrderBy!]

    """filter the rows returned"""
    where: QuestionKindBoolExp
  ): [QuestionKind!]!

  """fetch data from the table: "question_kind" using primary key columns"""
  questionKindByPk(id: String!): QuestionKind

  """
  fetch data from the table in a streaming manner: "question_kind"
  """
  questionKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [QuestionKindStreamCursorInput]!

    """filter the rows returned"""
    where: QuestionKindBoolExp
  ): [QuestionKind!]!

  """
  fetch data from the table: "question_option"
  """
  questionOption(
    """distinct select on columns"""
    distinctOn: [QuestionOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOptionOrderBy!]

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): [QuestionOption!]!

  """
  fetch aggregated fields from the table: "question_option"
  """
  questionOptionAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionOptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionOptionOrderBy!]

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): QuestionOptionAggregate!

  """fetch data from the table: "question_option" using primary key columns"""
  questionOptionByPk(id: uuid!): QuestionOption

  """
  fetch data from the table in a streaming manner: "question_option"
  """
  questionOptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [QuestionOptionStreamCursorInput]!

    """filter the rows returned"""
    where: QuestionOptionBoolExp
  ): [QuestionOption!]!

  """
  fetch data from the table: "question_response"
  """
  questionResponse(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): [QuestionResponse!]!

  """
  fetch aggregated fields from the table: "question_response"
  """
  questionResponseAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionResponseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionResponseOrderBy!]

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): QuestionResponseAggregate!

  """
  fetch data from the table: "question_response" using primary key columns
  """
  questionResponseByPk(id: uuid!): QuestionResponse

  """
  fetch data from the table in a streaming manner: "question_response"
  """
  questionResponseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [QuestionResponseStreamCursorInput]!

    """filter the rows returned"""
    where: QuestionResponseBoolExp
  ): [QuestionResponse!]!

  """
  fetch data from the table: "question_set"
  """
  questionSet(
    """distinct select on columns"""
    distinctOn: [QuestionSetSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionSetOrderBy!]

    """filter the rows returned"""
    where: QuestionSetBoolExp
  ): [QuestionSet!]!

  """
  fetch aggregated fields from the table: "question_set"
  """
  questionSetAggregate(
    """distinct select on columns"""
    distinctOn: [QuestionSetSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [QuestionSetOrderBy!]

    """filter the rows returned"""
    where: QuestionSetBoolExp
  ): QuestionSetAggregate!

  """fetch data from the table: "question_set" using primary key columns"""
  questionSetByPk(id: uuid!): QuestionSet

  """
  fetch data from the table in a streaming manner: "question_set"
  """
  questionSetStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [QuestionSetStreamCursorInput]!

    """filter the rows returned"""
    where: QuestionSetBoolExp
  ): [QuestionSet!]!

  """
  fetch data from the table in a streaming manner: "question"
  """
  questionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [QuestionStreamCursorInput]!

    """filter the rows returned"""
    where: QuestionBoolExp
  ): [Question!]!

  """
  fetch data from the table: "shop_order"
  """
  shopOrder(
    """distinct select on columns"""
    distinctOn: [ShopOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderOrderBy!]

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): [ShopOrder!]!

  """
  fetch aggregated fields from the table: "shop_order"
  """
  shopOrderAggregate(
    """distinct select on columns"""
    distinctOn: [ShopOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderOrderBy!]

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): ShopOrderAggregate!

  """fetch data from the table: "shop_order" using primary key columns"""
  shopOrderByPk(id: uuid!): ShopOrder

  """
  fetch data from the table: "shop_order_item"
  """
  shopOrderItem(
    """distinct select on columns"""
    distinctOn: [ShopOrderItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderItemOrderBy!]

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): [ShopOrderItem!]!

  """
  fetch aggregated fields from the table: "shop_order_item"
  """
  shopOrderItemAggregate(
    """distinct select on columns"""
    distinctOn: [ShopOrderItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopOrderItemOrderBy!]

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): ShopOrderItemAggregate!

  """fetch data from the table: "shop_order_item" using primary key columns"""
  shopOrderItemByPk(id: uuid!): ShopOrderItem

  """
  fetch data from the table in a streaming manner: "shop_order_item"
  """
  shopOrderItemStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ShopOrderItemStreamCursorInput]!

    """filter the rows returned"""
    where: ShopOrderItemBoolExp
  ): [ShopOrderItem!]!

  """
  fetch data from the table in a streaming manner: "shop_order"
  """
  shopOrderStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ShopOrderStreamCursorInput]!

    """filter the rows returned"""
    where: ShopOrderBoolExp
  ): [ShopOrder!]!

  """
  fetch data from the table: "shop_product"
  """
  shopProduct(
    """distinct select on columns"""
    distinctOn: [ShopProductSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductOrderBy!]

    """filter the rows returned"""
    where: ShopProductBoolExp
  ): [ShopProduct!]!

  """
  fetch aggregated fields from the table: "shop_product"
  """
  shopProductAggregate(
    """distinct select on columns"""
    distinctOn: [ShopProductSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductOrderBy!]

    """filter the rows returned"""
    where: ShopProductBoolExp
  ): ShopProductAggregate!

  """fetch data from the table: "shop_product" using primary key columns"""
  shopProductByPk(id: uuid!): ShopProduct

  """
  fetch data from the table: "shop_product_kind"
  """
  shopProductKind(
    """distinct select on columns"""
    distinctOn: [ShopProductKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductKindOrderBy!]

    """filter the rows returned"""
    where: ShopProductKindBoolExp
  ): [ShopProductKind!]!

  """
  fetch data from the table: "shop_product_kind" using primary key columns
  """
  shopProductKindByPk(id: String!): ShopProductKind

  """
  fetch data from the table in a streaming manner: "shop_product_kind"
  """
  shopProductKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ShopProductKindStreamCursorInput]!

    """filter the rows returned"""
    where: ShopProductKindBoolExp
  ): [ShopProductKind!]!

  """
  fetch data from the table: "shop_product_price"
  """
  shopProductPrice(
    """distinct select on columns"""
    distinctOn: [ShopProductPriceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductPriceOrderBy!]

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): [ShopProductPrice!]!

  """
  fetch aggregated fields from the table: "shop_product_price"
  """
  shopProductPriceAggregate(
    """distinct select on columns"""
    distinctOn: [ShopProductPriceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopProductPriceOrderBy!]

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): ShopProductPriceAggregate!

  """
  fetch data from the table: "shop_product_price" using primary key columns
  """
  shopProductPriceByPk(id: uuid!): ShopProductPrice

  """
  fetch data from the table in a streaming manner: "shop_product_price"
  """
  shopProductPriceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ShopProductPriceStreamCursorInput]!

    """filter the rows returned"""
    where: ShopProductPriceBoolExp
  ): [ShopProductPrice!]!

  """
  fetch data from the table in a streaming manner: "shop_product"
  """
  shopProductStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ShopProductStreamCursorInput]!

    """filter the rows returned"""
    where: ShopProductBoolExp
  ): [ShopProduct!]!

  """
  fetch data from the table: "shop_subscription"
  """
  shopSubscription(
    """distinct select on columns"""
    distinctOn: [ShopSubscriptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopSubscriptionOrderBy!]

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): [ShopSubscription!]!

  """
  fetch aggregated fields from the table: "shop_subscription"
  """
  shopSubscriptionAggregate(
    """distinct select on columns"""
    distinctOn: [ShopSubscriptionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ShopSubscriptionOrderBy!]

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): ShopSubscriptionAggregate!

  """
  fetch data from the table: "shop_subscription" using primary key columns
  """
  shopSubscriptionByPk(id: uuid!): ShopSubscription

  """
  fetch data from the table in a streaming manner: "shop_subscription"
  """
  shopSubscriptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ShopSubscriptionStreamCursorInput]!

    """filter the rows returned"""
    where: ShopSubscriptionBoolExp
  ): [ShopSubscription!]!

  """
  fetch data from the table: "tenant"
  """
  tenant(
    """distinct select on columns"""
    distinctOn: [TenantSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantOrderBy!]

    """filter the rows returned"""
    where: TenantBoolExp
  ): [Tenant!]!

  """
  fetch data from the table: "tenant_app"
  """
  tenantApp(
    """distinct select on columns"""
    distinctOn: [TenantAppSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppOrderBy!]

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): [TenantApp!]!

  """
  fetch aggregated fields from the table: "tenant_app"
  """
  tenantAppAggregate(
    """distinct select on columns"""
    distinctOn: [TenantAppSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppOrderBy!]

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): TenantAppAggregate!

  """fetch data from the table: "tenant_app" using primary key columns"""
  tenantAppByPk(id: String!, tenantId: String!): TenantApp

  """
  fetch data from the table: "tenant_app_release"
  """
  tenantAppRelease(
    """distinct select on columns"""
    distinctOn: [TenantAppReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppReleaseOrderBy!]

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): [TenantAppRelease!]!

  """
  fetch aggregated fields from the table: "tenant_app_release"
  """
  tenantAppReleaseAggregate(
    """distinct select on columns"""
    distinctOn: [TenantAppReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TenantAppReleaseOrderBy!]

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): TenantAppReleaseAggregate!

  """
  fetch data from the table: "tenant_app_release" using primary key columns
  """
  tenantAppReleaseByPk(id: uuid!): TenantAppRelease

  """
  fetch data from the table in a streaming manner: "tenant_app_release"
  """
  tenantAppReleaseStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TenantAppReleaseStreamCursorInput]!

    """filter the rows returned"""
    where: TenantAppReleaseBoolExp
  ): [TenantAppRelease!]!

  """
  fetch data from the table in a streaming manner: "tenant_app"
  """
  tenantAppStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TenantAppStreamCursorInput]!

    """filter the rows returned"""
    where: TenantAppBoolExp
  ): [TenantApp!]!

  """fetch data from the table: "tenant" using primary key columns"""
  tenantByPk(
    """url friendly version of name"""
    id: String!
  ): Tenant

  """
  fetch data from the table in a streaming manner: "tenant"
  """
  tenantStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [TenantStreamCursorInput]!

    """filter the rows returned"""
    where: TenantBoolExp
  ): [Tenant!]!

  """
  fetch data from the table: "value_kind"
  """
  valueKind(
    """distinct select on columns"""
    distinctOn: [ValueKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValueKindOrderBy!]

    """filter the rows returned"""
    where: ValueKindBoolExp
  ): [ValueKind!]!

  """fetch data from the table: "value_kind" using primary key columns"""
  valueKindByPk(id: String!): ValueKind

  """
  fetch data from the table in a streaming manner: "value_kind"
  """
  valueKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ValueKindStreamCursorInput]!

    """filter the rows returned"""
    where: ValueKindBoolExp
  ): [ValueKind!]!

  """
  fetch data from the table: "visibility_kind"
  """
  visibilityKind(
    """distinct select on columns"""
    distinctOn: [VisibilityKindSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VisibilityKindOrderBy!]

    """filter the rows returned"""
    where: VisibilityKindBoolExp
  ): [VisibilityKind!]!

  """fetch data from the table: "visibility_kind" using primary key columns"""
  visibilityKindByPk(id: String!): VisibilityKind

  """
  fetch data from the table in a streaming manner: "visibility_kind"
  """
  visibilityKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [VisibilityKindStreamCursorInput]!

    """filter the rows returned"""
    where: VisibilityKindBoolExp
  ): [VisibilityKind!]!
}

input tenantAppAggregateBoolExpCount {
  arguments: [TenantAppSelectColumn!]
  distinct: Boolean
  filter: TenantAppBoolExp
  predicate: IntComparisonExp!
}

input tenantAppReleaseAggregateBoolExpBool_and {
  arguments: TenantAppReleaseSelectColumnTenantAppReleaseAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TenantAppReleaseBoolExp
  predicate: BooleanComparisonExp!
}

input tenantAppReleaseAggregateBoolExpBool_or {
  arguments: TenantAppReleaseSelectColumnTenantAppReleaseAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TenantAppReleaseBoolExp
  predicate: BooleanComparisonExp!
}

input tenantAppReleaseAggregateBoolExpCount {
  arguments: [TenantAppReleaseSelectColumn!]
  distinct: Boolean
  filter: TenantAppReleaseBoolExp
  predicate: IntComparisonExp!
}

scalar time

scalar timestamptz

scalar timetz

scalar uuid